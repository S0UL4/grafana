{"ast":null,"code":"import { Observable } from 'rxjs';\nimport { toDataQueryResponse } from '@grafana/runtime';\n\n/**\n * A retry strategy specifically for cloud watch logs query. Cloud watch logs queries need first starting the query\n * and the polling for the results. The start query can fail because of the concurrent queries rate limit,\n * and so we have to retry the start query call if there is already lot of queries running.\n *\n * As we send multiple queries in a single request some can fail and some can succeed and we have to also handle those\n * cases by only retrying the failed queries. We retry the failed queries until we hit the time limit or all queries\n * succeed and only then we pass the data forward. This means we wait longer but makes the code a bit simpler as we\n * can treat starting the query and polling as steps in a pipeline.\n * @param queryFun\n * @param targets\n * @param options\n */\nexport function runWithRetry(queryFun, targets, timeoutFunc) {\n  const startTime = new Date();\n  let retries = 0;\n  let timerID;\n  let subscription;\n  let collected = {};\n\n  const retryWaitFunction = retry => {\n    return Math.pow(2, retry) * 1000 + Math.random() * 100;\n  };\n\n  return new Observable(observer => {\n    // Run function is where the logic takes place. We have it in a function so we can call it recursively.\n    function run(currentQueryParams) {\n      subscription = queryFun(currentQueryParams).subscribe({\n        next(frames) {\n          // In case we successfully finished, merge the current response with whatever we already collected.\n          const collectedPreviously = toDataQueryResponse({\n            data: {\n              results: collected\n            }\n          }).data || [];\n          observer.next({\n            frames: [...collectedPreviously, ...frames]\n          });\n          observer.complete();\n        },\n\n        error(error) {\n          // In case of error we first try to figure out what kind of error it is\n          // This means it was a generic 500 error probably so we just pass it on\n          if (typeof error === 'string') {\n            observer.error(error);\n            return;\n          } // In case of multiple queries this some can error while some may be ok\n\n\n          const errorData = splitErrorData(error);\n\n          if (!errorData) {\n            // Not sure what happened but the error structure wasn't what we expected\n            observer.error(error);\n            return;\n          }\n\n          if (!errorData.errors.length) {\n            // So there is no limit error but some other errors so nothing to retry so we just pass it as it would be\n            // otherwise.\n            observer.error(error);\n            return;\n          }\n\n          if (timeoutFunc(retries, startTime.valueOf())) {\n            // We timed out but we could have started some queries\n            if (Object.keys(collected).length || Object.keys(errorData.good).length) {\n              var _errorData$good, _collected, _dataResponse$error;\n\n              const dataResponse = toDataQueryResponse({\n                data: {\n                  results: Object.assign({}, (_errorData$good = errorData.good) !== null && _errorData$good !== void 0 ? _errorData$good : {}, (_collected = collected) !== null && _collected !== void 0 ? _collected : {})\n                }\n              });\n              dataResponse.error = Object.assign({}, (_dataResponse$error = dataResponse.error) !== null && _dataResponse$error !== void 0 ? _dataResponse$error : {}, {\n                message: `Some queries timed out: ${errorData.errorMessage}`\n              }); // So we consider this a partial success and pass the data forward but also with error to be shown to\n              // the user.\n\n              observer.next({\n                error: dataResponse.error,\n                frames: dataResponse.data\n              });\n              observer.complete();\n            } else {\n              var _error$data$results, _error$data;\n\n              // So we timed out and there was no data to pass forward so we just pass the error\n              const dataResponse = toDataQueryResponse({\n                data: {\n                  results: (_error$data$results = (_error$data = error.data) === null || _error$data === void 0 ? void 0 : _error$data.results) !== null && _error$data$results !== void 0 ? _error$data$results : {}\n                }\n              });\n              observer.error(dataResponse.error);\n            }\n\n            return;\n          }\n\n          collected = Object.assign({}, collected, errorData.good);\n          timerID = setTimeout(() => {\n            retries++;\n            run(errorData.errors);\n          }, // We want to know how long to wait for the next retry. First time this will be 0.\n          retryWaitFunction(retries + 1));\n        }\n\n      });\n    }\n\n    run(targets);\n    return () => {\n      // We clear only the latest timer and subscription but the observable should complete after one response so\n      // there should not be more things running at the same time.\n      clearTimeout(timerID);\n      subscription.unsubscribe();\n    };\n  });\n}\n\nfunction splitErrorData(error) {\n  var _error$data2;\n\n  const results = (_error$data2 = error.data) === null || _error$data2 === void 0 ? void 0 : _error$data2.results;\n\n  if (!results) {\n    return undefined;\n  }\n\n  return Object.keys(results).reduce((acc, refId) => {\n    var _results$refId$error;\n\n    if ((_results$refId$error = results[refId].error) !== null && _results$refId$error !== void 0 && _results$refId$error.startsWith('LimitExceededException')) {\n      acc.errorMessage = results[refId].error;\n      acc.errors.push(error.config.data.queries.find(q => q.refId === refId));\n    } else {\n      acc.good[refId] = results[refId];\n    }\n\n    return acc;\n  }, {\n    errors: [],\n    good: {},\n    errorMessage: ''\n  });\n}","map":{"version":3,"names":["Observable","toDataQueryResponse","runWithRetry","queryFun","targets","timeoutFunc","startTime","Date","retries","timerID","subscription","collected","retryWaitFunction","retry","Math","pow","random","observer","run","currentQueryParams","subscribe","next","frames","collectedPreviously","data","results","complete","error","errorData","splitErrorData","errors","length","valueOf","Object","keys","good","dataResponse","message","errorMessage","setTimeout","clearTimeout","unsubscribe","undefined","reduce","acc","refId","startsWith","push","config","queries","find","q"],"sources":["/home/soula/grafana/public/app/plugins/datasource/cloudwatch/utils/logsRetry.ts"],"sourcesContent":["import { Observable, Subscription } from 'rxjs';\n\nimport { DataFrame, DataFrameJSON, DataQueryError } from '@grafana/data';\nimport { FetchError, toDataQueryResponse } from '@grafana/runtime';\n\nimport { StartQueryRequest } from '../types';\n\ntype Result = { frames: DataFrameJSON[]; error?: string };\n\n/**\n * A retry strategy specifically for cloud watch logs query. Cloud watch logs queries need first starting the query\n * and the polling for the results. The start query can fail because of the concurrent queries rate limit,\n * and so we have to retry the start query call if there is already lot of queries running.\n *\n * As we send multiple queries in a single request some can fail and some can succeed and we have to also handle those\n * cases by only retrying the failed queries. We retry the failed queries until we hit the time limit or all queries\n * succeed and only then we pass the data forward. This means we wait longer but makes the code a bit simpler as we\n * can treat starting the query and polling as steps in a pipeline.\n * @param queryFun\n * @param targets\n * @param options\n */\nexport function runWithRetry(\n  queryFun: (targets: StartQueryRequest[]) => Observable<DataFrame[]>,\n  targets: StartQueryRequest[],\n  timeoutFunc: (retry: number, startTime: number) => boolean\n): Observable<{ frames: DataFrame[]; error?: DataQueryError }> {\n  const startTime = new Date();\n  let retries = 0;\n  let timerID: any;\n  let subscription: Subscription;\n  let collected = {};\n\n  const retryWaitFunction = (retry: number) => {\n    return Math.pow(2, retry) * 1000 + Math.random() * 100;\n  };\n\n  return new Observable((observer) => {\n    // Run function is where the logic takes place. We have it in a function so we can call it recursively.\n    function run(currentQueryParams: StartQueryRequest[]) {\n      subscription = queryFun(currentQueryParams).subscribe({\n        next(frames) {\n          // In case we successfully finished, merge the current response with whatever we already collected.\n          const collectedPreviously = toDataQueryResponse({ data: { results: collected } }).data || [];\n          observer.next({ frames: [...collectedPreviously, ...frames] });\n          observer.complete();\n        },\n        error(error: FetchError<{ results?: Record<string, Result> }> | string) {\n          // In case of error we first try to figure out what kind of error it is\n\n          // This means it was a generic 500 error probably so we just pass it on\n          if (typeof error === 'string') {\n            observer.error(error);\n            return;\n          }\n\n          // In case of multiple queries this some can error while some may be ok\n          const errorData = splitErrorData(error);\n\n          if (!errorData) {\n            // Not sure what happened but the error structure wasn't what we expected\n            observer.error(error);\n            return;\n          }\n\n          if (!errorData!.errors.length) {\n            // So there is no limit error but some other errors so nothing to retry so we just pass it as it would be\n            // otherwise.\n            observer.error(error);\n            return;\n          }\n\n          if (timeoutFunc(retries, startTime.valueOf())) {\n            // We timed out but we could have started some queries\n            if (Object.keys(collected).length || Object.keys(errorData.good).length) {\n              const dataResponse = toDataQueryResponse({\n                data: {\n                  results: {\n                    ...(errorData.good ?? {}),\n                    ...(collected ?? {}),\n                  },\n                },\n              });\n              dataResponse.error = {\n                ...(dataResponse.error ?? {}),\n                message: `Some queries timed out: ${errorData.errorMessage}`,\n              };\n              // So we consider this a partial success and pass the data forward but also with error to be shown to\n              // the user.\n              observer.next({\n                error: dataResponse.error,\n                frames: dataResponse.data,\n              });\n              observer.complete();\n            } else {\n              // So we timed out and there was no data to pass forward so we just pass the error\n              const dataResponse = toDataQueryResponse({ data: { results: error.data?.results ?? {} } });\n              observer.error(dataResponse.error);\n            }\n            return;\n          }\n\n          collected = {\n            ...collected,\n            ...errorData!.good,\n          };\n\n          timerID = setTimeout(\n            () => {\n              retries++;\n              run(errorData!.errors);\n            },\n            // We want to know how long to wait for the next retry. First time this will be 0.\n            retryWaitFunction(retries + 1)\n          );\n        },\n      });\n    }\n    run(targets);\n    return () => {\n      // We clear only the latest timer and subscription but the observable should complete after one response so\n      // there should not be more things running at the same time.\n      clearTimeout(timerID);\n      subscription.unsubscribe();\n    };\n  });\n}\n\nfunction splitErrorData(error: FetchError<{ results?: Record<string, Result> }>) {\n  const results = error.data?.results;\n  if (!results) {\n    return undefined;\n  }\n  return Object.keys(results).reduce<{\n    errors: StartQueryRequest[];\n    good: Record<string, Result>;\n    errorMessage: string;\n  }>(\n    (acc, refId) => {\n      if (results[refId].error?.startsWith('LimitExceededException')) {\n        acc.errorMessage = results[refId].error!;\n        acc.errors.push(error.config.data.queries.find((q: any) => q.refId === refId));\n      } else {\n        acc.good[refId] = results[refId];\n      }\n      return acc;\n    },\n    { errors: [], good: {}, errorMessage: '' }\n  );\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}