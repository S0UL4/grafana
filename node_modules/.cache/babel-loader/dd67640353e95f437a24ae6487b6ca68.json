{"ast":null,"code":"import memoizeOne from 'memoize-one';\nimport { getParser } from '@grafana/data';\nimport { MAX_CHARACTERS } from './LogRowMessage';\nconst memoizedGetParser = memoizeOne(getParser);\n\n/**\n * Returns all fields for log row which consists of fields we parse from the message itself and any derived fields\n * setup in data source config.\n */\nexport const getAllFields = memoizeOne((row, getFieldLinks) => {\n  const fields = parseMessage(row.entry);\n  const derivedFields = getDerivedFields(row, getFieldLinks);\n  const fieldsMap = [...derivedFields, ...fields].reduce((acc, field) => {\n    // Strip enclosing quotes for hashing. When values are parsed from log line the quotes are kept, but if same\n    // value is in the dataFrame it will be without the quotes. We treat them here as the same value.\n    const value = field.value.replace(/(^\")|(\"$)/g, '');\n    const fieldHash = `${field.key}=${value}`;\n\n    if (acc[fieldHash]) {\n      acc[fieldHash].links = [...(acc[fieldHash].links || []), ...(field.links || [])];\n    } else {\n      acc[fieldHash] = field;\n    }\n\n    return acc;\n  }, {});\n  const allFields = Object.values(fieldsMap);\n  allFields.sort(sortFieldsLinkFirst);\n  return allFields;\n});\nconst parseMessage = memoizeOne(rowEntry => {\n  if (rowEntry.length > MAX_CHARACTERS) {\n    return [];\n  }\n\n  const parser = memoizedGetParser(rowEntry);\n\n  if (!parser) {\n    return [];\n  } // Use parser to highlight detected fields\n\n\n  const detectedFields = parser.getFields(rowEntry);\n  const fields = detectedFields.map(field => {\n    const key = parser.getLabelFromField(field);\n    const value = parser.getValueFromField(field);\n    return {\n      key,\n      value\n    };\n  });\n  return fields;\n});\nconst getDerivedFields = memoizeOne((row, getFieldLinks) => {\n  return row.dataFrame.fields.map((field, index) => Object.assign({}, field, {\n    index\n  })) // Remove Id which we use for react key and entry field which we are showing as the log message. Also remove hidden fields.\n  .filter((field, index) => {\n    var _field$config$custom;\n\n    return !('id' === field.name || row.entryFieldIndex === index || (_field$config$custom = field.config.custom) !== null && _field$config$custom !== void 0 && _field$config$custom.hidden);\n  }) // Filter out fields without values. For example in elastic the fields are parsed from the document which can\n  // have different structure per row and so the dataframe is pretty sparse.\n  .filter(field => {\n    const value = field.values.get(row.rowIndex); // Not sure exactly what will be the empty value here. And we want to keep 0 as some values can be non\n    // string.\n\n    return value !== null && value !== undefined;\n  }).map(field => {\n    const links = getFieldLinks ? getFieldLinks(field, row.rowIndex) : [];\n    return {\n      key: field.name,\n      value: field.values.get(row.rowIndex).toString(),\n      links: links,\n      fieldIndex: field.index\n    };\n  });\n});\n\nfunction sortFieldsLinkFirst(fieldA, fieldB) {\n  var _fieldA$links, _fieldB$links, _fieldA$links2, _fieldB$links2;\n\n  if ((_fieldA$links = fieldA.links) !== null && _fieldA$links !== void 0 && _fieldA$links.length && !((_fieldB$links = fieldB.links) !== null && _fieldB$links !== void 0 && _fieldB$links.length)) {\n    return -1;\n  }\n\n  if (!((_fieldA$links2 = fieldA.links) !== null && _fieldA$links2 !== void 0 && _fieldA$links2.length) && (_fieldB$links2 = fieldB.links) !== null && _fieldB$links2 !== void 0 && _fieldB$links2.length) {\n    return 1;\n  }\n\n  return fieldA.key > fieldB.key ? 1 : fieldA.key < fieldB.key ? -1 : 0;\n}","map":{"version":3,"names":["memoizeOne","getParser","MAX_CHARACTERS","memoizedGetParser","getAllFields","row","getFieldLinks","fields","parseMessage","entry","derivedFields","getDerivedFields","fieldsMap","reduce","acc","field","value","replace","fieldHash","key","links","allFields","Object","values","sort","sortFieldsLinkFirst","rowEntry","length","parser","detectedFields","getFields","map","getLabelFromField","getValueFromField","dataFrame","index","filter","name","entryFieldIndex","config","custom","hidden","get","rowIndex","undefined","toString","fieldIndex","fieldA","fieldB"],"sources":["/home/soula/grafana/packages/grafana-ui/src/components/Logs/logParser.ts"],"sourcesContent":["import memoizeOne from 'memoize-one';\n\nimport { Field, getParser, LinkModel, LogRowModel } from '@grafana/data';\n\nimport { MAX_CHARACTERS } from './LogRowMessage';\n\nconst memoizedGetParser = memoizeOne(getParser);\n\ntype FieldDef = {\n  key: string;\n  value: string;\n  links?: Array<LinkModel<Field>>;\n  fieldIndex?: number;\n};\n\n/**\n * Returns all fields for log row which consists of fields we parse from the message itself and any derived fields\n * setup in data source config.\n */\nexport const getAllFields = memoizeOne(\n  (row: LogRowModel, getFieldLinks?: (field: Field, rowIndex: number) => Array<LinkModel<Field>>) => {\n    const fields = parseMessage(row.entry);\n    const derivedFields = getDerivedFields(row, getFieldLinks);\n    const fieldsMap = [...derivedFields, ...fields].reduce((acc, field) => {\n      // Strip enclosing quotes for hashing. When values are parsed from log line the quotes are kept, but if same\n      // value is in the dataFrame it will be without the quotes. We treat them here as the same value.\n      const value = field.value.replace(/(^\")|(\"$)/g, '');\n      const fieldHash = `${field.key}=${value}`;\n      if (acc[fieldHash]) {\n        acc[fieldHash].links = [...(acc[fieldHash].links || []), ...(field.links || [])];\n      } else {\n        acc[fieldHash] = field;\n      }\n      return acc;\n    }, {} as { [key: string]: FieldDef });\n\n    const allFields = Object.values(fieldsMap);\n    allFields.sort(sortFieldsLinkFirst);\n\n    return allFields;\n  }\n);\n\nconst parseMessage = memoizeOne((rowEntry): FieldDef[] => {\n  if (rowEntry.length > MAX_CHARACTERS) {\n    return [];\n  }\n  const parser = memoizedGetParser(rowEntry);\n  if (!parser) {\n    return [];\n  }\n  // Use parser to highlight detected fields\n  const detectedFields = parser.getFields(rowEntry);\n  const fields = detectedFields.map((field) => {\n    const key = parser.getLabelFromField(field);\n    const value = parser.getValueFromField(field);\n    return { key, value };\n  });\n\n  return fields;\n});\n\nconst getDerivedFields = memoizeOne(\n  (row: LogRowModel, getFieldLinks?: (field: Field, rowIndex: number) => Array<LinkModel<Field>>): FieldDef[] => {\n    return (\n      row.dataFrame.fields\n        .map((field, index) => ({ ...field, index }))\n        // Remove Id which we use for react key and entry field which we are showing as the log message. Also remove hidden fields.\n        .filter(\n          (field, index) => !('id' === field.name || row.entryFieldIndex === index || field.config.custom?.hidden)\n        )\n        // Filter out fields without values. For example in elastic the fields are parsed from the document which can\n        // have different structure per row and so the dataframe is pretty sparse.\n        .filter((field) => {\n          const value = field.values.get(row.rowIndex);\n          // Not sure exactly what will be the empty value here. And we want to keep 0 as some values can be non\n          // string.\n          return value !== null && value !== undefined;\n        })\n        .map((field) => {\n          const links = getFieldLinks ? getFieldLinks(field, row.rowIndex) : [];\n          return {\n            key: field.name,\n            value: field.values.get(row.rowIndex).toString(),\n            links: links,\n            fieldIndex: field.index,\n          };\n        })\n    );\n  }\n);\n\nfunction sortFieldsLinkFirst(fieldA: FieldDef, fieldB: FieldDef) {\n  if (fieldA.links?.length && !fieldB.links?.length) {\n    return -1;\n  }\n  if (!fieldA.links?.length && fieldB.links?.length) {\n    return 1;\n  }\n  return fieldA.key > fieldB.key ? 1 : fieldA.key < fieldB.key ? -1 : 0;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}