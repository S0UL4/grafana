{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { cloneDeep, defaults as _defaults, filter, indexOf, isEqual, map, maxBy, pull } from 'lodash';\nimport { Subscription } from 'rxjs';\nimport { dateTime, dateTimeFormat, dateTimeFormatTimeAgo, EventBusSrv } from '@grafana/data';\nimport { RefreshEvent, TimeRangeUpdatedEvent } from '@grafana/runtime';\nimport { DEFAULT_ANNOTATION_COLOR } from '@grafana/ui';\nimport { GRID_CELL_HEIGHT, GRID_CELL_VMARGIN, GRID_COLUMN_COUNT, REPEAT_DIR_VERTICAL } from 'app/core/constants';\nimport { contextSrv } from 'app/core/services/context_srv';\nimport { sortedDeepCloneWithoutNulls } from 'app/core/utils/object';\nimport { variableAdapters } from 'app/features/variables/adapters';\nimport { onTimeRangeUpdated } from 'app/features/variables/state/actions';\nimport { getVariablesByKey } from 'app/features/variables/state/selectors';\nimport { CoreEvents, KioskMode } from 'app/types';\nimport { DashboardPanelsChangedEvent, RenderEvent } from 'app/types/events';\nimport { appEvents } from '../../../core/core';\nimport { dispatch } from '../../../store/store';\nimport { VariablesChanged, VariablesChangedInUrl, VariablesTimeRangeProcessDone } from '../../variables/types';\nimport { isAllVariable } from '../../variables/utils';\nimport { getTimeSrv } from '../services/TimeSrv';\nimport { mergePanels } from '../utils/panelMerge';\nimport { DashboardMigrator } from './DashboardMigrator';\nimport { PanelModel } from './PanelModel';\nimport { deleteScopeVars, isOnTheSameGridRow } from './utils';\nexport class DashboardModel {\n  // ------------------\n  // not persisted\n  // ------------------\n  // repeat process cycles\n  constructor(data, meta, getVariablesFromState = getVariablesByKey) {\n    var _data$title, _data$tags, _data$style, _data$timezone, _data$weekStart, _data$time, _data$timepicker, _data$schemaVersion, _data$fiscalYearStart, _data$version, _data$links, _data$panels;\n\n    _defineProperty(this, \"id\", void 0);\n\n    _defineProperty(this, \"uid\", void 0);\n\n    _defineProperty(this, \"title\", void 0);\n\n    _defineProperty(this, \"autoUpdate\", void 0);\n\n    _defineProperty(this, \"description\", void 0);\n\n    _defineProperty(this, \"tags\", void 0);\n\n    _defineProperty(this, \"style\", void 0);\n\n    _defineProperty(this, \"timezone\", void 0);\n\n    _defineProperty(this, \"weekStart\", void 0);\n\n    _defineProperty(this, \"editable\", void 0);\n\n    _defineProperty(this, \"graphTooltip\", void 0);\n\n    _defineProperty(this, \"time\", void 0);\n\n    _defineProperty(this, \"liveNow\", void 0);\n\n    _defineProperty(this, \"originalTime\", void 0);\n\n    _defineProperty(this, \"timepicker\", void 0);\n\n    _defineProperty(this, \"templating\", void 0);\n\n    _defineProperty(this, \"originalTemplating\", void 0);\n\n    _defineProperty(this, \"annotations\", void 0);\n\n    _defineProperty(this, \"refresh\", void 0);\n\n    _defineProperty(this, \"snapshot\", void 0);\n\n    _defineProperty(this, \"schemaVersion\", void 0);\n\n    _defineProperty(this, \"version\", void 0);\n\n    _defineProperty(this, \"revision\", void 0);\n\n    _defineProperty(this, \"links\", void 0);\n\n    _defineProperty(this, \"gnetId\", void 0);\n\n    _defineProperty(this, \"panels\", void 0);\n\n    _defineProperty(this, \"panelInEdit\", void 0);\n\n    _defineProperty(this, \"panelInView\", void 0);\n\n    _defineProperty(this, \"fiscalYearStartMonth\", void 0);\n\n    _defineProperty(this, \"panelsAffectedByVariableChange\", void 0);\n\n    _defineProperty(this, \"appEventsSubscription\", void 0);\n\n    _defineProperty(this, \"lastRefresh\", void 0);\n\n    _defineProperty(this, \"iteration\", void 0);\n\n    _defineProperty(this, \"events\", void 0);\n\n    this.getVariablesFromState = getVariablesFromState;\n\n    if (!data) {\n      data = {};\n    }\n\n    this.events = new EventBusSrv();\n    this.id = data.id || null;\n    this.uid = data.uid || null;\n    this.revision = data.revision;\n    this.title = (_data$title = data.title) !== null && _data$title !== void 0 ? _data$title : 'No Title';\n    this.autoUpdate = data.autoUpdate;\n    this.description = data.description;\n    this.tags = (_data$tags = data.tags) !== null && _data$tags !== void 0 ? _data$tags : [];\n    this.style = (_data$style = data.style) !== null && _data$style !== void 0 ? _data$style : 'dark';\n    this.timezone = (_data$timezone = data.timezone) !== null && _data$timezone !== void 0 ? _data$timezone : '';\n    this.weekStart = (_data$weekStart = data.weekStart) !== null && _data$weekStart !== void 0 ? _data$weekStart : '';\n    this.editable = data.editable !== false;\n    this.graphTooltip = data.graphTooltip || 0;\n    this.time = (_data$time = data.time) !== null && _data$time !== void 0 ? _data$time : {\n      from: 'now-6h',\n      to: 'now'\n    };\n    this.timepicker = (_data$timepicker = data.timepicker) !== null && _data$timepicker !== void 0 ? _data$timepicker : {};\n    this.liveNow = Boolean(data.liveNow);\n    this.templating = this.ensureListExist(data.templating);\n    this.annotations = this.ensureListExist(data.annotations);\n    this.refresh = data.refresh;\n    this.snapshot = data.snapshot;\n    this.schemaVersion = (_data$schemaVersion = data.schemaVersion) !== null && _data$schemaVersion !== void 0 ? _data$schemaVersion : 0;\n    this.fiscalYearStartMonth = (_data$fiscalYearStart = data.fiscalYearStartMonth) !== null && _data$fiscalYearStart !== void 0 ? _data$fiscalYearStart : 0;\n    this.version = (_data$version = data.version) !== null && _data$version !== void 0 ? _data$version : 0;\n    this.links = (_data$links = data.links) !== null && _data$links !== void 0 ? _data$links : [];\n    this.gnetId = data.gnetId || null;\n    this.panels = map((_data$panels = data.panels) !== null && _data$panels !== void 0 ? _data$panels : [], panelData => new PanelModel(panelData));\n    this.ensurePanelsHaveIds();\n    this.formatDate = this.formatDate.bind(this);\n    this.resetOriginalVariables(true);\n    this.resetOriginalTime();\n    this.initMeta(meta);\n    this.updateSchema(data);\n    this.addBuiltInAnnotationQuery();\n    this.sortPanelsByGridPos();\n    this.panelsAffectedByVariableChange = null;\n    this.appEventsSubscription = new Subscription();\n    this.lastRefresh = Date.now();\n    this.appEventsSubscription.add(appEvents.subscribe(VariablesChanged, this.variablesChangedHandler.bind(this)));\n    this.appEventsSubscription.add(appEvents.subscribe(VariablesTimeRangeProcessDone, this.variablesTimeRangeProcessDoneHandler.bind(this)));\n    this.appEventsSubscription.add(appEvents.subscribe(VariablesChangedInUrl, this.variablesChangedInUrlHandler.bind(this)));\n  }\n\n  addBuiltInAnnotationQuery() {\n    const found = this.annotations.list.some(item => item.builtIn === 1);\n\n    if (found) {\n      return;\n    }\n\n    this.annotations.list.unshift({\n      datasource: {\n        uid: '-- Grafana --',\n        type: 'grafana'\n      },\n      name: 'Annotations & Alerts',\n      type: 'dashboard',\n      iconColor: DEFAULT_ANNOTATION_COLOR,\n      enable: true,\n      hide: true,\n      builtIn: 1\n    });\n  }\n\n  initMeta(meta) {\n    meta = meta || {};\n    meta.canShare = meta.canShare !== false;\n    meta.canSave = meta.canSave !== false;\n    meta.canStar = meta.canStar !== false;\n    meta.canEdit = meta.canEdit !== false;\n    meta.canDelete = meta.canDelete !== false;\n    meta.showSettings = meta.canSave;\n    meta.canMakeEditable = meta.canSave && !this.editable;\n    meta.hasUnsavedFolderChange = false;\n\n    if (!this.editable) {\n      meta.canEdit = false;\n      meta.canDelete = false;\n      meta.canSave = false;\n    }\n\n    this.meta = meta;\n  } // cleans meta data and other non persistent state\n\n\n  getSaveModelClone(options) {\n    const defaults = _defaults(options || {}, {\n      saveVariables: true,\n      saveTimerange: true\n    }); // make clone\n\n\n    let copy = {};\n\n    for (const property in this) {\n      if (DashboardModel.nonPersistedProperties[property] || !this.hasOwnProperty(property)) {\n        continue;\n      }\n\n      copy[property] = cloneDeep(this[property]);\n    }\n\n    this.updateTemplatingSaveModelClone(copy, defaults);\n\n    if (!defaults.saveTimerange) {\n      copy.time = this.originalTime;\n    } // get panel save models\n\n\n    copy.panels = this.getPanelSaveModels(); //  sort by keys\n\n    copy = sortedDeepCloneWithoutNulls(copy);\n\n    copy.getVariables = () => copy.templating.list;\n\n    return copy;\n  }\n  /**\n   * This will load a new dashboard, but keep existing panels unchanged\n   *\n   * This function can be used to implement:\n   * 1. potentially faster loading dashboard loading\n   * 2. dynamic dashboard behavior\n   * 3. \"live\" dashboard editing\n   *\n   * @internal and experimental\n   */\n\n\n  updatePanels(panels) {\n    const info = mergePanels(this.panels, panels !== null && panels !== void 0 ? panels : []);\n\n    if (info.changed) {\n      var _info$panels;\n\n      this.panels = (_info$panels = info.panels) !== null && _info$panels !== void 0 ? _info$panels : [];\n      this.sortPanelsByGridPos();\n      this.events.publish(new DashboardPanelsChangedEvent());\n    }\n\n    return info;\n  }\n\n  getPanelSaveModels() {\n    return this.panels.filter(panel => this.isSnapshotTruthy() || !(panel.type === 'add-panel' || panel.repeatPanelId || panel.repeatedByRow)).map(panel => {\n      // If we save while editing we should include the panel in edit mode instead of the\n      // unmodified source panel\n      if (this.panelInEdit && this.panelInEdit.id === panel.id) {\n        return this.panelInEdit.getSaveModel();\n      }\n\n      return panel.getSaveModel();\n    }).map(model => {\n      if (this.isSnapshotTruthy()) {\n        return model;\n      } // Clear any scopedVars from persisted mode. This cannot be part of getSaveModel as we need to be able to copy\n      // panel models with preserved scopedVars, for example when going into edit mode.\n\n\n      delete model.scopedVars; // Clear any repeated panels from collapsed rows\n\n      if (model.type === 'row' && model.panels && model.panels.length > 0) {\n        model.panels = model.panels.filter(rowPanel => !rowPanel.repeatPanelId).map(model => {\n          delete model.scopedVars;\n          return model;\n        });\n      }\n\n      return model;\n    });\n  }\n\n  updateTemplatingSaveModelClone(copy, defaults) {\n    const originalVariables = this.originalTemplating;\n    const currentVariables = this.getVariablesFromState(this.uid);\n    copy.templating = {\n      list: currentVariables.map(variable => variableAdapters.get(variable.type).getSaveModel(variable, defaults.saveVariables))\n    };\n\n    if (!defaults.saveVariables) {\n      for (const current of copy.templating.list) {\n        const original = originalVariables.find(({\n          name,\n          type\n        }) => name === current.name && type === current.type);\n\n        if (!original) {\n          continue;\n        }\n\n        if (current.type === 'adhoc') {\n          current.filters = original.filters;\n        } else {\n          current.current = original.current;\n        }\n      }\n    }\n  }\n\n  timeRangeUpdated(timeRange) {\n    this.events.publish(new TimeRangeUpdatedEvent(timeRange));\n    dispatch(onTimeRangeUpdated(this.uid, timeRange));\n  }\n\n  startRefresh(event = {\n    refreshAll: true,\n    panelIds: []\n  }) {\n    this.events.publish(new RefreshEvent());\n    this.lastRefresh = Date.now();\n\n    if (this.panelInEdit && (event.refreshAll || event.panelIds.includes(this.panelInEdit.id))) {\n      this.panelInEdit.refresh();\n      return;\n    }\n\n    for (const panel of this.panels) {\n      if (!this.otherPanelInFullscreen(panel) && (event.refreshAll || event.panelIds.includes(panel.id))) {\n        panel.refresh();\n      }\n    }\n  }\n\n  render() {\n    this.events.publish(new RenderEvent());\n\n    for (const panel of this.panels) {\n      panel.render();\n    }\n  }\n\n  panelInitialized(panel) {\n    const lastResult = panel.getQueryRunner().getLastResult();\n\n    if (!this.otherPanelInFullscreen(panel) && !lastResult) {\n      panel.refresh();\n    }\n  }\n\n  otherPanelInFullscreen(panel) {\n    return (this.panelInEdit || this.panelInView) && !(panel.isViewing || panel.isEditing);\n  }\n\n  initEditPanel(sourcePanel) {\n    getTimeSrv().pauseAutoRefresh();\n    this.panelInEdit = sourcePanel.getEditClone();\n    return this.panelInEdit;\n  }\n\n  initViewPanel(panel) {\n    this.panelInView = panel;\n    panel.setIsViewing(true);\n  }\n\n  exitViewPanel(panel) {\n    this.panelInView = undefined;\n    panel.setIsViewing(false);\n    this.refreshIfPanelsAffectedByVariableChange();\n  }\n\n  exitPanelEditor() {\n    this.panelInEdit.destroy();\n    this.panelInEdit = undefined;\n    getTimeSrv().resumeAutoRefresh();\n    this.refreshIfPanelsAffectedByVariableChange();\n  }\n\n  refreshIfPanelsAffectedByVariableChange() {\n    if (!this.panelsAffectedByVariableChange) {\n      return;\n    }\n\n    this.startRefresh({\n      panelIds: this.panelsAffectedByVariableChange,\n      refreshAll: false\n    });\n    this.panelsAffectedByVariableChange = null;\n  }\n\n  ensurePanelsHaveIds() {\n    let nextPanelId = this.getNextPanelId();\n\n    for (const panel of this.panelIterator()) {\n      panel.id ??= nextPanelId++;\n    }\n  }\n\n  ensureListExist(data = {}) {\n    data.list ??= [];\n    return data;\n  }\n\n  getNextPanelId() {\n    let max = 0;\n\n    for (const panel of this.panelIterator()) {\n      if (panel.id > max) {\n        max = panel.id;\n      }\n    }\n\n    return max + 1;\n  }\n\n  *panelIterator() {\n    for (const panel of this.panels) {\n      var _panel$panels;\n\n      yield panel;\n      const rowPanels = (_panel$panels = panel.panels) !== null && _panel$panels !== void 0 ? _panel$panels : [];\n\n      for (const rowPanel of rowPanels) {\n        yield rowPanel;\n      }\n    }\n  }\n\n  forEachPanel(callback) {\n    for (let i = 0; i < this.panels.length; i++) {\n      callback(this.panels[i], i);\n    }\n  }\n\n  getPanelById(id) {\n    var _this$panels$find;\n\n    if (this.panelInEdit && this.panelInEdit.id === id) {\n      return this.panelInEdit;\n    }\n\n    return (_this$panels$find = this.panels.find(p => p.id === id)) !== null && _this$panels$find !== void 0 ? _this$panels$find : null;\n  }\n\n  canEditPanel(panel) {\n    return Boolean(this.meta.canEdit && panel && !panel.repeatPanelId && panel.type !== 'row');\n  }\n\n  canEditPanelById(id) {\n    return this.canEditPanel(this.getPanelById(id));\n  }\n\n  addPanel(panelData) {\n    panelData.id = this.getNextPanelId();\n    this.panels.unshift(new PanelModel(panelData));\n    this.sortPanelsByGridPos();\n    this.events.publish(new DashboardPanelsChangedEvent());\n  }\n\n  sortPanelsByGridPos() {\n    this.panels.sort((panelA, panelB) => {\n      if (panelA.gridPos.y === panelB.gridPos.y) {\n        return panelA.gridPos.x - panelB.gridPos.x;\n      } else {\n        return panelA.gridPos.y - panelB.gridPos.y;\n      }\n    });\n  }\n\n  clearUnsavedChanges() {\n    for (const panel of this.panels) {\n      panel.configRev = 0;\n    }\n  }\n\n  hasUnsavedChanges() {\n    const changedPanel = this.panels.find(p => p.hasChanged);\n    return Boolean(changedPanel);\n  }\n\n  cleanUpRepeats() {\n    if (this.isSnapshotTruthy() || !this.hasVariables()) {\n      return;\n    }\n\n    this.iteration = (this.iteration || new Date().getTime()) + 1; // cleanup scopedVars\n\n    deleteScopeVars(this.panels);\n    const panelsToRemove = this.panels.filter(p => (!p.repeat || p.repeatedByRow) && p.repeatPanelId && p.repeatIteration !== this.iteration); // remove panels\n\n    pull(this.panels, ...panelsToRemove);\n    panelsToRemove.map(p => p.destroy());\n    this.sortPanelsByGridPos();\n  }\n\n  processRepeats() {\n    if (this.isSnapshotTruthy() || !this.hasVariables()) {\n      return;\n    }\n\n    this.cleanUpRepeats();\n    this.iteration = (this.iteration || new Date().getTime()) + 1;\n\n    for (let i = 0; i < this.panels.length; i++) {\n      const panel = this.panels[i];\n\n      if (panel.repeat) {\n        this.repeatPanel(panel, i);\n      }\n    }\n\n    this.sortPanelsByGridPos();\n    this.events.publish(new DashboardPanelsChangedEvent());\n  }\n\n  cleanUpRowRepeats(rowPanels) {\n    const panelIds = rowPanels.map(row => row.id); // Remove repeated panels whose parent is in this row as these will be recreated later in processRowRepeats\n\n    const panelsToRemove = rowPanels.filter(p => !p.repeat && p.repeatPanelId && panelIds.includes(p.repeatPanelId));\n    pull(rowPanels, ...panelsToRemove);\n    pull(this.panels, ...panelsToRemove);\n  }\n\n  processRowRepeats(row) {\n    var _row$panels;\n\n    if (this.isSnapshotTruthy() || !this.hasVariables()) {\n      return;\n    }\n\n    let rowPanels = (_row$panels = row.panels) !== null && _row$panels !== void 0 ? _row$panels : [];\n\n    if (!row.collapsed) {\n      const rowPanelIndex = this.panels.findIndex(p => p.id === row.id);\n      rowPanels = this.getRowPanels(rowPanelIndex);\n    }\n\n    this.cleanUpRowRepeats(rowPanels);\n\n    for (const panel of rowPanels) {\n      if (panel.repeat) {\n        const panelIndex = this.panels.findIndex(p => p.id === panel.id);\n        this.repeatPanel(panel, panelIndex);\n      }\n    }\n  }\n\n  getPanelRepeatClone(sourcePanel, valueIndex, sourcePanelIndex) {\n    var _this$panelInView;\n\n    // if first clone return source\n    if (valueIndex === 0) {\n      return sourcePanel;\n    }\n\n    const m = sourcePanel.getSaveModel();\n    m.id = this.getNextPanelId();\n    const clone = new PanelModel(m); // insert after source panel + value index\n\n    this.panels.splice(sourcePanelIndex + valueIndex, 0, clone);\n    clone.repeatIteration = this.iteration;\n    clone.repeatPanelId = sourcePanel.id;\n    clone.repeat = undefined;\n\n    if (((_this$panelInView = this.panelInView) === null || _this$panelInView === void 0 ? void 0 : _this$panelInView.id) === clone.id) {\n      clone.setIsViewing(true);\n      this.panelInView = clone;\n    }\n\n    return clone;\n  }\n\n  getRowRepeatClone(sourceRowPanel, valueIndex, sourcePanelIndex) {\n    // if first clone return source\n    if (valueIndex === 0) {\n      if (!sourceRowPanel.collapsed) {\n        const rowPanels = this.getRowPanels(sourcePanelIndex);\n        sourceRowPanel.panels = rowPanels;\n      }\n\n      return sourceRowPanel;\n    }\n\n    const clone = new PanelModel(sourceRowPanel.getSaveModel()); // for row clones we need to figure out panels under row to clone and where to insert clone\n\n    let rowPanels, insertPos;\n\n    if (sourceRowPanel.collapsed) {\n      var _cloneDeep;\n\n      rowPanels = (_cloneDeep = cloneDeep(sourceRowPanel.panels)) !== null && _cloneDeep !== void 0 ? _cloneDeep : [];\n      clone.panels = rowPanels; // insert copied row after preceding row\n\n      insertPos = sourcePanelIndex + valueIndex;\n    } else {\n      rowPanels = this.getRowPanels(sourcePanelIndex);\n      clone.panels = rowPanels.map(panel => panel.getSaveModel()); // insert copied row after preceding row's panels\n\n      insertPos = sourcePanelIndex + (rowPanels.length + 1) * valueIndex;\n    }\n\n    this.panels.splice(insertPos, 0, clone);\n    this.updateRepeatedPanelIds(clone);\n    return clone;\n  }\n\n  repeatPanel(panel, panelIndex) {\n    const variable = this.getPanelRepeatVariable(panel);\n\n    if (!variable) {\n      return;\n    }\n\n    if (panel.type === 'row') {\n      this.repeatRow(panel, panelIndex, variable);\n      return;\n    }\n\n    const selectedOptions = this.getSelectedVariableOptions(variable);\n    const maxPerRow = panel.maxPerRow || 4;\n    let xPos = 0;\n    let yPos = panel.gridPos.y;\n\n    for (let index = 0; index < selectedOptions.length; index++) {\n      const option = selectedOptions[index];\n      let copy;\n      copy = this.getPanelRepeatClone(panel, index, panelIndex);\n      copy.scopedVars ??= {};\n      copy.scopedVars[variable.name] = option;\n\n      if (panel.repeatDirection === REPEAT_DIR_VERTICAL) {\n        if (index > 0) {\n          yPos += copy.gridPos.h;\n        }\n\n        copy.gridPos.y = yPos;\n      } else {\n        // set width based on how many are selected\n        // assumed the repeated panels should take up full row width\n        copy.gridPos.w = Math.max(GRID_COLUMN_COUNT / selectedOptions.length, GRID_COLUMN_COUNT / maxPerRow);\n        copy.gridPos.x = xPos;\n        copy.gridPos.y = yPos;\n        xPos += copy.gridPos.w; // handle overflow by pushing down one row\n\n        if (xPos + copy.gridPos.w > GRID_COLUMN_COUNT) {\n          xPos = 0;\n          yPos += copy.gridPos.h;\n        }\n      }\n    } // Update gridPos for panels below\n\n\n    const yOffset = yPos - panel.gridPos.y;\n\n    if (yOffset > 0) {\n      const panelBelowIndex = panelIndex + selectedOptions.length;\n\n      for (const curPanel of this.panels.slice(panelBelowIndex)) {\n        if (isOnTheSameGridRow(panel, curPanel)) {\n          continue;\n        }\n\n        curPanel.gridPos.y += yOffset;\n      }\n    }\n  }\n\n  repeatRow(panel, panelIndex, variable) {\n    const selectedOptions = this.getSelectedVariableOptions(variable);\n    let yPos = panel.gridPos.y;\n\n    function setScopedVars(panel, variableOption) {\n      panel.scopedVars ??= {};\n      panel.scopedVars[variable.name] = variableOption;\n    }\n\n    for (let optionIndex = 0; optionIndex < selectedOptions.length; optionIndex++) {\n      const option = selectedOptions[optionIndex];\n      const rowCopy = this.getRowRepeatClone(panel, optionIndex, panelIndex);\n      setScopedVars(rowCopy, option);\n      const rowHeight = this.getRowHeight(rowCopy);\n      const rowPanels = rowCopy.panels || [];\n      let panelBelowIndex;\n\n      if (panel.collapsed) {\n        // For collapsed row just copy its panels and set scoped vars and proper IDs\n        for (const rowPanel of rowPanels) {\n          setScopedVars(rowPanel, option);\n\n          if (optionIndex > 0) {\n            this.updateRepeatedPanelIds(rowPanel, true);\n          }\n        }\n\n        rowCopy.gridPos.y += optionIndex;\n        yPos += optionIndex;\n        panelBelowIndex = panelIndex + optionIndex + 1;\n      } else {\n        // insert after 'row' panel\n        const insertPos = panelIndex + (rowPanels.length + 1) * optionIndex + 1;\n        rowPanels.forEach((rowPanel, i) => {\n          setScopedVars(rowPanel, option);\n\n          if (optionIndex > 0) {\n            const cloneRowPanel = new PanelModel(rowPanel);\n            this.updateRepeatedPanelIds(cloneRowPanel, true); // For exposed row additionally set proper Y grid position and add it to dashboard panels\n\n            cloneRowPanel.gridPos.y += rowHeight * optionIndex;\n            this.panels.splice(insertPos + i, 0, cloneRowPanel);\n          }\n        });\n        rowCopy.panels = [];\n        rowCopy.gridPos.y += rowHeight * optionIndex;\n        yPos += rowHeight;\n        panelBelowIndex = insertPos + rowPanels.length;\n      } // Update gridPos for panels below if we inserted more than 1 repeated row panel\n\n\n      if (selectedOptions.length > 1) {\n        for (const panel of this.panels.slice(panelBelowIndex)) {\n          panel.gridPos.y += yPos;\n        }\n      }\n    }\n  }\n\n  updateRepeatedPanelIds(panel, repeatedByRow) {\n    panel.repeatPanelId = panel.id;\n    panel.id = this.getNextPanelId();\n    panel.repeatIteration = this.iteration;\n\n    if (repeatedByRow) {\n      panel.repeatedByRow = true;\n    } else {\n      panel.repeat = undefined;\n    }\n\n    return panel;\n  }\n\n  getSelectedVariableOptions(variable) {\n    let selectedOptions;\n\n    if (isAllVariable(variable)) {\n      selectedOptions = variable.options.slice(1, variable.options.length);\n    } else {\n      selectedOptions = filter(variable.options, {\n        selected: true\n      });\n    }\n\n    return selectedOptions;\n  }\n\n  getRowHeight(rowPanel) {\n    if (!rowPanel.panels || rowPanel.panels.length === 0) {\n      return 0;\n    }\n\n    const rowYPos = rowPanel.gridPos.y;\n    const positions = map(rowPanel.panels, 'gridPos');\n    const maxPos = maxBy(positions, pos => pos.y + pos.h);\n    return maxPos.y + maxPos.h - rowYPos;\n  }\n\n  removePanel(panel) {\n    this.panels = this.panels.filter(item => item !== panel);\n    this.events.publish(new DashboardPanelsChangedEvent());\n  }\n\n  removeRow(row, removePanels) {\n    const needToggle = !removePanels && row.collapsed || removePanels && !row.collapsed;\n\n    if (needToggle) {\n      this.toggleRow(row);\n    }\n\n    this.removePanel(row);\n  }\n\n  expandRows() {\n    const collapsedRows = this.panels.filter(p => p.type === 'row' && p.collapsed);\n\n    for (const row of collapsedRows) {\n      this.toggleRow(row);\n    }\n  }\n\n  collapseRows() {\n    const collapsedRows = this.panels.filter(p => p.type === 'row' && !p.collapsed);\n\n    for (const row of collapsedRows) {\n      this.toggleRow(row);\n    }\n  }\n\n  isSubMenuVisible() {\n    return this.links.length > 0 || this.getVariables().some(variable => variable.hide !== 2) || this.annotations.list.some(annotation => !annotation.hide);\n  }\n\n  getPanelInfoById(panelId) {\n    const panelIndex = this.panels.findIndex(p => p.id === panelId);\n    return panelIndex >= 0 ? {\n      panel: this.panels[panelIndex],\n      index: panelIndex\n    } : null;\n  }\n\n  duplicatePanel(panel) {\n    const newPanel = panel.getSaveModel();\n    newPanel.id = this.getNextPanelId();\n    delete newPanel.repeat;\n    delete newPanel.repeatIteration;\n    delete newPanel.repeatPanelId;\n    delete newPanel.scopedVars;\n\n    if (newPanel.alert) {\n      delete newPanel.thresholds;\n    }\n\n    delete newPanel.alert; // does it fit to the right?\n\n    if (panel.gridPos.x + panel.gridPos.w * 2 <= GRID_COLUMN_COUNT) {\n      newPanel.gridPos.x += panel.gridPos.w;\n    } else {\n      // add below\n      newPanel.gridPos.y += panel.gridPos.h;\n    }\n\n    this.addPanel(newPanel);\n    return newPanel;\n  }\n\n  formatDate(date, format) {\n    return dateTimeFormat(date, {\n      format,\n      timeZone: this.getTimezone()\n    });\n  }\n\n  destroy() {\n    this.appEventsSubscription.unsubscribe();\n    this.events.removeAllListeners();\n\n    for (const panel of this.panels) {\n      panel.destroy();\n    }\n  }\n\n  toggleRow(row) {\n    var _row$panels2;\n\n    const rowIndex = indexOf(this.panels, row);\n\n    if (!row.collapsed) {\n      const rowPanels = this.getRowPanels(rowIndex); // remove panels\n\n      pull(this.panels, ...rowPanels); // save panel models inside row panel\n\n      row.panels = rowPanels.map(panel => panel.getSaveModel());\n      row.collapsed = true;\n\n      if (rowPanels.some(panel => panel.hasChanged)) {\n        row.configRev++;\n      } // emit change event\n\n\n      this.events.publish(new DashboardPanelsChangedEvent());\n      return;\n    }\n\n    row.collapsed = false;\n    const rowPanels = (_row$panels2 = row.panels) !== null && _row$panels2 !== void 0 ? _row$panels2 : [];\n    const hasRepeat = rowPanels.some(p => p.repeat);\n\n    if (rowPanels.length > 0) {\n      var _rowPanels$0$gridPos$;\n\n      // Use first panel to figure out if it was moved or pushed\n      // If the panel doesn't have gridPos.y, use the row gridPos.y instead.\n      // This can happen for some generated dashboards.\n      const firstPanelYPos = (_rowPanels$0$gridPos$ = rowPanels[0].gridPos.y) !== null && _rowPanels$0$gridPos$ !== void 0 ? _rowPanels$0$gridPos$ : row.gridPos.y;\n      const yDiff = firstPanelYPos - (row.gridPos.y + row.gridPos.h); // start inserting after row\n\n      let insertPos = rowIndex + 1; // y max will represent the bottom y pos after all panels have been added\n      // needed to know home much panels below should be pushed down\n\n      let yMax = row.gridPos.y;\n\n      for (const panel of rowPanels) {\n        var _panel$gridPos$y;\n\n        // set the y gridPos if it wasn't already set\n        (_panel$gridPos$y = panel.gridPos.y) !== null && _panel$gridPos$y !== void 0 ? _panel$gridPos$y : panel.gridPos.y = row.gridPos.y; // (Safari 13.1 lacks ??= support)\n        // make sure y is adjusted (in case row moved while collapsed)\n\n        panel.gridPos.y -= yDiff; // insert after row\n\n        this.panels.splice(insertPos, 0, new PanelModel(panel)); // update insert post and y max\n\n        insertPos += 1;\n        yMax = Math.max(yMax, panel.gridPos.y + panel.gridPos.h);\n      }\n\n      const pushDownAmount = yMax - row.gridPos.y - 1; // push panels below down\n\n      for (const panel of this.panels.slice(insertPos)) {\n        panel.gridPos.y += pushDownAmount;\n      }\n\n      row.panels = [];\n\n      if (hasRepeat) {\n        this.processRowRepeats(row);\n      }\n    } // sort panels\n\n\n    this.sortPanelsByGridPos(); // emit change event\n\n    this.events.publish(new DashboardPanelsChangedEvent());\n  }\n  /**\n   * Will return all panels after rowIndex until it encounters another row\n   */\n\n\n  getRowPanels(rowIndex) {\n    const panelsBelowRow = this.panels.slice(rowIndex + 1);\n    const nextRowIndex = panelsBelowRow.findIndex(p => p.type === 'row'); // Take all panels up to next row, or all panels if there are no other rows\n\n    const rowPanels = panelsBelowRow.slice(0, nextRowIndex >= 0 ? nextRowIndex : this.panels.length);\n    return rowPanels;\n  }\n  /** @deprecated */\n\n\n  on(event, callback) {\n    console.log('DashboardModel.on is deprecated use events.subscribe');\n    this.events.on(event, callback);\n  }\n  /** @deprecated */\n\n\n  off(event, callback) {\n    console.log('DashboardModel.off is deprecated');\n    this.events.off(event, callback);\n  }\n\n  cycleGraphTooltip() {\n    this.graphTooltip = (this.graphTooltip + 1) % 3;\n  }\n\n  sharedTooltipModeEnabled() {\n    return this.graphTooltip > 0;\n  }\n\n  sharedCrosshairModeOnly() {\n    return this.graphTooltip === 1;\n  }\n\n  getRelativeTime(date) {\n    return dateTimeFormatTimeAgo(date, {\n      timeZone: this.getTimezone()\n    });\n  }\n\n  isSnapshot() {\n    return this.snapshot !== undefined;\n  }\n\n  getTimezone() {\n    var _contextSrv$user;\n\n    return this.timezone ? this.timezone : contextSrv === null || contextSrv === void 0 ? void 0 : (_contextSrv$user = contextSrv.user) === null || _contextSrv$user === void 0 ? void 0 : _contextSrv$user.timezone;\n  }\n\n  updateSchema(old) {\n    const migrator = new DashboardMigrator(this);\n    migrator.updateSchema(old);\n  }\n\n  resetOriginalTime() {\n    this.originalTime = cloneDeep(this.time);\n  }\n\n  hasTimeChanged() {\n    const {\n      time,\n      originalTime\n    } = this; // Compare moment values vs strings values\n\n    return !(isEqual(time, originalTime) || isEqual(dateTime(time === null || time === void 0 ? void 0 : time.from), dateTime(originalTime === null || originalTime === void 0 ? void 0 : originalTime.from)) && isEqual(dateTime(time === null || time === void 0 ? void 0 : time.to), dateTime(originalTime === null || originalTime === void 0 ? void 0 : originalTime.to)));\n  }\n\n  resetOriginalVariables(initial = false) {\n    if (initial) {\n      this.originalTemplating = this.cloneVariablesFrom(this.templating.list);\n      return;\n    }\n\n    this.originalTemplating = this.cloneVariablesFrom(this.getVariablesFromState(this.uid));\n  }\n\n  hasVariableValuesChanged() {\n    return this.hasVariablesChanged(this.originalTemplating, this.getVariablesFromState(this.uid));\n  }\n\n  autoFitPanels(viewHeight, kioskMode) {\n    const currentGridHeight = Math.max(...this.panels.map(panel => panel.gridPos.h + panel.gridPos.y));\n    const navbarHeight = 55;\n    const margin = 20;\n    const submenuHeight = 50;\n    let visibleHeight = viewHeight - navbarHeight - margin; // Remove submenu height if visible\n\n    if (this.meta.submenuEnabled && !kioskMode) {\n      visibleHeight -= submenuHeight;\n    } // add back navbar height\n\n\n    if (kioskMode && kioskMode !== KioskMode.TV) {\n      visibleHeight += navbarHeight;\n    }\n\n    const visibleGridHeight = Math.floor(visibleHeight / (GRID_CELL_HEIGHT + GRID_CELL_VMARGIN));\n    const scaleFactor = currentGridHeight / visibleGridHeight;\n\n    for (const panel of this.panels) {\n      panel.gridPos.y = Math.round(panel.gridPos.y / scaleFactor) || 1;\n      panel.gridPos.h = Math.round(panel.gridPos.h / scaleFactor) || 1;\n    }\n  }\n\n  templateVariableValueUpdated() {\n    this.processRepeats();\n    this.events.emit(CoreEvents.templateVariableValueUpdated);\n  }\n\n  getPanelByUrlId(panelUrlId) {\n    const panelId = parseInt(panelUrlId !== null && panelUrlId !== void 0 ? panelUrlId : '0', 10); // First try to find it in a collapsed row and exand it\n\n    const collapsedPanels = this.panels.filter(p => p.collapsed);\n\n    for (const panel of collapsedPanels) {\n      var _panel$panels2;\n\n      const hasPanel = (_panel$panels2 = panel.panels) === null || _panel$panels2 === void 0 ? void 0 : _panel$panels2.some(rp => rp.id === panelId);\n      hasPanel && this.toggleRow(panel);\n    }\n\n    return this.getPanelById(panelId);\n  }\n\n  toggleLegendsForAll() {\n    const panelsWithLegends = this.panels.filter(isPanelWithLegend); // determine if more panels are displaying legends or not\n\n    const onCount = panelsWithLegends.filter(panel => panel.legend.show).length;\n    const offCount = panelsWithLegends.length - onCount;\n    const panelLegendsOn = onCount >= offCount;\n\n    for (const panel of panelsWithLegends) {\n      panel.legend.show = !panelLegendsOn;\n      panel.render();\n    }\n  }\n\n  getVariables() {\n    return this.getVariablesFromState(this.uid);\n  }\n\n  canEditAnnotations(dashboardId) {\n    let canEdit = true; // if RBAC is enabled there are additional conditions to check\n\n    if (contextSrv.accessControlEnabled()) {\n      if (dashboardId === 0) {\n        var _this$meta$annotation;\n\n        canEdit = !!((_this$meta$annotation = this.meta.annotationsPermissions) !== null && _this$meta$annotation !== void 0 && _this$meta$annotation.organization.canEdit);\n      } else {\n        var _this$meta$annotation2;\n\n        canEdit = !!((_this$meta$annotation2 = this.meta.annotationsPermissions) !== null && _this$meta$annotation2 !== void 0 && _this$meta$annotation2.dashboard.canEdit);\n      }\n    }\n\n    return this.canEditDashboard() && canEdit;\n  }\n\n  canAddAnnotations() {\n    var _this$meta$annotation3;\n\n    // If RBAC is enabled there are additional conditions to check\n    const canAdd = !contextSrv.accessControlEnabled() || ((_this$meta$annotation3 = this.meta.annotationsPermissions) === null || _this$meta$annotation3 === void 0 ? void 0 : _this$meta$annotation3.dashboard.canAdd);\n    return this.canEditDashboard() && canAdd;\n  }\n\n  canEditDashboard() {\n    return this.meta.canEdit || this.meta.canMakeEditable;\n  }\n\n  shouldUpdateDashboardPanelFromJSON(updatedPanel, panel) {\n    const shouldUpdateGridPositionLayout = !isEqual(updatedPanel === null || updatedPanel === void 0 ? void 0 : updatedPanel.gridPos, panel === null || panel === void 0 ? void 0 : panel.gridPos);\n\n    if (shouldUpdateGridPositionLayout) {\n      this.events.publish(new DashboardPanelsChangedEvent());\n    }\n  }\n\n  getPanelRepeatVariable(panel) {\n    return this.getVariablesFromState(this.uid).find(variable => variable.name === panel.repeat);\n  }\n\n  isSnapshotTruthy() {\n    return this.snapshot;\n  }\n\n  hasVariables() {\n    return this.getVariablesFromState(this.uid).length > 0;\n  }\n\n  hasVariablesChanged(originalVariables, currentVariables) {\n    if (originalVariables.length !== currentVariables.length) {\n      return false;\n    }\n\n    const updated = currentVariables.map(variable => ({\n      name: variable.name,\n      type: variable.type,\n      current: cloneDeep(variable.current),\n      filters: cloneDeep(variable.filters)\n    }));\n    return !isEqual(updated, originalVariables);\n  }\n\n  cloneVariablesFrom(variables) {\n    return variables.map(variable => ({\n      name: variable.name,\n      type: variable.type,\n      current: cloneDeep(variable.current),\n      filters: cloneDeep(variable.filters)\n    }));\n  }\n\n  variablesTimeRangeProcessDoneHandler(event) {\n    const processRepeats = event.payload.variableIds.length > 0;\n    this.variablesChangedHandler(new VariablesChanged({\n      panelIds: [],\n      refreshAll: true\n    }), processRepeats);\n  }\n\n  variablesChangedHandler(event, processRepeats = true) {\n    if (processRepeats) {\n      this.processRepeats();\n    }\n\n    if (event.payload.refreshAll || getTimeSrv().isRefreshOutsideThreshold(this.lastRefresh)) {\n      this.startRefresh({\n        refreshAll: true,\n        panelIds: []\n      });\n      return;\n    }\n\n    if (this.panelInEdit || this.panelInView) {\n      this.panelsAffectedByVariableChange = event.payload.panelIds.filter(id => {\n        var _this$panelInEdit$id, _this$panelInEdit, _this$panelInView2;\n\n        return id !== ((_this$panelInEdit$id = (_this$panelInEdit = this.panelInEdit) === null || _this$panelInEdit === void 0 ? void 0 : _this$panelInEdit.id) !== null && _this$panelInEdit$id !== void 0 ? _this$panelInEdit$id : (_this$panelInView2 = this.panelInView) === null || _this$panelInView2 === void 0 ? void 0 : _this$panelInView2.id);\n      });\n    }\n\n    this.startRefresh(event.payload);\n  }\n\n  variablesChangedInUrlHandler(event) {\n    this.templateVariableValueUpdated();\n    this.startRefresh(event.payload);\n  }\n\n}\n\n_defineProperty(DashboardModel, \"nonPersistedProperties\", {\n  events: true,\n  meta: true,\n  panels: true,\n  // needs special handling\n  templating: true,\n  // needs special handling\n  originalTime: true,\n  originalTemplating: true,\n  originalLibraryPanels: true,\n  panelInEdit: true,\n  panelInView: true,\n  getVariablesFromState: true,\n  formatDate: true,\n  appEventsSubscription: true,\n  panelsAffectedByVariableChange: true,\n  lastRefresh: true\n});\n\nfunction isPanelWithLegend(panel) {\n  return Boolean(panel.legend);\n}","map":{"version":3,"names":["cloneDeep","defaults","_defaults","filter","indexOf","isEqual","map","maxBy","pull","Subscription","dateTime","dateTimeFormat","dateTimeFormatTimeAgo","EventBusSrv","RefreshEvent","TimeRangeUpdatedEvent","DEFAULT_ANNOTATION_COLOR","GRID_CELL_HEIGHT","GRID_CELL_VMARGIN","GRID_COLUMN_COUNT","REPEAT_DIR_VERTICAL","contextSrv","sortedDeepCloneWithoutNulls","variableAdapters","onTimeRangeUpdated","getVariablesByKey","CoreEvents","KioskMode","DashboardPanelsChangedEvent","RenderEvent","appEvents","dispatch","VariablesChanged","VariablesChangedInUrl","VariablesTimeRangeProcessDone","isAllVariable","getTimeSrv","mergePanels","DashboardMigrator","PanelModel","deleteScopeVars","isOnTheSameGridRow","DashboardModel","constructor","data","meta","getVariablesFromState","events","id","uid","revision","title","autoUpdate","description","tags","style","timezone","weekStart","editable","graphTooltip","time","from","to","timepicker","liveNow","Boolean","templating","ensureListExist","annotations","refresh","snapshot","schemaVersion","fiscalYearStartMonth","version","links","gnetId","panels","panelData","ensurePanelsHaveIds","formatDate","bind","resetOriginalVariables","resetOriginalTime","initMeta","updateSchema","addBuiltInAnnotationQuery","sortPanelsByGridPos","panelsAffectedByVariableChange","appEventsSubscription","lastRefresh","Date","now","add","subscribe","variablesChangedHandler","variablesTimeRangeProcessDoneHandler","variablesChangedInUrlHandler","found","list","some","item","builtIn","unshift","datasource","type","name","iconColor","enable","hide","canShare","canSave","canStar","canEdit","canDelete","showSettings","canMakeEditable","hasUnsavedFolderChange","getSaveModelClone","options","saveVariables","saveTimerange","copy","property","nonPersistedProperties","hasOwnProperty","updateTemplatingSaveModelClone","originalTime","getPanelSaveModels","getVariables","updatePanels","info","changed","publish","panel","isSnapshotTruthy","repeatPanelId","repeatedByRow","panelInEdit","getSaveModel","model","scopedVars","length","rowPanel","originalVariables","originalTemplating","currentVariables","variable","get","current","original","find","filters","timeRangeUpdated","timeRange","startRefresh","event","refreshAll","panelIds","includes","otherPanelInFullscreen","render","panelInitialized","lastResult","getQueryRunner","getLastResult","panelInView","isViewing","isEditing","initEditPanel","sourcePanel","pauseAutoRefresh","getEditClone","initViewPanel","setIsViewing","exitViewPanel","undefined","refreshIfPanelsAffectedByVariableChange","exitPanelEditor","destroy","resumeAutoRefresh","nextPanelId","getNextPanelId","panelIterator","max","rowPanels","forEachPanel","callback","i","getPanelById","p","canEditPanel","canEditPanelById","addPanel","sort","panelA","panelB","gridPos","y","x","clearUnsavedChanges","configRev","hasUnsavedChanges","changedPanel","hasChanged","cleanUpRepeats","hasVariables","iteration","getTime","panelsToRemove","repeat","repeatIteration","processRepeats","repeatPanel","cleanUpRowRepeats","row","processRowRepeats","collapsed","rowPanelIndex","findIndex","getRowPanels","panelIndex","getPanelRepeatClone","valueIndex","sourcePanelIndex","m","clone","splice","getRowRepeatClone","sourceRowPanel","insertPos","updateRepeatedPanelIds","getPanelRepeatVariable","repeatRow","selectedOptions","getSelectedVariableOptions","maxPerRow","xPos","yPos","index","option","repeatDirection","h","w","Math","yOffset","panelBelowIndex","curPanel","slice","setScopedVars","variableOption","optionIndex","rowCopy","rowHeight","getRowHeight","forEach","cloneRowPanel","selected","rowYPos","positions","maxPos","pos","removePanel","removeRow","removePanels","needToggle","toggleRow","expandRows","collapsedRows","collapseRows","isSubMenuVisible","annotation","getPanelInfoById","panelId","duplicatePanel","newPanel","alert","thresholds","date","format","timeZone","getTimezone","unsubscribe","removeAllListeners","rowIndex","hasRepeat","firstPanelYPos","yDiff","yMax","pushDownAmount","panelsBelowRow","nextRowIndex","on","console","log","off","cycleGraphTooltip","sharedTooltipModeEnabled","sharedCrosshairModeOnly","getRelativeTime","isSnapshot","user","old","migrator","hasTimeChanged","initial","cloneVariablesFrom","hasVariableValuesChanged","hasVariablesChanged","autoFitPanels","viewHeight","kioskMode","currentGridHeight","navbarHeight","margin","submenuHeight","visibleHeight","submenuEnabled","TV","visibleGridHeight","floor","scaleFactor","round","templateVariableValueUpdated","emit","getPanelByUrlId","panelUrlId","parseInt","collapsedPanels","hasPanel","rp","toggleLegendsForAll","panelsWithLegends","isPanelWithLegend","onCount","legend","show","offCount","panelLegendsOn","canEditAnnotations","dashboardId","accessControlEnabled","annotationsPermissions","organization","dashboard","canEditDashboard","canAddAnnotations","canAdd","shouldUpdateDashboardPanelFromJSON","updatedPanel","shouldUpdateGridPositionLayout","updated","variables","payload","variableIds","isRefreshOutsideThreshold","originalLibraryPanels"],"sources":["/home/soula/grafana/public/app/features/dashboard/state/DashboardModel.ts"],"sourcesContent":["import { cloneDeep, defaults as _defaults, filter, indexOf, isEqual, map, maxBy, pull } from 'lodash';\nimport { Subscription } from 'rxjs';\n\nimport {\n  AnnotationQuery,\n  AppEvent,\n  DashboardCursorSync,\n  dateTime,\n  dateTimeFormat,\n  dateTimeFormatTimeAgo,\n  DateTimeInput,\n  EventBusExtended,\n  EventBusSrv,\n  PanelModel as IPanelModel,\n  TimeRange,\n  TimeZone,\n  UrlQueryValue,\n} from '@grafana/data';\nimport { RefreshEvent, TimeRangeUpdatedEvent } from '@grafana/runtime';\nimport { DEFAULT_ANNOTATION_COLOR } from '@grafana/ui';\nimport { GRID_CELL_HEIGHT, GRID_CELL_VMARGIN, GRID_COLUMN_COUNT, REPEAT_DIR_VERTICAL } from 'app/core/constants';\nimport { contextSrv } from 'app/core/services/context_srv';\nimport { sortedDeepCloneWithoutNulls } from 'app/core/utils/object';\nimport { variableAdapters } from 'app/features/variables/adapters';\nimport { onTimeRangeUpdated } from 'app/features/variables/state/actions';\nimport { GetVariables, getVariablesByKey } from 'app/features/variables/state/selectors';\nimport { CoreEvents, DashboardMeta, KioskMode } from 'app/types';\nimport { DashboardPanelsChangedEvent, RenderEvent } from 'app/types/events';\n\nimport { appEvents } from '../../../core/core';\nimport { dispatch } from '../../../store/store';\nimport {\n  VariablesChanged,\n  VariablesChangedEvent,\n  VariablesChangedInUrl,\n  VariablesTimeRangeProcessDone,\n} from '../../variables/types';\nimport { isAllVariable } from '../../variables/utils';\nimport { getTimeSrv } from '../services/TimeSrv';\nimport { mergePanels, PanelMergeInfo } from '../utils/panelMerge';\n\nimport { DashboardMigrator } from './DashboardMigrator';\nimport { GridPos, PanelModel } from './PanelModel';\nimport { TimeModel } from './TimeModel';\nimport { deleteScopeVars, isOnTheSameGridRow } from './utils';\n\nexport interface CloneOptions {\n  saveVariables?: boolean;\n  saveTimerange?: boolean;\n  message?: string;\n}\n\nexport type DashboardLinkType = 'link' | 'dashboards';\n\nexport interface DashboardLink {\n  icon: string;\n  title: string;\n  tooltip: string;\n  type: DashboardLinkType;\n  url: string;\n  asDropdown: boolean;\n  tags: any[];\n  searchHits?: any[];\n  targetBlank: boolean;\n  keepTime: boolean;\n  includeVars: boolean;\n}\n\nexport class DashboardModel implements TimeModel {\n  id: any;\n  uid: string;\n  title: string;\n  autoUpdate: any;\n  description: any;\n  tags: any;\n  style: any;\n  timezone: any;\n  weekStart: any;\n  editable: any;\n  graphTooltip: DashboardCursorSync;\n  time: any;\n  liveNow: boolean;\n  private originalTime: any;\n  timepicker: any;\n  templating: { list: any[] };\n  private originalTemplating: any;\n  annotations: { list: AnnotationQuery[] };\n  refresh: any;\n  snapshot: any;\n  schemaVersion: number;\n  version: number;\n  revision: number;\n  links: DashboardLink[];\n  gnetId: any;\n  panels: PanelModel[];\n  panelInEdit?: PanelModel;\n  panelInView?: PanelModel;\n  fiscalYearStartMonth?: number;\n  private panelsAffectedByVariableChange: number[] | null;\n  private appEventsSubscription: Subscription;\n  private lastRefresh: number;\n\n  // ------------------\n  // not persisted\n  // ------------------\n\n  // repeat process cycles\n  iteration?: number;\n  declare meta: DashboardMeta;\n  events: EventBusExtended;\n\n  static nonPersistedProperties: { [str: string]: boolean } = {\n    events: true,\n    meta: true,\n    panels: true, // needs special handling\n    templating: true, // needs special handling\n    originalTime: true,\n    originalTemplating: true,\n    originalLibraryPanels: true,\n    panelInEdit: true,\n    panelInView: true,\n    getVariablesFromState: true,\n    formatDate: true,\n    appEventsSubscription: true,\n    panelsAffectedByVariableChange: true,\n    lastRefresh: true,\n  };\n\n  constructor(data: any, meta?: DashboardMeta, private getVariablesFromState: GetVariables = getVariablesByKey) {\n    if (!data) {\n      data = {};\n    }\n\n    this.events = new EventBusSrv();\n    this.id = data.id || null;\n    this.uid = data.uid || null;\n    this.revision = data.revision;\n    this.title = data.title ?? 'No Title';\n    this.autoUpdate = data.autoUpdate;\n    this.description = data.description;\n    this.tags = data.tags ?? [];\n    this.style = data.style ?? 'dark';\n    this.timezone = data.timezone ?? '';\n    this.weekStart = data.weekStart ?? '';\n    this.editable = data.editable !== false;\n    this.graphTooltip = data.graphTooltip || 0;\n    this.time = data.time ?? { from: 'now-6h', to: 'now' };\n    this.timepicker = data.timepicker ?? {};\n    this.liveNow = Boolean(data.liveNow);\n    this.templating = this.ensureListExist(data.templating);\n    this.annotations = this.ensureListExist(data.annotations);\n    this.refresh = data.refresh;\n    this.snapshot = data.snapshot;\n    this.schemaVersion = data.schemaVersion ?? 0;\n    this.fiscalYearStartMonth = data.fiscalYearStartMonth ?? 0;\n    this.version = data.version ?? 0;\n    this.links = data.links ?? [];\n    this.gnetId = data.gnetId || null;\n    this.panels = map(data.panels ?? [], (panelData: any) => new PanelModel(panelData));\n    this.ensurePanelsHaveIds();\n    this.formatDate = this.formatDate.bind(this);\n\n    this.resetOriginalVariables(true);\n    this.resetOriginalTime();\n\n    this.initMeta(meta);\n    this.updateSchema(data);\n\n    this.addBuiltInAnnotationQuery();\n    this.sortPanelsByGridPos();\n    this.panelsAffectedByVariableChange = null;\n    this.appEventsSubscription = new Subscription();\n    this.lastRefresh = Date.now();\n    this.appEventsSubscription.add(appEvents.subscribe(VariablesChanged, this.variablesChangedHandler.bind(this)));\n    this.appEventsSubscription.add(\n      appEvents.subscribe(VariablesTimeRangeProcessDone, this.variablesTimeRangeProcessDoneHandler.bind(this))\n    );\n    this.appEventsSubscription.add(\n      appEvents.subscribe(VariablesChangedInUrl, this.variablesChangedInUrlHandler.bind(this))\n    );\n  }\n\n  addBuiltInAnnotationQuery() {\n    const found = this.annotations.list.some((item) => item.builtIn === 1);\n    if (found) {\n      return;\n    }\n\n    this.annotations.list.unshift({\n      datasource: { uid: '-- Grafana --', type: 'grafana' },\n      name: 'Annotations & Alerts',\n      type: 'dashboard',\n      iconColor: DEFAULT_ANNOTATION_COLOR,\n      enable: true,\n      hide: true,\n      builtIn: 1,\n    });\n  }\n\n  private initMeta(meta?: DashboardMeta) {\n    meta = meta || {};\n\n    meta.canShare = meta.canShare !== false;\n    meta.canSave = meta.canSave !== false;\n    meta.canStar = meta.canStar !== false;\n    meta.canEdit = meta.canEdit !== false;\n    meta.canDelete = meta.canDelete !== false;\n\n    meta.showSettings = meta.canSave;\n    meta.canMakeEditable = meta.canSave && !this.editable;\n    meta.hasUnsavedFolderChange = false;\n\n    if (!this.editable) {\n      meta.canEdit = false;\n      meta.canDelete = false;\n      meta.canSave = false;\n    }\n\n    this.meta = meta;\n  }\n\n  // cleans meta data and other non persistent state\n  getSaveModelClone(options?: CloneOptions): DashboardModel {\n    const defaults = _defaults(options || {}, {\n      saveVariables: true,\n      saveTimerange: true,\n    });\n\n    // make clone\n    let copy: any = {};\n    for (const property in this) {\n      if (DashboardModel.nonPersistedProperties[property] || !this.hasOwnProperty(property)) {\n        continue;\n      }\n\n      copy[property] = cloneDeep(this[property]);\n    }\n\n    this.updateTemplatingSaveModelClone(copy, defaults);\n\n    if (!defaults.saveTimerange) {\n      copy.time = this.originalTime;\n    }\n\n    // get panel save models\n    copy.panels = this.getPanelSaveModels();\n\n    //  sort by keys\n    copy = sortedDeepCloneWithoutNulls(copy);\n    copy.getVariables = () => copy.templating.list;\n\n    return copy;\n  }\n\n  /**\n   * This will load a new dashboard, but keep existing panels unchanged\n   *\n   * This function can be used to implement:\n   * 1. potentially faster loading dashboard loading\n   * 2. dynamic dashboard behavior\n   * 3. \"live\" dashboard editing\n   *\n   * @internal and experimental\n   */\n  updatePanels(panels: IPanelModel[]): PanelMergeInfo {\n    const info = mergePanels(this.panels, panels ?? []);\n    if (info.changed) {\n      this.panels = info.panels ?? [];\n      this.sortPanelsByGridPos();\n      this.events.publish(new DashboardPanelsChangedEvent());\n    }\n    return info;\n  }\n\n  private getPanelSaveModels() {\n    return this.panels\n      .filter(\n        (panel) =>\n          this.isSnapshotTruthy() || !(panel.type === 'add-panel' || panel.repeatPanelId || panel.repeatedByRow)\n      )\n      .map((panel) => {\n        // If we save while editing we should include the panel in edit mode instead of the\n        // unmodified source panel\n        if (this.panelInEdit && this.panelInEdit.id === panel.id) {\n          return this.panelInEdit.getSaveModel();\n        }\n\n        return panel.getSaveModel();\n      })\n      .map((model: any) => {\n        if (this.isSnapshotTruthy()) {\n          return model;\n        }\n        // Clear any scopedVars from persisted mode. This cannot be part of getSaveModel as we need to be able to copy\n        // panel models with preserved scopedVars, for example when going into edit mode.\n        delete model.scopedVars;\n\n        // Clear any repeated panels from collapsed rows\n        if (model.type === 'row' && model.panels && model.panels.length > 0) {\n          model.panels = model.panels\n            .filter((rowPanel: PanelModel) => !rowPanel.repeatPanelId)\n            .map((model: PanelModel) => {\n              delete model.scopedVars;\n              return model;\n            });\n        }\n\n        return model;\n      });\n  }\n\n  private updateTemplatingSaveModelClone(\n    copy: any,\n    defaults: { saveTimerange: boolean; saveVariables: boolean } & CloneOptions\n  ) {\n    const originalVariables = this.originalTemplating;\n    const currentVariables = this.getVariablesFromState(this.uid);\n\n    copy.templating = {\n      list: currentVariables.map((variable) =>\n        variableAdapters.get(variable.type).getSaveModel(variable, defaults.saveVariables)\n      ),\n    };\n\n    if (!defaults.saveVariables) {\n      for (const current of copy.templating.list) {\n        const original = originalVariables.find(\n          ({ name, type }: any) => name === current.name && type === current.type\n        );\n\n        if (!original) {\n          continue;\n        }\n\n        if (current.type === 'adhoc') {\n          current.filters = original.filters;\n        } else {\n          current.current = original.current;\n        }\n      }\n    }\n  }\n\n  timeRangeUpdated(timeRange: TimeRange) {\n    this.events.publish(new TimeRangeUpdatedEvent(timeRange));\n    dispatch(onTimeRangeUpdated(this.uid, timeRange));\n  }\n\n  startRefresh(event: VariablesChangedEvent = { refreshAll: true, panelIds: [] }) {\n    this.events.publish(new RefreshEvent());\n    this.lastRefresh = Date.now();\n\n    if (this.panelInEdit && (event.refreshAll || event.panelIds.includes(this.panelInEdit.id))) {\n      this.panelInEdit.refresh();\n      return;\n    }\n\n    for (const panel of this.panels) {\n      if (!this.otherPanelInFullscreen(panel) && (event.refreshAll || event.panelIds.includes(panel.id))) {\n        panel.refresh();\n      }\n    }\n  }\n\n  render() {\n    this.events.publish(new RenderEvent());\n    for (const panel of this.panels) {\n      panel.render();\n    }\n  }\n\n  panelInitialized(panel: PanelModel) {\n    const lastResult = panel.getQueryRunner().getLastResult();\n\n    if (!this.otherPanelInFullscreen(panel) && !lastResult) {\n      panel.refresh();\n    }\n  }\n\n  otherPanelInFullscreen(panel: PanelModel) {\n    return (this.panelInEdit || this.panelInView) && !(panel.isViewing || panel.isEditing);\n  }\n\n  initEditPanel(sourcePanel: PanelModel): PanelModel {\n    getTimeSrv().pauseAutoRefresh();\n    this.panelInEdit = sourcePanel.getEditClone();\n    return this.panelInEdit;\n  }\n\n  initViewPanel(panel: PanelModel) {\n    this.panelInView = panel;\n    panel.setIsViewing(true);\n  }\n\n  exitViewPanel(panel: PanelModel) {\n    this.panelInView = undefined;\n    panel.setIsViewing(false);\n    this.refreshIfPanelsAffectedByVariableChange();\n  }\n\n  exitPanelEditor() {\n    this.panelInEdit!.destroy();\n    this.panelInEdit = undefined;\n    getTimeSrv().resumeAutoRefresh();\n    this.refreshIfPanelsAffectedByVariableChange();\n  }\n\n  private refreshIfPanelsAffectedByVariableChange() {\n    if (!this.panelsAffectedByVariableChange) {\n      return;\n    }\n\n    this.startRefresh({ panelIds: this.panelsAffectedByVariableChange, refreshAll: false });\n    this.panelsAffectedByVariableChange = null;\n  }\n\n  private ensurePanelsHaveIds() {\n    let nextPanelId = this.getNextPanelId();\n    for (const panel of this.panelIterator()) {\n      panel.id ??= nextPanelId++;\n    }\n  }\n\n  private ensureListExist(data: any = {}) {\n    data.list ??= [];\n    return data;\n  }\n\n  getNextPanelId() {\n    let max = 0;\n\n    for (const panel of this.panelIterator()) {\n      if (panel.id > max) {\n        max = panel.id;\n      }\n    }\n\n    return max + 1;\n  }\n\n  *panelIterator() {\n    for (const panel of this.panels) {\n      yield panel;\n\n      const rowPanels = panel.panels ?? [];\n      for (const rowPanel of rowPanels) {\n        yield rowPanel as PanelModel;\n      }\n    }\n  }\n\n  forEachPanel(callback: (panel: PanelModel, index: number) => void) {\n    for (let i = 0; i < this.panels.length; i++) {\n      callback(this.panels[i], i);\n    }\n  }\n\n  getPanelById(id: number): PanelModel | null {\n    if (this.panelInEdit && this.panelInEdit.id === id) {\n      return this.panelInEdit;\n    }\n\n    return this.panels.find((p) => p.id === id) ?? null;\n  }\n\n  canEditPanel(panel?: PanelModel | null): boolean | undefined | null {\n    return Boolean(this.meta.canEdit && panel && !panel.repeatPanelId && panel.type !== 'row');\n  }\n\n  canEditPanelById(id: number): boolean | undefined | null {\n    return this.canEditPanel(this.getPanelById(id));\n  }\n\n  addPanel(panelData: any) {\n    panelData.id = this.getNextPanelId();\n\n    this.panels.unshift(new PanelModel(panelData));\n\n    this.sortPanelsByGridPos();\n\n    this.events.publish(new DashboardPanelsChangedEvent());\n  }\n\n  sortPanelsByGridPos() {\n    this.panels.sort((panelA, panelB) => {\n      if (panelA.gridPos.y === panelB.gridPos.y) {\n        return panelA.gridPos.x - panelB.gridPos.x;\n      } else {\n        return panelA.gridPos.y - panelB.gridPos.y;\n      }\n    });\n  }\n\n  clearUnsavedChanges() {\n    for (const panel of this.panels) {\n      panel.configRev = 0;\n    }\n  }\n\n  hasUnsavedChanges() {\n    const changedPanel = this.panels.find((p) => p.hasChanged);\n    return Boolean(changedPanel);\n  }\n\n  cleanUpRepeats() {\n    if (this.isSnapshotTruthy() || !this.hasVariables()) {\n      return;\n    }\n\n    this.iteration = (this.iteration || new Date().getTime()) + 1;\n    // cleanup scopedVars\n    deleteScopeVars(this.panels);\n\n    const panelsToRemove = this.panels.filter(\n      (p) => (!p.repeat || p.repeatedByRow) && p.repeatPanelId && p.repeatIteration !== this.iteration\n    );\n\n    // remove panels\n    pull(this.panels, ...panelsToRemove);\n    panelsToRemove.map((p) => p.destroy());\n    this.sortPanelsByGridPos();\n  }\n\n  processRepeats() {\n    if (this.isSnapshotTruthy() || !this.hasVariables()) {\n      return;\n    }\n\n    this.cleanUpRepeats();\n\n    this.iteration = (this.iteration || new Date().getTime()) + 1;\n\n    for (let i = 0; i < this.panels.length; i++) {\n      const panel = this.panels[i];\n      if (panel.repeat) {\n        this.repeatPanel(panel, i);\n      }\n    }\n\n    this.sortPanelsByGridPos();\n    this.events.publish(new DashboardPanelsChangedEvent());\n  }\n\n  cleanUpRowRepeats(rowPanels: PanelModel[]) {\n    const panelIds = rowPanels.map((row) => row.id);\n    // Remove repeated panels whose parent is in this row as these will be recreated later in processRowRepeats\n    const panelsToRemove = rowPanels.filter((p) => !p.repeat && p.repeatPanelId && panelIds.includes(p.repeatPanelId));\n\n    pull(rowPanels, ...panelsToRemove);\n    pull(this.panels, ...panelsToRemove);\n  }\n\n  processRowRepeats(row: PanelModel) {\n    if (this.isSnapshotTruthy() || !this.hasVariables()) {\n      return;\n    }\n\n    let rowPanels = row.panels ?? [];\n    if (!row.collapsed) {\n      const rowPanelIndex = this.panels.findIndex((p) => p.id === row.id);\n      rowPanels = this.getRowPanels(rowPanelIndex);\n    }\n\n    this.cleanUpRowRepeats(rowPanels);\n\n    for (const panel of rowPanels) {\n      if (panel.repeat) {\n        const panelIndex = this.panels.findIndex((p) => p.id === panel.id);\n        this.repeatPanel(panel, panelIndex);\n      }\n    }\n  }\n\n  getPanelRepeatClone(sourcePanel: PanelModel, valueIndex: number, sourcePanelIndex: number) {\n    // if first clone return source\n    if (valueIndex === 0) {\n      return sourcePanel;\n    }\n\n    const m = sourcePanel.getSaveModel();\n    m.id = this.getNextPanelId();\n    const clone = new PanelModel(m);\n\n    // insert after source panel + value index\n    this.panels.splice(sourcePanelIndex + valueIndex, 0, clone);\n\n    clone.repeatIteration = this.iteration;\n    clone.repeatPanelId = sourcePanel.id;\n    clone.repeat = undefined;\n\n    if (this.panelInView?.id === clone.id) {\n      clone.setIsViewing(true);\n      this.panelInView = clone;\n    }\n\n    return clone;\n  }\n\n  getRowRepeatClone(sourceRowPanel: PanelModel, valueIndex: number, sourcePanelIndex: number) {\n    // if first clone return source\n    if (valueIndex === 0) {\n      if (!sourceRowPanel.collapsed) {\n        const rowPanels = this.getRowPanels(sourcePanelIndex);\n        sourceRowPanel.panels = rowPanels;\n      }\n      return sourceRowPanel;\n    }\n\n    const clone = new PanelModel(sourceRowPanel.getSaveModel());\n    // for row clones we need to figure out panels under row to clone and where to insert clone\n    let rowPanels: PanelModel[], insertPos: number;\n    if (sourceRowPanel.collapsed) {\n      rowPanels = cloneDeep(sourceRowPanel.panels) ?? [];\n      clone.panels = rowPanels;\n      // insert copied row after preceding row\n      insertPos = sourcePanelIndex + valueIndex;\n    } else {\n      rowPanels = this.getRowPanels(sourcePanelIndex);\n      clone.panels = rowPanels.map((panel) => panel.getSaveModel());\n      // insert copied row after preceding row's panels\n      insertPos = sourcePanelIndex + (rowPanels.length + 1) * valueIndex;\n    }\n    this.panels.splice(insertPos, 0, clone);\n\n    this.updateRepeatedPanelIds(clone);\n    return clone;\n  }\n\n  repeatPanel(panel: PanelModel, panelIndex: number) {\n    const variable = this.getPanelRepeatVariable(panel);\n    if (!variable) {\n      return;\n    }\n\n    if (panel.type === 'row') {\n      this.repeatRow(panel, panelIndex, variable);\n      return;\n    }\n\n    const selectedOptions = this.getSelectedVariableOptions(variable);\n\n    const maxPerRow = panel.maxPerRow || 4;\n    let xPos = 0;\n    let yPos = panel.gridPos.y;\n\n    for (let index = 0; index < selectedOptions.length; index++) {\n      const option = selectedOptions[index];\n      let copy;\n\n      copy = this.getPanelRepeatClone(panel, index, panelIndex);\n      copy.scopedVars ??= {};\n      copy.scopedVars[variable.name] = option;\n\n      if (panel.repeatDirection === REPEAT_DIR_VERTICAL) {\n        if (index > 0) {\n          yPos += copy.gridPos.h;\n        }\n        copy.gridPos.y = yPos;\n      } else {\n        // set width based on how many are selected\n        // assumed the repeated panels should take up full row width\n        copy.gridPos.w = Math.max(GRID_COLUMN_COUNT / selectedOptions.length, GRID_COLUMN_COUNT / maxPerRow);\n        copy.gridPos.x = xPos;\n        copy.gridPos.y = yPos;\n\n        xPos += copy.gridPos.w;\n\n        // handle overflow by pushing down one row\n        if (xPos + copy.gridPos.w > GRID_COLUMN_COUNT) {\n          xPos = 0;\n          yPos += copy.gridPos.h;\n        }\n      }\n    }\n\n    // Update gridPos for panels below\n    const yOffset = yPos - panel.gridPos.y;\n    if (yOffset > 0) {\n      const panelBelowIndex = panelIndex + selectedOptions.length;\n      for (const curPanel of this.panels.slice(panelBelowIndex)) {\n        if (isOnTheSameGridRow(panel, curPanel)) {\n          continue;\n        }\n\n        curPanel.gridPos.y += yOffset;\n      }\n    }\n  }\n\n  repeatRow(panel: PanelModel, panelIndex: number, variable: any) {\n    const selectedOptions = this.getSelectedVariableOptions(variable);\n    let yPos = panel.gridPos.y;\n\n    function setScopedVars(panel: PanelModel, variableOption: any) {\n      panel.scopedVars ??= {};\n      panel.scopedVars[variable.name] = variableOption;\n    }\n\n    for (let optionIndex = 0; optionIndex < selectedOptions.length; optionIndex++) {\n      const option = selectedOptions[optionIndex];\n      const rowCopy = this.getRowRepeatClone(panel, optionIndex, panelIndex);\n      setScopedVars(rowCopy, option);\n\n      const rowHeight = this.getRowHeight(rowCopy);\n      const rowPanels = rowCopy.panels || [];\n      let panelBelowIndex;\n\n      if (panel.collapsed) {\n        // For collapsed row just copy its panels and set scoped vars and proper IDs\n        for (const rowPanel of rowPanels) {\n          setScopedVars(rowPanel, option);\n          if (optionIndex > 0) {\n            this.updateRepeatedPanelIds(rowPanel, true);\n          }\n        }\n        rowCopy.gridPos.y += optionIndex;\n        yPos += optionIndex;\n        panelBelowIndex = panelIndex + optionIndex + 1;\n      } else {\n        // insert after 'row' panel\n        const insertPos = panelIndex + (rowPanels.length + 1) * optionIndex + 1;\n        rowPanels.forEach((rowPanel: PanelModel, i: number) => {\n          setScopedVars(rowPanel, option);\n          if (optionIndex > 0) {\n            const cloneRowPanel = new PanelModel(rowPanel);\n            this.updateRepeatedPanelIds(cloneRowPanel, true);\n            // For exposed row additionally set proper Y grid position and add it to dashboard panels\n            cloneRowPanel.gridPos.y += rowHeight * optionIndex;\n            this.panels.splice(insertPos + i, 0, cloneRowPanel);\n          }\n        });\n        rowCopy.panels = [];\n        rowCopy.gridPos.y += rowHeight * optionIndex;\n        yPos += rowHeight;\n        panelBelowIndex = insertPos + rowPanels.length;\n      }\n\n      // Update gridPos for panels below if we inserted more than 1 repeated row panel\n      if (selectedOptions.length > 1) {\n        for (const panel of this.panels.slice(panelBelowIndex)) {\n          panel.gridPos.y += yPos;\n        }\n      }\n    }\n  }\n\n  updateRepeatedPanelIds(panel: PanelModel, repeatedByRow?: boolean) {\n    panel.repeatPanelId = panel.id;\n    panel.id = this.getNextPanelId();\n    panel.repeatIteration = this.iteration;\n    if (repeatedByRow) {\n      panel.repeatedByRow = true;\n    } else {\n      panel.repeat = undefined;\n    }\n    return panel;\n  }\n\n  getSelectedVariableOptions(variable: any) {\n    let selectedOptions: any[];\n    if (isAllVariable(variable)) {\n      selectedOptions = variable.options.slice(1, variable.options.length);\n    } else {\n      selectedOptions = filter(variable.options, { selected: true });\n    }\n    return selectedOptions;\n  }\n\n  getRowHeight(rowPanel: PanelModel): number {\n    if (!rowPanel.panels || rowPanel.panels.length === 0) {\n      return 0;\n    }\n\n    const rowYPos = rowPanel.gridPos.y;\n    const positions = map(rowPanel.panels, 'gridPos');\n    const maxPos = maxBy(positions, (pos: GridPos) => pos.y + pos.h);\n    return maxPos!.y + maxPos!.h - rowYPos;\n  }\n\n  removePanel(panel: PanelModel) {\n    this.panels = this.panels.filter((item) => item !== panel);\n    this.events.publish(new DashboardPanelsChangedEvent());\n  }\n\n  removeRow(row: PanelModel, removePanels: boolean) {\n    const needToggle = (!removePanels && row.collapsed) || (removePanels && !row.collapsed);\n\n    if (needToggle) {\n      this.toggleRow(row);\n    }\n\n    this.removePanel(row);\n  }\n\n  expandRows() {\n    const collapsedRows = this.panels.filter((p) => p.type === 'row' && p.collapsed);\n    for (const row of collapsedRows) {\n      this.toggleRow(row);\n    }\n  }\n\n  collapseRows() {\n    const collapsedRows = this.panels.filter((p) => p.type === 'row' && !p.collapsed);\n    for (const row of collapsedRows) {\n      this.toggleRow(row);\n    }\n  }\n\n  isSubMenuVisible() {\n    return (\n      this.links.length > 0 ||\n      this.getVariables().some((variable) => variable.hide !== 2) ||\n      this.annotations.list.some((annotation) => !annotation.hide)\n    );\n  }\n\n  getPanelInfoById(panelId: number) {\n    const panelIndex = this.panels.findIndex((p) => p.id === panelId);\n    return panelIndex >= 0 ? { panel: this.panels[panelIndex], index: panelIndex } : null;\n  }\n\n  duplicatePanel(panel: PanelModel) {\n    const newPanel = panel.getSaveModel();\n    newPanel.id = this.getNextPanelId();\n\n    delete newPanel.repeat;\n    delete newPanel.repeatIteration;\n    delete newPanel.repeatPanelId;\n    delete newPanel.scopedVars;\n    if (newPanel.alert) {\n      delete newPanel.thresholds;\n    }\n    delete newPanel.alert;\n\n    // does it fit to the right?\n    if (panel.gridPos.x + panel.gridPos.w * 2 <= GRID_COLUMN_COUNT) {\n      newPanel.gridPos.x += panel.gridPos.w;\n    } else {\n      // add below\n      newPanel.gridPos.y += panel.gridPos.h;\n    }\n\n    this.addPanel(newPanel);\n    return newPanel;\n  }\n\n  formatDate(date: DateTimeInput, format?: string) {\n    return dateTimeFormat(date, {\n      format,\n      timeZone: this.getTimezone(),\n    });\n  }\n\n  destroy() {\n    this.appEventsSubscription.unsubscribe();\n    this.events.removeAllListeners();\n    for (const panel of this.panels) {\n      panel.destroy();\n    }\n  }\n\n  toggleRow(row: PanelModel) {\n    const rowIndex = indexOf(this.panels, row);\n\n    if (!row.collapsed) {\n      const rowPanels = this.getRowPanels(rowIndex);\n\n      // remove panels\n      pull(this.panels, ...rowPanels);\n      // save panel models inside row panel\n      row.panels = rowPanels.map((panel: PanelModel) => panel.getSaveModel());\n      row.collapsed = true;\n\n      if (rowPanels.some((panel) => panel.hasChanged)) {\n        row.configRev++;\n      }\n\n      // emit change event\n      this.events.publish(new DashboardPanelsChangedEvent());\n      return;\n    }\n\n    row.collapsed = false;\n    const rowPanels = row.panels ?? [];\n    const hasRepeat = rowPanels.some((p: PanelModel) => p.repeat);\n    if (rowPanels.length > 0) {\n      // Use first panel to figure out if it was moved or pushed\n      // If the panel doesn't have gridPos.y, use the row gridPos.y instead.\n      // This can happen for some generated dashboards.\n      const firstPanelYPos = rowPanels[0].gridPos.y ?? row.gridPos.y;\n      const yDiff = firstPanelYPos - (row.gridPos.y + row.gridPos.h);\n\n      // start inserting after row\n      let insertPos = rowIndex + 1;\n      // y max will represent the bottom y pos after all panels have been added\n      // needed to know home much panels below should be pushed down\n      let yMax = row.gridPos.y;\n\n      for (const panel of rowPanels) {\n        // set the y gridPos if it wasn't already set\n        panel.gridPos.y ?? (panel.gridPos.y = row.gridPos.y); // (Safari 13.1 lacks ??= support)\n        // make sure y is adjusted (in case row moved while collapsed)\n        panel.gridPos.y -= yDiff;\n        // insert after row\n        this.panels.splice(insertPos, 0, new PanelModel(panel));\n        // update insert post and y max\n        insertPos += 1;\n        yMax = Math.max(yMax, panel.gridPos.y + panel.gridPos.h);\n      }\n\n      const pushDownAmount = yMax - row.gridPos.y - 1;\n\n      // push panels below down\n      for (const panel of this.panels.slice(insertPos)) {\n        panel.gridPos.y += pushDownAmount;\n      }\n\n      row.panels = [];\n\n      if (hasRepeat) {\n        this.processRowRepeats(row);\n      }\n    }\n\n    // sort panels\n    this.sortPanelsByGridPos();\n\n    // emit change event\n    this.events.publish(new DashboardPanelsChangedEvent());\n  }\n\n  /**\n   * Will return all panels after rowIndex until it encounters another row\n   */\n  getRowPanels(rowIndex: number): PanelModel[] {\n    const panelsBelowRow = this.panels.slice(rowIndex + 1);\n    const nextRowIndex = panelsBelowRow.findIndex((p) => p.type === 'row');\n\n    // Take all panels up to next row, or all panels if there are no other rows\n    const rowPanels = panelsBelowRow.slice(0, nextRowIndex >= 0 ? nextRowIndex : this.panels.length);\n\n    return rowPanels;\n  }\n\n  /** @deprecated */\n  on<T>(event: AppEvent<T>, callback: (payload?: T) => void) {\n    console.log('DashboardModel.on is deprecated use events.subscribe');\n    this.events.on(event, callback);\n  }\n\n  /** @deprecated */\n  off<T>(event: AppEvent<T>, callback: (payload?: T) => void) {\n    console.log('DashboardModel.off is deprecated');\n    this.events.off(event, callback);\n  }\n\n  cycleGraphTooltip() {\n    this.graphTooltip = (this.graphTooltip + 1) % 3;\n  }\n\n  sharedTooltipModeEnabled() {\n    return this.graphTooltip > 0;\n  }\n\n  sharedCrosshairModeOnly() {\n    return this.graphTooltip === 1;\n  }\n\n  getRelativeTime(date: DateTimeInput) {\n    return dateTimeFormatTimeAgo(date, {\n      timeZone: this.getTimezone(),\n    });\n  }\n\n  isSnapshot() {\n    return this.snapshot !== undefined;\n  }\n\n  getTimezone(): TimeZone {\n    return (this.timezone ? this.timezone : contextSrv?.user?.timezone) as TimeZone;\n  }\n\n  private updateSchema(old: any) {\n    const migrator = new DashboardMigrator(this);\n    migrator.updateSchema(old);\n  }\n\n  resetOriginalTime() {\n    this.originalTime = cloneDeep(this.time);\n  }\n\n  hasTimeChanged() {\n    const { time, originalTime } = this;\n\n    // Compare moment values vs strings values\n    return !(\n      isEqual(time, originalTime) ||\n      (isEqual(dateTime(time?.from), dateTime(originalTime?.from)) &&\n        isEqual(dateTime(time?.to), dateTime(originalTime?.to)))\n    );\n  }\n\n  resetOriginalVariables(initial = false) {\n    if (initial) {\n      this.originalTemplating = this.cloneVariablesFrom(this.templating.list);\n      return;\n    }\n\n    this.originalTemplating = this.cloneVariablesFrom(this.getVariablesFromState(this.uid));\n  }\n\n  hasVariableValuesChanged() {\n    return this.hasVariablesChanged(this.originalTemplating, this.getVariablesFromState(this.uid));\n  }\n\n  autoFitPanels(viewHeight: number, kioskMode?: UrlQueryValue) {\n    const currentGridHeight = Math.max(...this.panels.map((panel) => panel.gridPos.h + panel.gridPos.y));\n\n    const navbarHeight = 55;\n    const margin = 20;\n    const submenuHeight = 50;\n\n    let visibleHeight = viewHeight - navbarHeight - margin;\n\n    // Remove submenu height if visible\n    if (this.meta.submenuEnabled && !kioskMode) {\n      visibleHeight -= submenuHeight;\n    }\n\n    // add back navbar height\n    if (kioskMode && kioskMode !== KioskMode.TV) {\n      visibleHeight += navbarHeight;\n    }\n\n    const visibleGridHeight = Math.floor(visibleHeight / (GRID_CELL_HEIGHT + GRID_CELL_VMARGIN));\n    const scaleFactor = currentGridHeight / visibleGridHeight;\n\n    for (const panel of this.panels) {\n      panel.gridPos.y = Math.round(panel.gridPos.y / scaleFactor) || 1;\n      panel.gridPos.h = Math.round(panel.gridPos.h / scaleFactor) || 1;\n    }\n  }\n\n  templateVariableValueUpdated() {\n    this.processRepeats();\n    this.events.emit(CoreEvents.templateVariableValueUpdated);\n  }\n\n  getPanelByUrlId(panelUrlId: string) {\n    const panelId = parseInt(panelUrlId ?? '0', 10);\n\n    // First try to find it in a collapsed row and exand it\n    const collapsedPanels = this.panels.filter((p) => p.collapsed);\n    for (const panel of collapsedPanels) {\n      const hasPanel = panel.panels?.some((rp: any) => rp.id === panelId);\n      hasPanel && this.toggleRow(panel);\n    }\n\n    return this.getPanelById(panelId);\n  }\n\n  toggleLegendsForAll() {\n    const panelsWithLegends = this.panels.filter(isPanelWithLegend);\n\n    // determine if more panels are displaying legends or not\n    const onCount = panelsWithLegends.filter((panel) => panel.legend.show).length;\n    const offCount = panelsWithLegends.length - onCount;\n    const panelLegendsOn = onCount >= offCount;\n\n    for (const panel of panelsWithLegends) {\n      panel.legend.show = !panelLegendsOn;\n      panel.render();\n    }\n  }\n\n  getVariables() {\n    return this.getVariablesFromState(this.uid);\n  }\n\n  canEditAnnotations(dashboardId: number) {\n    let canEdit = true;\n\n    // if RBAC is enabled there are additional conditions to check\n    if (contextSrv.accessControlEnabled()) {\n      if (dashboardId === 0) {\n        canEdit = !!this.meta.annotationsPermissions?.organization.canEdit;\n      } else {\n        canEdit = !!this.meta.annotationsPermissions?.dashboard.canEdit;\n      }\n    }\n    return this.canEditDashboard() && canEdit;\n  }\n\n  canAddAnnotations() {\n    // If RBAC is enabled there are additional conditions to check\n    const canAdd = !contextSrv.accessControlEnabled() || this.meta.annotationsPermissions?.dashboard.canAdd;\n    return this.canEditDashboard() && canAdd;\n  }\n\n  canEditDashboard() {\n    return this.meta.canEdit || this.meta.canMakeEditable;\n  }\n\n  shouldUpdateDashboardPanelFromJSON(updatedPanel: PanelModel, panel: PanelModel) {\n    const shouldUpdateGridPositionLayout = !isEqual(updatedPanel?.gridPos, panel?.gridPos);\n    if (shouldUpdateGridPositionLayout) {\n      this.events.publish(new DashboardPanelsChangedEvent());\n    }\n  }\n\n  private getPanelRepeatVariable(panel: PanelModel) {\n    return this.getVariablesFromState(this.uid).find((variable) => variable.name === panel.repeat);\n  }\n\n  private isSnapshotTruthy() {\n    return this.snapshot;\n  }\n\n  private hasVariables() {\n    return this.getVariablesFromState(this.uid).length > 0;\n  }\n\n  private hasVariablesChanged(originalVariables: any[], currentVariables: any[]): boolean {\n    if (originalVariables.length !== currentVariables.length) {\n      return false;\n    }\n\n    const updated = currentVariables.map((variable: any) => ({\n      name: variable.name,\n      type: variable.type,\n      current: cloneDeep(variable.current),\n      filters: cloneDeep(variable.filters),\n    }));\n\n    return !isEqual(updated, originalVariables);\n  }\n\n  private cloneVariablesFrom(variables: any[]): any[] {\n    return variables.map((variable) => ({\n      name: variable.name,\n      type: variable.type,\n      current: cloneDeep(variable.current),\n      filters: cloneDeep(variable.filters),\n    }));\n  }\n\n  private variablesTimeRangeProcessDoneHandler(event: VariablesTimeRangeProcessDone) {\n    const processRepeats = event.payload.variableIds.length > 0;\n    this.variablesChangedHandler(new VariablesChanged({ panelIds: [], refreshAll: true }), processRepeats);\n  }\n\n  private variablesChangedHandler(event: VariablesChanged, processRepeats = true) {\n    if (processRepeats) {\n      this.processRepeats();\n    }\n\n    if (event.payload.refreshAll || getTimeSrv().isRefreshOutsideThreshold(this.lastRefresh)) {\n      this.startRefresh({ refreshAll: true, panelIds: [] });\n      return;\n    }\n\n    if (this.panelInEdit || this.panelInView) {\n      this.panelsAffectedByVariableChange = event.payload.panelIds.filter(\n        (id) => id !== (this.panelInEdit?.id ?? this.panelInView?.id)\n      );\n    }\n\n    this.startRefresh(event.payload);\n  }\n\n  private variablesChangedInUrlHandler(event: VariablesChangedInUrl) {\n    this.templateVariableValueUpdated();\n    this.startRefresh(event.payload);\n  }\n}\n\nfunction isPanelWithLegend(panel: PanelModel): panel is PanelModel & Pick<Required<PanelModel>, 'legend'> {\n  return Boolean(panel.legend);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}