{"ast":null,"code":"import { getCenter } from 'ol/extent';\nimport { LineString, Point } from 'ol/geom';\nimport { toLonLat } from 'ol/proj';\nimport { getArea, getLength } from 'ol/sphere';\nimport { ArrayVector, FieldType } from '@grafana/data';\nimport { SpatialCalculation } from './models.gen';\n/** Will return a field with a single row */\n\nexport function toLineString(field) {\n  const coords = [];\n\n  for (const geo of field.values.toArray()) {\n    if (geo) {\n      coords.push(getCenterPoint(geo));\n    }\n  }\n\n  return new LineString(coords);\n}\n/** Will return a field with a single row */\n\nexport function calculateBearings(values) {\n  const bearing = new Array(values.length);\n\n  if (values.length > 1) {\n    let prev = getCenterPointWGS84(values[0]);\n\n    for (let i = 1; i < values.length; i++) {\n      let next = getCenterPointWGS84(values[i]);\n\n      if (prev && next) {\n        let degrees = Math.atan2(next[0] - prev[0], next[1] - prev[1]) * 180 / Math.PI;\n\n        if (degrees < 0.0) {\n          degrees += 360.0;\n        }\n\n        bearing[i - 1] = bearing[i] = degrees;\n      }\n    }\n  } else {\n    bearing.fill(0);\n  }\n\n  return bearing;\n}\nexport function getCenterPoint(geo) {\n  if (geo instanceof Point) {\n    return geo.getCoordinates();\n  }\n\n  return getCenter(geo.getExtent());\n}\nexport function getCenterPointWGS84(geo) {\n  if (!geo) {\n    return undefined;\n  }\n\n  return toLonLat(getCenterPoint(geo));\n}\n/** Will return a new field with calculated values */\n\nexport function doGeomeryCalculation(field, options) {\n  var _options$calc, _options$field;\n\n  const values = field.values.toArray();\n  const buffer = new Array(field.values.length);\n  const op = (_options$calc = options.calc) !== null && _options$calc !== void 0 ? _options$calc : SpatialCalculation.Heading;\n  const name = (_options$field = options.field) !== null && _options$field !== void 0 ? _options$field : op;\n\n  switch (op) {\n    case SpatialCalculation.Area:\n      {\n        for (let i = 0; i < values.length; i++) {\n          const geo = values[i];\n\n          if (geo) {\n            buffer[i] = getArea(geo);\n          }\n        }\n\n        return {\n          name,\n          type: FieldType.number,\n          config: {\n            unit: 'areaM2'\n          },\n          values: new ArrayVector(buffer)\n        };\n      }\n\n    case SpatialCalculation.Distance:\n      {\n        for (let i = 0; i < values.length; i++) {\n          const geo = values[i];\n\n          if (geo) {\n            buffer[i] = getLength(geo);\n          }\n        }\n\n        return {\n          name,\n          type: FieldType.number,\n          config: {\n            unit: 'lengthm'\n          },\n          values: new ArrayVector(buffer)\n        };\n      }\n    // Use heading as default\n\n    case SpatialCalculation.Heading:\n    default:\n      {\n        return {\n          name,\n          type: FieldType.number,\n          config: {\n            unit: 'degree'\n          },\n          values: new ArrayVector(calculateBearings(values))\n        };\n      }\n  }\n}","map":{"version":3,"names":["getCenter","LineString","Point","toLonLat","getArea","getLength","ArrayVector","FieldType","SpatialCalculation","toLineString","field","coords","geo","values","toArray","push","getCenterPoint","calculateBearings","bearing","Array","length","prev","getCenterPointWGS84","i","next","degrees","Math","atan2","PI","fill","getCoordinates","getExtent","undefined","doGeomeryCalculation","options","buffer","op","calc","Heading","name","Area","type","number","config","unit","Distance"],"sources":["/home/soula/grafana/public/app/features/transformers/spatial/utils.ts"],"sourcesContent":["import { getCenter } from 'ol/extent';\nimport { Geometry, LineString, Point } from 'ol/geom';\nimport { toLonLat } from 'ol/proj';\nimport { getArea, getLength } from 'ol/sphere';\n\nimport { ArrayVector, Field, FieldType } from '@grafana/data';\n\nimport { SpatialCalculation, SpatialCalculationOption } from './models.gen';\n\n/** Will return a field with a single row */\nexport function toLineString(field: Field<Geometry | undefined>): LineString {\n  const coords: number[][] = [];\n  for (const geo of field.values.toArray()) {\n    if (geo) {\n      coords.push(getCenterPoint(geo));\n    }\n  }\n  return new LineString(coords);\n}\n\n/** Will return a field with a single row */\nexport function calculateBearings(values: Array<Geometry | undefined>): number[] {\n  const bearing = new Array(values.length);\n  if (values.length > 1) {\n    let prev: number[] | undefined = getCenterPointWGS84(values[0]);\n    for (let i = 1; i < values.length; i++) {\n      let next: number[] | undefined = getCenterPointWGS84(values[i]);\n      if (prev && next) {\n        let degrees = (Math.atan2(next[0] - prev[0], next[1] - prev[1]) * 180) / Math.PI;\n        if (degrees < 0.0) {\n          degrees += 360.0;\n        }\n        bearing[i - 1] = bearing[i] = degrees;\n      }\n    }\n  } else {\n    bearing.fill(0);\n  }\n  return bearing;\n}\n\nexport function getCenterPoint(geo: Geometry): number[] {\n  if (geo instanceof Point) {\n    return (geo as Point).getCoordinates();\n  }\n  return getCenter(geo.getExtent());\n}\n\nexport function getCenterPointWGS84(geo?: Geometry): number[] | undefined {\n  if (!geo) {\n    return undefined;\n  }\n  return toLonLat(getCenterPoint(geo));\n}\n\n/** Will return a new field with calculated values */\nexport function doGeomeryCalculation(field: Field<Geometry | undefined>, options: SpatialCalculationOption): Field {\n  const values = field.values.toArray();\n  const buffer = new Array(field.values.length);\n  const op = options.calc ?? SpatialCalculation.Heading;\n  const name = options.field ?? op;\n\n  switch (op) {\n    case SpatialCalculation.Area: {\n      for (let i = 0; i < values.length; i++) {\n        const geo = values[i];\n        if (geo) {\n          buffer[i] = getArea(geo);\n        }\n      }\n      return {\n        name,\n        type: FieldType.number,\n        config: {\n          unit: 'areaM2',\n        },\n        values: new ArrayVector(buffer),\n      };\n    }\n    case SpatialCalculation.Distance: {\n      for (let i = 0; i < values.length; i++) {\n        const geo = values[i];\n        if (geo) {\n          buffer[i] = getLength(geo);\n        }\n      }\n      return {\n        name,\n        type: FieldType.number,\n        config: {\n          unit: 'lengthm',\n        },\n        values: new ArrayVector(buffer),\n      };\n    }\n\n    // Use heading as default\n    case SpatialCalculation.Heading:\n    default: {\n      return {\n        name,\n        type: FieldType.number,\n        config: {\n          unit: 'degree',\n        },\n        values: new ArrayVector(calculateBearings(values)),\n      };\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}