{"ast":null,"code":"import React from 'react';\nimport { useFormContext } from 'react-hook-form';\nimport { Button, Field, Input } from '@grafana/ui';\nimport { OptionField } from './fields/OptionField';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-runtime\";\nexport function ChannelOptions({\n  defaultValues,\n  selectedChannelOptions,\n  onResetSecureField,\n  secureFields,\n  errors,\n  pathPrefix = '',\n  readOnly = false\n}) {\n  const {\n    watch\n  } = useFormContext();\n  const currentFormValues = watch(); // react hook form types ARE LYING!\n\n  return /*#__PURE__*/_jsx(_Fragment, {\n    children: selectedChannelOptions.map((option, index) => {\n      var _ref, _defaultValues$settin;\n\n      const key = `${option.label}-${index}`; // Some options can be dependent on other options, this determines what is selected in the dependency options\n      // I think this needs more thought.\n\n      const selectedOptionValue = currentFormValues[`${pathPrefix}settings.${option.showWhen.field}`];\n\n      if (option.showWhen.field && selectedOptionValue !== option.showWhen.is) {\n        return null;\n      }\n\n      if (secureFields && secureFields[option.propertyName]) {\n        return /*#__PURE__*/_jsx(Field, {\n          label: option.label,\n          description: option.description || undefined,\n          children: /*#__PURE__*/_jsx(Input, {\n            readOnly: true,\n            value: \"Configured\",\n            suffix: readOnly ? null : /*#__PURE__*/_jsx(Button, {\n              onClick: () => onResetSecureField(option.propertyName),\n              fill: \"text\",\n              type: \"button\",\n              size: \"sm\",\n              children: \"Clear\"\n            })\n          })\n        }, key);\n      }\n\n      const error = (_ref = option.secure ? errors === null || errors === void 0 ? void 0 : errors.secureSettings : errors === null || errors === void 0 ? void 0 : errors.settings) === null || _ref === void 0 ? void 0 : _ref[option.propertyName];\n      const defaultValue = defaultValues === null || defaultValues === void 0 ? void 0 : (_defaultValues$settin = defaultValues.settings) === null || _defaultValues$settin === void 0 ? void 0 : _defaultValues$settin[option.propertyName];\n      return /*#__PURE__*/_jsx(OptionField, {\n        defaultValue: defaultValue,\n        readOnly: readOnly,\n        error: error,\n        pathPrefix: pathPrefix,\n        pathSuffix: option.secure ? 'secureSettings.' : 'settings.',\n        option: option\n      }, key);\n    })\n  });\n}","map":{"version":3,"names":["React","useFormContext","Button","Field","Input","OptionField","ChannelOptions","defaultValues","selectedChannelOptions","onResetSecureField","secureFields","errors","pathPrefix","readOnly","watch","currentFormValues","map","option","index","key","label","selectedOptionValue","showWhen","field","is","propertyName","description","undefined","error","secure","secureSettings","settings","defaultValue"],"sources":["/home/soula/grafana/public/app/features/alerting/unified/components/receivers/form/ChannelOptions.tsx"],"sourcesContent":["import React from 'react';\nimport { useFormContext, FieldError, FieldErrors, DeepMap } from 'react-hook-form';\n\nimport { Button, Field, Input } from '@grafana/ui';\nimport { NotificationChannelOption, NotificationChannelSecureFields } from 'app/types';\n\nimport { ChannelValues, ReceiverFormValues } from '../../../types/receiver-form';\n\nimport { OptionField } from './fields/OptionField';\n\nexport interface Props<R extends ChannelValues> {\n  defaultValues: R;\n  selectedChannelOptions: NotificationChannelOption[];\n  secureFields: NotificationChannelSecureFields;\n\n  onResetSecureField: (key: string) => void;\n  errors?: FieldErrors<R>;\n  pathPrefix?: string;\n  readOnly?: boolean;\n}\n\nexport function ChannelOptions<R extends ChannelValues>({\n  defaultValues,\n  selectedChannelOptions,\n  onResetSecureField,\n  secureFields,\n  errors,\n  pathPrefix = '',\n  readOnly = false,\n}: Props<R>): JSX.Element {\n  const { watch } = useFormContext<ReceiverFormValues<R>>();\n  const currentFormValues = watch() as Record<string, any>; // react hook form types ARE LYING!\n  return (\n    <>\n      {selectedChannelOptions.map((option: NotificationChannelOption, index: number) => {\n        const key = `${option.label}-${index}`;\n        // Some options can be dependent on other options, this determines what is selected in the dependency options\n        // I think this needs more thought.\n        const selectedOptionValue = currentFormValues[`${pathPrefix}settings.${option.showWhen.field}`];\n\n        if (option.showWhen.field && selectedOptionValue !== option.showWhen.is) {\n          return null;\n        }\n\n        if (secureFields && secureFields[option.propertyName]) {\n          return (\n            <Field key={key} label={option.label} description={option.description || undefined}>\n              <Input\n                readOnly={true}\n                value=\"Configured\"\n                suffix={\n                  readOnly ? null : (\n                    <Button onClick={() => onResetSecureField(option.propertyName)} fill=\"text\" type=\"button\" size=\"sm\">\n                      Clear\n                    </Button>\n                  )\n                }\n              />\n            </Field>\n          );\n        }\n\n        const error: FieldError | DeepMap<any, FieldError> | undefined = (\n          (option.secure ? errors?.secureSettings : errors?.settings) as DeepMap<any, FieldError> | undefined\n        )?.[option.propertyName];\n\n        const defaultValue = defaultValues?.settings?.[option.propertyName];\n\n        return (\n          <OptionField\n            defaultValue={defaultValue}\n            readOnly={readOnly}\n            key={key}\n            error={error}\n            pathPrefix={pathPrefix}\n            pathSuffix={option.secure ? 'secureSettings.' : 'settings.'}\n            option={option}\n          />\n        );\n      })}\n    </>\n  );\n}\n"],"mappings":"AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,SAASC,cAAT,QAAiE,iBAAjE;AAEA,SAASC,MAAT,EAAiBC,KAAjB,EAAwBC,KAAxB,QAAqC,aAArC;AAKA,SAASC,WAAT,QAA4B,sBAA5B;;;AAaA,OAAO,SAASC,cAAT,CAAiD;EACtDC,aADsD;EAEtDC,sBAFsD;EAGtDC,kBAHsD;EAItDC,YAJsD;EAKtDC,MALsD;EAMtDC,UAAU,GAAG,EANyC;EAOtDC,QAAQ,GAAG;AAP2C,CAAjD,EAQmB;EACxB,MAAM;IAAEC;EAAF,IAAYb,cAAc,EAAhC;EACA,MAAMc,iBAAiB,GAAGD,KAAK,EAA/B,CAFwB,CAEkC;;EAC1D,oBACE;IAAA,UACGN,sBAAsB,CAACQ,GAAvB,CAA2B,CAACC,MAAD,EAAoCC,KAApC,KAAsD;MAAA;;MAChF,MAAMC,GAAG,GAAI,GAAEF,MAAM,CAACG,KAAM,IAAGF,KAAM,EAArC,CADgF,CAEhF;MACA;;MACA,MAAMG,mBAAmB,GAAGN,iBAAiB,CAAE,GAAEH,UAAW,YAAWK,MAAM,CAACK,QAAP,CAAgBC,KAAM,EAAhD,CAA7C;;MAEA,IAAIN,MAAM,CAACK,QAAP,CAAgBC,KAAhB,IAAyBF,mBAAmB,KAAKJ,MAAM,CAACK,QAAP,CAAgBE,EAArE,EAAyE;QACvE,OAAO,IAAP;MACD;;MAED,IAAId,YAAY,IAAIA,YAAY,CAACO,MAAM,CAACQ,YAAR,CAAhC,EAAuD;QACrD,oBACE,KAAC,KAAD;UAAiB,KAAK,EAAER,MAAM,CAACG,KAA/B;UAAsC,WAAW,EAAEH,MAAM,CAACS,WAAP,IAAsBC,SAAzE;UAAA,uBACE,KAAC,KAAD;YACE,QAAQ,EAAE,IADZ;YAEE,KAAK,EAAC,YAFR;YAGE,MAAM,EACJd,QAAQ,GAAG,IAAH,gBACN,KAAC,MAAD;cAAQ,OAAO,EAAE,MAAMJ,kBAAkB,CAACQ,MAAM,CAACQ,YAAR,CAAzC;cAAgE,IAAI,EAAC,MAArE;cAA4E,IAAI,EAAC,QAAjF;cAA0F,IAAI,EAAC,IAA/F;cAAA;YAAA;UALN;QADF,GAAYN,GAAZ,CADF;MAeD;;MAED,MAAMS,KAAwD,WAC3DX,MAAM,CAACY,MAAP,GAAgBlB,MAAhB,aAAgBA,MAAhB,uBAAgBA,MAAM,CAAEmB,cAAxB,GAAyCnB,MAAzC,aAAyCA,MAAzC,uBAAyCA,MAAM,CAAEoB,QADU,yCAAG,KAE7Dd,MAAM,CAACQ,YAFsD,CAAjE;MAIA,MAAMO,YAAY,GAAGzB,aAAH,aAAGA,aAAH,gDAAGA,aAAa,CAAEwB,QAAlB,0DAAG,sBAA0Bd,MAAM,CAACQ,YAAjC,CAArB;MAEA,oBACE,KAAC,WAAD;QACE,YAAY,EAAEO,YADhB;QAEE,QAAQ,EAAEnB,QAFZ;QAIE,KAAK,EAAEe,KAJT;QAKE,UAAU,EAAEhB,UALd;QAME,UAAU,EAAEK,MAAM,CAACY,MAAP,GAAgB,iBAAhB,GAAoC,WANlD;QAOE,MAAM,EAAEZ;MAPV,GAGOE,GAHP,CADF;IAWD,CA7CA;EADH,EADF;AAkDD"},"metadata":{},"sourceType":"module"}