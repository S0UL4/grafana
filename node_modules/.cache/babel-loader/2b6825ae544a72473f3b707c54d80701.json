{"ast":null,"code":"import { identity } from 'lodash';\nimport { FieldType, MutableDataFrame } from '@grafana/data';\n\n/**\n * Transforms response to Grafana trace data frame.\n */\nexport function transformResponse(zSpans) {\n  const spanRows = zSpans.map(transformSpan);\n  const frame = new MutableDataFrame({\n    fields: [{\n      name: 'traceID',\n      type: FieldType.string\n    }, {\n      name: 'spanID',\n      type: FieldType.string\n    }, {\n      name: 'parentSpanID',\n      type: FieldType.string\n    }, {\n      name: 'operationName',\n      type: FieldType.string\n    }, {\n      name: 'serviceName',\n      type: FieldType.string\n    }, {\n      name: 'serviceTags',\n      type: FieldType.other\n    }, {\n      name: 'startTime',\n      type: FieldType.number\n    }, {\n      name: 'duration',\n      type: FieldType.number\n    }, {\n      name: 'logs',\n      type: FieldType.other\n    }, {\n      name: 'tags',\n      type: FieldType.other\n    }],\n    meta: {\n      preferredVisualisationType: 'trace',\n      custom: {\n        traceFormat: 'zipkin'\n      }\n    }\n  });\n\n  for (const span of spanRows) {\n    frame.add(span);\n  }\n\n  return frame;\n}\n\nfunction transformSpan(span) {\n  var _span$localEndpoint, _span$remoteEndpoint, _span$annotations$map, _span$annotations;\n\n  const row = {\n    traceID: span.traceId,\n    spanID: span.id,\n    parentSpanID: span.parentId,\n    operationName: span.name,\n    serviceName: ((_span$localEndpoint = span.localEndpoint) === null || _span$localEndpoint === void 0 ? void 0 : _span$localEndpoint.serviceName) || ((_span$remoteEndpoint = span.remoteEndpoint) === null || _span$remoteEndpoint === void 0 ? void 0 : _span$remoteEndpoint.serviceName) || 'unknown',\n    serviceTags: serviceTags(span),\n    startTime: span.timestamp / 1000,\n    duration: span.duration / 1000,\n    logs: (_span$annotations$map = (_span$annotations = span.annotations) === null || _span$annotations === void 0 ? void 0 : _span$annotations.map(transformAnnotation)) !== null && _span$annotations$map !== void 0 ? _span$annotations$map : [],\n    tags: Object.keys(span.tags || {}).reduce((acc, key) => {\n      // If tag is error we remap it to simple boolean so that the trace ui will show an error icon.\n      if (key === 'error') {\n        acc.push({\n          key: 'error',\n          value: true\n        });\n        acc.push({\n          key: 'errorValue',\n          value: span.tags['error']\n        });\n        return acc;\n      }\n\n      acc.push({\n        key,\n        value: span.tags[key]\n      });\n      return acc;\n    }, [])\n  };\n\n  if (span.kind) {\n    var _row$tags;\n\n    row.tags = [{\n      key: 'kind',\n      value: span.kind\n    }, ...((_row$tags = row.tags) !== null && _row$tags !== void 0 ? _row$tags : [])];\n  }\n\n  if (span.shared) {\n    var _row$tags2;\n\n    row.tags = [{\n      key: 'shared',\n      value: span.shared\n    }, ...((_row$tags2 = row.tags) !== null && _row$tags2 !== void 0 ? _row$tags2 : [])];\n  }\n\n  return row;\n}\n/**\n * Maps annotations as a log as that seems to be the closest thing.\n * See https://zipkin.io/zipkin-api/#/default/get_trace__traceId_\n */\n\n\nfunction transformAnnotation(annotation) {\n  return {\n    timestamp: annotation.timestamp,\n    fields: [{\n      key: 'annotation',\n      value: annotation.value\n    }]\n  };\n}\n\nfunction serviceTags(span) {\n  const endpoint = span.localEndpoint || span.remoteEndpoint;\n\n  if (!endpoint) {\n    return [];\n  }\n\n  return [valueToTag('ipv4', endpoint.ipv4), valueToTag('ipv6', endpoint.ipv6), valueToTag('port', endpoint.port), valueToTag('endpointType', span.localEndpoint ? 'local' : 'remote')].filter(identity);\n}\n\nfunction valueToTag(key, value) {\n  if (!value) {\n    return undefined;\n  }\n\n  return {\n    key,\n    value\n  };\n}\n/**\n * Transforms data frame to Zipkin response\n */\n\n\nexport const transformToZipkin = data => {\n  let response = [];\n\n  for (let i = 0; i < data.length; i++) {\n    var _span$tags$find, _span$tags$find2;\n\n    const span = data.get(i);\n    response.push(Object.assign({\n      traceId: span.traceID,\n      parentId: span.parentSpanID,\n      name: span.operationName,\n      id: span.spanID,\n      timestamp: span.startTime * 1000,\n      duration: span.duration * 1000\n    }, getEndpoint(span), {\n      annotations: span.logs.length ? span.logs.map(l => ({\n        timestamp: l.timestamp,\n        value: l.fields[0].value\n      })) : undefined,\n      tags: span.tags.length ? span.tags.filter(t => t.key !== 'kind' && t.key !== 'endpointType' && t.key !== 'shared').reduce((tags, t) => {\n        if (t.key === 'error') {\n          return Object.assign({}, tags, {\n            [t.key]: span.tags.find(t => t.key === 'errorValue').value || ''\n          });\n        }\n\n        return Object.assign({}, tags, {\n          [t.key]: t.value\n        });\n      }, {}) : undefined,\n      kind: (_span$tags$find = span.tags.find(t => t.key === 'kind')) === null || _span$tags$find === void 0 ? void 0 : _span$tags$find.value,\n      shared: (_span$tags$find2 = span.tags.find(t => t.key === 'shared')) === null || _span$tags$find2 === void 0 ? void 0 : _span$tags$find2.value\n    }));\n  }\n\n  return response;\n}; // Returns remote or local endpoint object\n\nconst getEndpoint = span => {\n  var _span$serviceTags$fin, _span$serviceTags$fin2, _span$serviceTags$fin3, _span$serviceTags$fin4;\n\n  const key = ((_span$serviceTags$fin = span.serviceTags.find(t => t.key === 'endpointType')) === null || _span$serviceTags$fin === void 0 ? void 0 : _span$serviceTags$fin.value) === 'local' ? 'localEndpoint' : 'remoteEndpoint';\n  return span.serviceName !== 'unknown' ? {\n    [key]: {\n      serviceName: span.serviceName,\n      ipv4: (_span$serviceTags$fin2 = span.serviceTags.find(t => t.key === 'ipv4')) === null || _span$serviceTags$fin2 === void 0 ? void 0 : _span$serviceTags$fin2.value,\n      ipv6: (_span$serviceTags$fin3 = span.serviceTags.find(t => t.key === 'ipv6')) === null || _span$serviceTags$fin3 === void 0 ? void 0 : _span$serviceTags$fin3.value,\n      port: (_span$serviceTags$fin4 = span.serviceTags.find(t => t.key === 'port')) === null || _span$serviceTags$fin4 === void 0 ? void 0 : _span$serviceTags$fin4.value\n    }\n  } : undefined;\n};","map":{"version":3,"names":["identity","FieldType","MutableDataFrame","transformResponse","zSpans","spanRows","map","transformSpan","frame","fields","name","type","string","other","number","meta","preferredVisualisationType","custom","traceFormat","span","add","row","traceID","traceId","spanID","id","parentSpanID","parentId","operationName","serviceName","localEndpoint","remoteEndpoint","serviceTags","startTime","timestamp","duration","logs","annotations","transformAnnotation","tags","Object","keys","reduce","acc","key","push","value","kind","shared","annotation","endpoint","valueToTag","ipv4","ipv6","port","filter","undefined","transformToZipkin","data","response","i","length","get","getEndpoint","l","t","find"],"sources":["/home/soula/grafana/public/app/plugins/datasource/zipkin/utils/transforms.ts"],"sourcesContent":["import { identity } from 'lodash';\n\nimport { DataFrame, FieldType, MutableDataFrame, TraceKeyValuePair, TraceLog, TraceSpanRow } from '@grafana/data';\n\nimport { ZipkinAnnotation, ZipkinEndpoint, ZipkinSpan } from '../types';\n\n/**\n * Transforms response to Grafana trace data frame.\n */\nexport function transformResponse(zSpans: ZipkinSpan[]): DataFrame {\n  const spanRows = zSpans.map(transformSpan);\n  const frame = new MutableDataFrame({\n    fields: [\n      { name: 'traceID', type: FieldType.string },\n      { name: 'spanID', type: FieldType.string },\n      { name: 'parentSpanID', type: FieldType.string },\n      { name: 'operationName', type: FieldType.string },\n      { name: 'serviceName', type: FieldType.string },\n      { name: 'serviceTags', type: FieldType.other },\n      { name: 'startTime', type: FieldType.number },\n      { name: 'duration', type: FieldType.number },\n      { name: 'logs', type: FieldType.other },\n      { name: 'tags', type: FieldType.other },\n    ],\n    meta: {\n      preferredVisualisationType: 'trace',\n      custom: {\n        traceFormat: 'zipkin',\n      },\n    },\n  });\n\n  for (const span of spanRows) {\n    frame.add(span);\n  }\n\n  return frame;\n}\n\nfunction transformSpan(span: ZipkinSpan): TraceSpanRow {\n  const row = {\n    traceID: span.traceId,\n    spanID: span.id,\n    parentSpanID: span.parentId,\n    operationName: span.name,\n    serviceName: span.localEndpoint?.serviceName || span.remoteEndpoint?.serviceName || 'unknown',\n    serviceTags: serviceTags(span),\n    startTime: span.timestamp / 1000,\n    duration: span.duration / 1000,\n    logs: span.annotations?.map(transformAnnotation) ?? [],\n    tags: Object.keys(span.tags || {}).reduce<TraceKeyValuePair[]>((acc, key) => {\n      // If tag is error we remap it to simple boolean so that the trace ui will show an error icon.\n      if (key === 'error') {\n        acc.push({\n          key: 'error',\n          value: true,\n        });\n\n        acc.push({\n          key: 'errorValue',\n          value: span.tags!['error'],\n        });\n        return acc;\n      }\n      acc.push({ key, value: span.tags![key] });\n      return acc;\n    }, []),\n  };\n\n  if (span.kind) {\n    row.tags = [\n      {\n        key: 'kind',\n        value: span.kind,\n      },\n      ...(row.tags ?? []),\n    ];\n  }\n\n  if (span.shared) {\n    row.tags = [\n      {\n        key: 'shared',\n        value: span.shared,\n      },\n      ...(row.tags ?? []),\n    ];\n  }\n\n  return row;\n}\n\n/**\n * Maps annotations as a log as that seems to be the closest thing.\n * See https://zipkin.io/zipkin-api/#/default/get_trace__traceId_\n */\nfunction transformAnnotation(annotation: ZipkinAnnotation): TraceLog {\n  return {\n    timestamp: annotation.timestamp,\n    fields: [\n      {\n        key: 'annotation',\n        value: annotation.value,\n      },\n    ],\n  };\n}\n\nfunction serviceTags(span: ZipkinSpan): TraceKeyValuePair[] {\n  const endpoint = span.localEndpoint || span.remoteEndpoint;\n  if (!endpoint) {\n    return [];\n  }\n  return [\n    valueToTag('ipv4', endpoint.ipv4),\n    valueToTag('ipv6', endpoint.ipv6),\n    valueToTag('port', endpoint.port),\n    valueToTag('endpointType', span.localEndpoint ? 'local' : 'remote'),\n  ].filter(identity) as TraceKeyValuePair[];\n}\n\nfunction valueToTag<T>(key: string, value: T): TraceKeyValuePair<T> | undefined {\n  if (!value) {\n    return undefined;\n  }\n  return {\n    key,\n    value,\n  };\n}\n\n/**\n * Transforms data frame to Zipkin response\n */\nexport const transformToZipkin = (data: MutableDataFrame): ZipkinSpan[] => {\n  let response: ZipkinSpan[] = [];\n\n  for (let i = 0; i < data.length; i++) {\n    const span = data.get(i);\n    response.push({\n      traceId: span.traceID,\n      parentId: span.parentSpanID,\n      name: span.operationName,\n      id: span.spanID,\n      timestamp: span.startTime * 1000,\n      duration: span.duration * 1000,\n      ...getEndpoint(span),\n      annotations: span.logs.length\n        ? span.logs.map((l: TraceLog) => ({ timestamp: l.timestamp, value: l.fields[0].value }))\n        : undefined,\n      tags: span.tags.length\n        ? span.tags\n            .filter((t: TraceKeyValuePair) => t.key !== 'kind' && t.key !== 'endpointType' && t.key !== 'shared')\n            .reduce((tags: { [key: string]: string }, t: TraceKeyValuePair) => {\n              if (t.key === 'error') {\n                return {\n                  ...tags,\n                  [t.key]: span.tags.find((t: TraceKeyValuePair) => t.key === 'errorValue').value || '',\n                };\n              }\n              return { ...tags, [t.key]: t.value };\n            }, {})\n        : undefined,\n      kind: span.tags.find((t: TraceKeyValuePair) => t.key === 'kind')?.value,\n      shared: span.tags.find((t: TraceKeyValuePair) => t.key === 'shared')?.value,\n    });\n  }\n\n  return response;\n};\n\n// Returns remote or local endpoint object\nconst getEndpoint = (span: any): { [key: string]: ZipkinEndpoint } | undefined => {\n  const key =\n    span.serviceTags.find((t: TraceKeyValuePair) => t.key === 'endpointType')?.value === 'local'\n      ? 'localEndpoint'\n      : 'remoteEndpoint';\n  return span.serviceName !== 'unknown'\n    ? {\n        [key]: {\n          serviceName: span.serviceName,\n          ipv4: span.serviceTags.find((t: TraceKeyValuePair) => t.key === 'ipv4')?.value,\n          ipv6: span.serviceTags.find((t: TraceKeyValuePair) => t.key === 'ipv6')?.value,\n          port: span.serviceTags.find((t: TraceKeyValuePair) => t.key === 'port')?.value,\n        },\n      }\n    : undefined;\n};\n"],"mappings":"AAAA,SAASA,QAAT,QAAyB,QAAzB;AAEA,SAAoBC,SAApB,EAA+BC,gBAA/B,QAAkG,eAAlG;;AAIA;AACA;AACA;AACA,OAAO,SAASC,iBAAT,CAA2BC,MAA3B,EAA4D;EACjE,MAAMC,QAAQ,GAAGD,MAAM,CAACE,GAAP,CAAWC,aAAX,CAAjB;EACA,MAAMC,KAAK,GAAG,IAAIN,gBAAJ,CAAqB;IACjCO,MAAM,EAAE,CACN;MAAEC,IAAI,EAAE,SAAR;MAAmBC,IAAI,EAAEV,SAAS,CAACW;IAAnC,CADM,EAEN;MAAEF,IAAI,EAAE,QAAR;MAAkBC,IAAI,EAAEV,SAAS,CAACW;IAAlC,CAFM,EAGN;MAAEF,IAAI,EAAE,cAAR;MAAwBC,IAAI,EAAEV,SAAS,CAACW;IAAxC,CAHM,EAIN;MAAEF,IAAI,EAAE,eAAR;MAAyBC,IAAI,EAAEV,SAAS,CAACW;IAAzC,CAJM,EAKN;MAAEF,IAAI,EAAE,aAAR;MAAuBC,IAAI,EAAEV,SAAS,CAACW;IAAvC,CALM,EAMN;MAAEF,IAAI,EAAE,aAAR;MAAuBC,IAAI,EAAEV,SAAS,CAACY;IAAvC,CANM,EAON;MAAEH,IAAI,EAAE,WAAR;MAAqBC,IAAI,EAAEV,SAAS,CAACa;IAArC,CAPM,EAQN;MAAEJ,IAAI,EAAE,UAAR;MAAoBC,IAAI,EAAEV,SAAS,CAACa;IAApC,CARM,EASN;MAAEJ,IAAI,EAAE,MAAR;MAAgBC,IAAI,EAAEV,SAAS,CAACY;IAAhC,CATM,EAUN;MAAEH,IAAI,EAAE,MAAR;MAAgBC,IAAI,EAAEV,SAAS,CAACY;IAAhC,CAVM,CADyB;IAajCE,IAAI,EAAE;MACJC,0BAA0B,EAAE,OADxB;MAEJC,MAAM,EAAE;QACNC,WAAW,EAAE;MADP;IAFJ;EAb2B,CAArB,CAAd;;EAqBA,KAAK,MAAMC,IAAX,IAAmBd,QAAnB,EAA6B;IAC3BG,KAAK,CAACY,GAAN,CAAUD,IAAV;EACD;;EAED,OAAOX,KAAP;AACD;;AAED,SAASD,aAAT,CAAuBY,IAAvB,EAAuD;EAAA;;EACrD,MAAME,GAAG,GAAG;IACVC,OAAO,EAAEH,IAAI,CAACI,OADJ;IAEVC,MAAM,EAAEL,IAAI,CAACM,EAFH;IAGVC,YAAY,EAAEP,IAAI,CAACQ,QAHT;IAIVC,aAAa,EAAET,IAAI,CAACT,IAJV;IAKVmB,WAAW,EAAE,wBAAAV,IAAI,CAACW,aAAL,4EAAoBD,WAApB,8BAAmCV,IAAI,CAACY,cAAxC,yDAAmC,qBAAqBF,WAAxD,KAAuE,SAL1E;IAMVG,WAAW,EAAEA,WAAW,CAACb,IAAD,CANd;IAOVc,SAAS,EAAEd,IAAI,CAACe,SAAL,GAAiB,IAPlB;IAQVC,QAAQ,EAAEhB,IAAI,CAACgB,QAAL,GAAgB,IARhB;IASVC,IAAI,gDAAEjB,IAAI,CAACkB,WAAP,sDAAE,kBAAkB/B,GAAlB,CAAsBgC,mBAAtB,CAAF,yEAAgD,EAT1C;IAUVC,IAAI,EAAEC,MAAM,CAACC,IAAP,CAAYtB,IAAI,CAACoB,IAAL,IAAa,EAAzB,EAA6BG,MAA7B,CAAyD,CAACC,GAAD,EAAMC,GAAN,KAAc;MAC3E;MACA,IAAIA,GAAG,KAAK,OAAZ,EAAqB;QACnBD,GAAG,CAACE,IAAJ,CAAS;UACPD,GAAG,EAAE,OADE;UAEPE,KAAK,EAAE;QAFA,CAAT;QAKAH,GAAG,CAACE,IAAJ,CAAS;UACPD,GAAG,EAAE,YADE;UAEPE,KAAK,EAAE3B,IAAI,CAACoB,IAAL,CAAW,OAAX;QAFA,CAAT;QAIA,OAAOI,GAAP;MACD;;MACDA,GAAG,CAACE,IAAJ,CAAS;QAAED,GAAF;QAAOE,KAAK,EAAE3B,IAAI,CAACoB,IAAL,CAAWK,GAAX;MAAd,CAAT;MACA,OAAOD,GAAP;IACD,CAhBK,EAgBH,EAhBG;EAVI,CAAZ;;EA6BA,IAAIxB,IAAI,CAAC4B,IAAT,EAAe;IAAA;;IACb1B,GAAG,CAACkB,IAAJ,GAAW,CACT;MACEK,GAAG,EAAE,MADP;MAEEE,KAAK,EAAE3B,IAAI,CAAC4B;IAFd,CADS,EAKT,iBAAI1B,GAAG,CAACkB,IAAR,iDAAgB,EAAhB,CALS,CAAX;EAOD;;EAED,IAAIpB,IAAI,CAAC6B,MAAT,EAAiB;IAAA;;IACf3B,GAAG,CAACkB,IAAJ,GAAW,CACT;MACEK,GAAG,EAAE,QADP;MAEEE,KAAK,EAAE3B,IAAI,CAAC6B;IAFd,CADS,EAKT,kBAAI3B,GAAG,CAACkB,IAAR,mDAAgB,EAAhB,CALS,CAAX;EAOD;;EAED,OAAOlB,GAAP;AACD;AAED;AACA;AACA;AACA;;;AACA,SAASiB,mBAAT,CAA6BW,UAA7B,EAAqE;EACnE,OAAO;IACLf,SAAS,EAAEe,UAAU,CAACf,SADjB;IAELzB,MAAM,EAAE,CACN;MACEmC,GAAG,EAAE,YADP;MAEEE,KAAK,EAAEG,UAAU,CAACH;IAFpB,CADM;EAFH,CAAP;AASD;;AAED,SAASd,WAAT,CAAqBb,IAArB,EAA4D;EAC1D,MAAM+B,QAAQ,GAAG/B,IAAI,CAACW,aAAL,IAAsBX,IAAI,CAACY,cAA5C;;EACA,IAAI,CAACmB,QAAL,EAAe;IACb,OAAO,EAAP;EACD;;EACD,OAAO,CACLC,UAAU,CAAC,MAAD,EAASD,QAAQ,CAACE,IAAlB,CADL,EAELD,UAAU,CAAC,MAAD,EAASD,QAAQ,CAACG,IAAlB,CAFL,EAGLF,UAAU,CAAC,MAAD,EAASD,QAAQ,CAACI,IAAlB,CAHL,EAILH,UAAU,CAAC,cAAD,EAAiBhC,IAAI,CAACW,aAAL,GAAqB,OAArB,GAA+B,QAAhD,CAJL,EAKLyB,MALK,CAKEvD,QALF,CAAP;AAMD;;AAED,SAASmD,UAAT,CAAuBP,GAAvB,EAAoCE,KAApC,EAAgF;EAC9E,IAAI,CAACA,KAAL,EAAY;IACV,OAAOU,SAAP;EACD;;EACD,OAAO;IACLZ,GADK;IAELE;EAFK,CAAP;AAID;AAED;AACA;AACA;;;AACA,OAAO,MAAMW,iBAAiB,GAAIC,IAAD,IAA0C;EACzE,IAAIC,QAAsB,GAAG,EAA7B;;EAEA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,IAAI,CAACG,MAAzB,EAAiCD,CAAC,EAAlC,EAAsC;IAAA;;IACpC,MAAMzC,IAAI,GAAGuC,IAAI,CAACI,GAAL,CAASF,CAAT,CAAb;IACAD,QAAQ,CAACd,IAAT;MACEtB,OAAO,EAAEJ,IAAI,CAACG,OADhB;MAEEK,QAAQ,EAAER,IAAI,CAACO,YAFjB;MAGEhB,IAAI,EAAES,IAAI,CAACS,aAHb;MAIEH,EAAE,EAAEN,IAAI,CAACK,MAJX;MAKEU,SAAS,EAAEf,IAAI,CAACc,SAAL,GAAiB,IAL9B;MAMEE,QAAQ,EAAEhB,IAAI,CAACgB,QAAL,GAAgB;IAN5B,GAOK4B,WAAW,CAAC5C,IAAD,CAPhB;MAQEkB,WAAW,EAAElB,IAAI,CAACiB,IAAL,CAAUyB,MAAV,GACT1C,IAAI,CAACiB,IAAL,CAAU9B,GAAV,CAAe0D,CAAD,KAAkB;QAAE9B,SAAS,EAAE8B,CAAC,CAAC9B,SAAf;QAA0BY,KAAK,EAAEkB,CAAC,CAACvD,MAAF,CAAS,CAAT,EAAYqC;MAA7C,CAAlB,CAAd,CADS,GAETU,SAVN;MAWEjB,IAAI,EAAEpB,IAAI,CAACoB,IAAL,CAAUsB,MAAV,GACF1C,IAAI,CAACoB,IAAL,CACGgB,MADH,CACWU,CAAD,IAA0BA,CAAC,CAACrB,GAAF,KAAU,MAAV,IAAoBqB,CAAC,CAACrB,GAAF,KAAU,cAA9B,IAAgDqB,CAAC,CAACrB,GAAF,KAAU,QAD9F,EAEGF,MAFH,CAEU,CAACH,IAAD,EAAkC0B,CAAlC,KAA2D;QACjE,IAAIA,CAAC,CAACrB,GAAF,KAAU,OAAd,EAAuB;UACrB,yBACKL,IADL;YAEE,CAAC0B,CAAC,CAACrB,GAAH,GAASzB,IAAI,CAACoB,IAAL,CAAU2B,IAAV,CAAgBD,CAAD,IAA0BA,CAAC,CAACrB,GAAF,KAAU,YAAnD,EAAiEE,KAAjE,IAA0E;UAFrF;QAID;;QACD,yBAAYP,IAAZ;UAAkB,CAAC0B,CAAC,CAACrB,GAAH,GAASqB,CAAC,CAACnB;QAA7B;MACD,CAVH,EAUK,EAVL,CADE,GAYFU,SAvBN;MAwBET,IAAI,qBAAE5B,IAAI,CAACoB,IAAL,CAAU2B,IAAV,CAAgBD,CAAD,IAA0BA,CAAC,CAACrB,GAAF,KAAU,MAAnD,CAAF,oDAAE,gBAA4DE,KAxBpE;MAyBEE,MAAM,sBAAE7B,IAAI,CAACoB,IAAL,CAAU2B,IAAV,CAAgBD,CAAD,IAA0BA,CAAC,CAACrB,GAAF,KAAU,QAAnD,CAAF,qDAAE,iBAA8DE;IAzBxE;EA2BD;;EAED,OAAOa,QAAP;AACD,CAnCM,C,CAqCP;;AACA,MAAMI,WAAW,GAAI5C,IAAD,IAA8D;EAAA;;EAChF,MAAMyB,GAAG,GACP,0BAAAzB,IAAI,CAACa,WAAL,CAAiBkC,IAAjB,CAAuBD,CAAD,IAA0BA,CAAC,CAACrB,GAAF,KAAU,cAA1D,iFAA2EE,KAA3E,MAAqF,OAArF,GACI,eADJ,GAEI,gBAHN;EAIA,OAAO3B,IAAI,CAACU,WAAL,KAAqB,SAArB,GACH;IACE,CAACe,GAAD,GAAO;MACLf,WAAW,EAAEV,IAAI,CAACU,WADb;MAELuB,IAAI,4BAAEjC,IAAI,CAACa,WAAL,CAAiBkC,IAAjB,CAAuBD,CAAD,IAA0BA,CAAC,CAACrB,GAAF,KAAU,MAA1D,CAAF,2DAAE,uBAAmEE,KAFpE;MAGLO,IAAI,4BAAElC,IAAI,CAACa,WAAL,CAAiBkC,IAAjB,CAAuBD,CAAD,IAA0BA,CAAC,CAACrB,GAAF,KAAU,MAA1D,CAAF,2DAAE,uBAAmEE,KAHpE;MAILQ,IAAI,4BAAEnC,IAAI,CAACa,WAAL,CAAiBkC,IAAjB,CAAuBD,CAAD,IAA0BA,CAAC,CAACrB,GAAF,KAAU,MAA1D,CAAF,2DAAE,uBAAmEE;IAJpE;EADT,CADG,GASHU,SATJ;AAUD,CAfD"},"metadata":{},"sourceType":"module"}