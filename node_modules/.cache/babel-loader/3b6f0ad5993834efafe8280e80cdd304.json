{"ast":null,"code":"import { ensureTimeField, FieldType } from '@grafana/data';\nimport { GraphDrawStyle, GraphTransform, StackingMode } from '@grafana/schema';\nimport { attachDebugger } from '../../utils';\nimport { createLogger } from '../../utils/logger';\nimport { buildScaleKey } from '../GraphNG/utils';\nconst ALLOWED_FORMAT_STRINGS_REGEX = /\\b(YYYY|YY|MMMM|MMM|MM|M|DD|D|WWWW|WWW|HH|H|h|AA|aa|a|mm|m|ss|s|fff)\\b/g;\nexport function timeFormatToTemplate(f) {\n  return f.replace(ALLOWED_FORMAT_STRINGS_REGEX, match => `{${match}}`);\n}\n\nconst paddingSide = (u, side, sidesWithAxes) => {\n  let hasCrossAxis = side % 2 ? sidesWithAxes[0] || sidesWithAxes[2] : sidesWithAxes[1] || sidesWithAxes[3];\n  return sidesWithAxes[side] || !hasCrossAxis ? 0 : 8;\n};\n\nexport const DEFAULT_PLOT_CONFIG = {\n  focus: {\n    alpha: 1\n  },\n  cursor: {\n    focus: {\n      prox: 30\n    }\n  },\n  legend: {\n    show: false\n  },\n  padding: [paddingSide, paddingSide, paddingSide, paddingSide],\n  series: [],\n  hooks: {}\n};\n/** @internal */\n\n/** @internal */\nvar StackDirection; // generates bands between adjacent group series\n\n/** @internal */\n\n(function (StackDirection) {\n  StackDirection[StackDirection[\"Pos\"] = 1] = \"Pos\";\n  StackDirection[StackDirection[\"Neg\"] = -1] = \"Neg\";\n})(StackDirection || (StackDirection = {}));\n\nexport function getStackingBands(group) {\n  let bands = [];\n  let {\n    series,\n    dir\n  } = group;\n  let lastIdx = series.length - 1;\n  let rSeries = series.slice().reverse();\n  rSeries.forEach((si, i) => {\n    if (i !== lastIdx) {\n      let nextIdx = rSeries[i + 1];\n      bands.push({\n        series: [si, nextIdx],\n        // fill direction is inverted from stack direction\n        dir: -1 * dir\n      });\n    }\n  });\n  return bands;\n} // expects an AlignedFrame\n\n/** @internal */\n\nexport function getStackingGroups(frame) {\n  let groups = new Map();\n  frame.fields.forEach(({\n    config,\n    values\n  }, i) => {\n    var _custom$hideFrom;\n\n    // skip x or time field\n    if (i === 0) {\n      return;\n    }\n\n    let {\n      custom\n    } = config;\n\n    if (custom == null) {\n      return;\n    } // TODO: currently all AlignedFrame fields end up in uplot series & data, even custom.hideFrom?.viz\n    // ideally hideFrom.viz fields would be excluded so we can remove this\n\n\n    if ((_custom$hideFrom = custom.hideFrom) !== null && _custom$hideFrom !== void 0 && _custom$hideFrom.viz) {\n      return;\n    }\n\n    let {\n      stacking\n    } = custom;\n\n    if (stacking == null) {\n      return;\n    }\n\n    let {\n      mode: stackingMode,\n      group: stackingGroup\n    } = stacking; // not stacking\n\n    if (stackingMode === StackingMode.None) {\n      return;\n    } // will this be stacked up or down after any transforms applied\n\n\n    let vals = values.toArray();\n    let transform = custom.transform;\n    let firstValue = vals.find(v => v != null);\n    let stackDir = transform === GraphTransform.Constant ? firstValue >= 0 ? StackDirection.Pos : StackDirection.Neg : transform === GraphTransform.NegativeY ? firstValue >= 0 ? StackDirection.Neg : StackDirection.Pos : firstValue >= 0 ? StackDirection.Pos : StackDirection.Neg;\n    let drawStyle = custom.drawStyle;\n    let drawStyle2 = drawStyle === GraphDrawStyle.Bars ? custom.barAlignment : drawStyle === GraphDrawStyle.Line ? custom.lineInterpolation : null;\n    let stackKey = `${stackDir}|${stackingMode}|${stackingGroup}|${buildScaleKey(config)}|${drawStyle}|${drawStyle2}`;\n    let group = groups.get(stackKey);\n\n    if (group == null) {\n      group = {\n        series: [],\n        dir: stackDir\n      };\n      groups.set(stackKey, group);\n    }\n\n    group.series.push(i);\n  });\n  return [...groups.values()];\n}\n/** @internal */\n\nexport function preparePlotData2(frame, stackingGroups, onStackMeta) {\n  let data = Array(frame.fields.length);\n  let stacksQty = stackingGroups.length;\n  let dataLen = frame.length;\n  let zeroArr = stacksQty > 0 ? Array(dataLen).fill(0) : [];\n  let falseArr = stacksQty > 0 ? Array(dataLen).fill(false) : [];\n  let accums = Array.from({\n    length: stacksQty\n  }, () => zeroArr.slice());\n  let anyValsAtX = Array.from({\n    length: stacksQty\n  }, () => falseArr.slice()); // figure out at which time indices each stacking group has any values\n  // (needed to avoid absorbing initial accum 0s at unrelated joined timestamps)\n\n  stackingGroups.forEach((group, groupIdx) => {\n    let groupValsAtX = anyValsAtX[groupIdx];\n    group.series.forEach(seriesIdx => {\n      var _field$config$custom, _field$config$custom$;\n\n      let field = frame.fields[seriesIdx];\n\n      if ((_field$config$custom = field.config.custom) !== null && _field$config$custom !== void 0 && (_field$config$custom$ = _field$config$custom.hideFrom) !== null && _field$config$custom$ !== void 0 && _field$config$custom$.viz) {\n        return;\n      }\n\n      let vals = field.values.toArray();\n\n      for (let i = 0; i < dataLen; i++) {\n        if (vals[i] != null) {\n          groupValsAtX[i] = true;\n        }\n      }\n    });\n  });\n  frame.fields.forEach((field, i) => {\n    var _custom$hideFrom2, _custom$stacking;\n\n    let vals = field.values.toArray();\n\n    if (i === 0) {\n      if (field.type === FieldType.time) {\n        data[i] = ensureTimeField(field).values.toArray();\n      } else {\n        data[i] = vals;\n      }\n\n      return;\n    }\n\n    let {\n      custom\n    } = field.config;\n\n    if (!custom || (_custom$hideFrom2 = custom.hideFrom) !== null && _custom$hideFrom2 !== void 0 && _custom$hideFrom2.viz) {\n      data[i] = vals;\n      return;\n    } // apply transforms\n\n\n    if (custom.transform === GraphTransform.Constant) {\n      vals = Array(vals.length).fill(vals[0]);\n    } else {\n      vals = vals.slice();\n\n      if (custom.transform === GraphTransform.NegativeY) {\n        for (let i = 0; i < vals.length; i++) {\n          if (vals[i] != null) {\n            vals[i] *= -1;\n          }\n        }\n      }\n    }\n\n    let stackingMode = (_custom$stacking = custom.stacking) === null || _custom$stacking === void 0 ? void 0 : _custom$stacking.mode;\n\n    if (!stackingMode || stackingMode === StackingMode.None) {\n      data[i] = vals;\n    } else {\n      let stackIdx = stackingGroups.findIndex(group => group.series.indexOf(i) > -1);\n      let accum = accums[stackIdx];\n      let groupValsAtX = anyValsAtX[stackIdx];\n      let stacked = data[i] = Array(dataLen);\n\n      for (let i = 0; i < dataLen; i++) {\n        let v = vals[i];\n\n        if (v != null) {\n          stacked[i] = accum[i] += v;\n        } else {\n          stacked[i] = groupValsAtX[i] ? accum[i] : v;\n        }\n      }\n    }\n  });\n\n  if (onStackMeta) {\n    let accumsBySeriesIdx = data.map((vals, i) => {\n      let stackIdx = stackingGroups.findIndex(group => group.series.indexOf(i) > -1);\n      return stackIdx !== -1 ? accums[stackIdx] : vals;\n    });\n    onStackMeta({\n      totals: accumsBySeriesIdx\n    });\n  } // re-compute by percent\n\n\n  frame.fields.forEach((field, i) => {\n    var _field$config$custom2, _field$config$custom3, _field$config$custom4, _field$config$custom5;\n\n    if (i === 0 || (_field$config$custom2 = field.config.custom) !== null && _field$config$custom2 !== void 0 && (_field$config$custom3 = _field$config$custom2.hideFrom) !== null && _field$config$custom3 !== void 0 && _field$config$custom3.viz) {\n      return;\n    }\n\n    let stackingMode = (_field$config$custom4 = field.config.custom) === null || _field$config$custom4 === void 0 ? void 0 : (_field$config$custom5 = _field$config$custom4.stacking) === null || _field$config$custom5 === void 0 ? void 0 : _field$config$custom5.mode;\n\n    if (stackingMode === StackingMode.Percent) {\n      let stackIdx = stackingGroups.findIndex(group => group.series.indexOf(i) > -1);\n      let accum = accums[stackIdx];\n      let group = stackingGroups[stackIdx];\n      let stacked = data[i];\n\n      for (let i = 0; i < dataLen; i++) {\n        let v = stacked[i];\n\n        if (v != null) {\n          // v / accum will always be pos, so properly (re)sign by group stacking dir\n          stacked[i] = group.dir * (v / accum[i]);\n        }\n      }\n    }\n  });\n  return data;\n}\n/**\n * Finds y axis midpoint for point at given idx (css pixels relative to uPlot canvas)\n * @internal\n **/\n\nexport function findMidPointYPosition(u, idx) {\n  let y;\n  let sMaxIdx = 1;\n  let sMinIdx = 1; // assume min/max being values of 1st series\n\n  let max = u.data[1][idx];\n  let min = u.data[1][idx]; // find min max values AND ids of the corresponding series to get the scales\n\n  for (let i = 1; i < u.data.length; i++) {\n    const sData = u.data[i];\n    const sVal = sData[idx];\n\n    if (sVal != null) {\n      if (max == null) {\n        max = sVal;\n      } else {\n        if (sVal > max) {\n          max = u.data[i][idx];\n          sMaxIdx = i;\n        }\n      }\n\n      if (min == null) {\n        min = sVal;\n      } else {\n        if (sVal < min) {\n          min = u.data[i][idx];\n          sMinIdx = i;\n        }\n      }\n    }\n  }\n\n  if (min == null && max == null) {\n    // no tooltip to show\n    y = undefined;\n  } else if (min != null && max != null) {\n    // find median position\n    y = (u.valToPos(min, u.series[sMinIdx].scale) + u.valToPos(max, u.series[sMaxIdx].scale)) / 2;\n  } else {\n    // snap tooltip to min OR max point, one of those is not null :)\n    y = u.valToPos(min || max, u.series[sMaxIdx || sMinIdx].scale);\n  } // if y is out of canvas bounds, snap it to the bottom\n\n\n  if (y !== undefined && y < 0) {\n    y = u.bbox.height / devicePixelRatio;\n  }\n\n  return y;\n} // Dev helpers\n\n/** @internal */\n\nexport const pluginLogger = createLogger('uPlot');\nexport const pluginLog = pluginLogger.logger; // pluginLogger.enable();\n\nattachDebugger('graphng', undefined, pluginLogger);","map":{"version":3,"names":["ensureTimeField","FieldType","GraphDrawStyle","GraphTransform","StackingMode","attachDebugger","createLogger","buildScaleKey","ALLOWED_FORMAT_STRINGS_REGEX","timeFormatToTemplate","f","replace","match","paddingSide","u","side","sidesWithAxes","hasCrossAxis","DEFAULT_PLOT_CONFIG","focus","alpha","cursor","prox","legend","show","padding","series","hooks","StackDirection","getStackingBands","group","bands","dir","lastIdx","length","rSeries","slice","reverse","forEach","si","i","nextIdx","push","getStackingGroups","frame","groups","Map","fields","config","values","custom","hideFrom","viz","stacking","mode","stackingMode","stackingGroup","None","vals","toArray","transform","firstValue","find","v","stackDir","Constant","Pos","Neg","NegativeY","drawStyle","drawStyle2","Bars","barAlignment","Line","lineInterpolation","stackKey","get","set","preparePlotData2","stackingGroups","onStackMeta","data","Array","stacksQty","dataLen","zeroArr","fill","falseArr","accums","from","anyValsAtX","groupIdx","groupValsAtX","seriesIdx","field","type","time","stackIdx","findIndex","indexOf","accum","stacked","accumsBySeriesIdx","map","totals","Percent","findMidPointYPosition","idx","y","sMaxIdx","sMinIdx","max","min","sData","sVal","undefined","valToPos","scale","bbox","height","devicePixelRatio","pluginLogger","pluginLog","logger"],"sources":["/home/soula/grafana/packages/grafana-ui/src/components/uPlot/utils.ts"],"sourcesContent":["import uPlot, { AlignedData, Options, PaddingSide } from 'uplot';\n\nimport { DataFrame, ensureTimeField, FieldType } from '@grafana/data';\nimport { BarAlignment, GraphDrawStyle, GraphTransform, LineInterpolation, StackingMode } from '@grafana/schema';\n\nimport { attachDebugger } from '../../utils';\nimport { createLogger } from '../../utils/logger';\nimport { buildScaleKey } from '../GraphNG/utils';\n\nconst ALLOWED_FORMAT_STRINGS_REGEX = /\\b(YYYY|YY|MMMM|MMM|MM|M|DD|D|WWWW|WWW|HH|H|h|AA|aa|a|mm|m|ss|s|fff)\\b/g;\n\nexport function timeFormatToTemplate(f: string) {\n  return f.replace(ALLOWED_FORMAT_STRINGS_REGEX, (match) => `{${match}}`);\n}\n\nconst paddingSide: PaddingSide = (u, side, sidesWithAxes) => {\n  let hasCrossAxis = side % 2 ? sidesWithAxes[0] || sidesWithAxes[2] : sidesWithAxes[1] || sidesWithAxes[3];\n\n  return sidesWithAxes[side] || !hasCrossAxis ? 0 : 8;\n};\n\nexport const DEFAULT_PLOT_CONFIG: Partial<Options> = {\n  focus: {\n    alpha: 1,\n  },\n  cursor: {\n    focus: {\n      prox: 30,\n    },\n  },\n  legend: {\n    show: false,\n  },\n  padding: [paddingSide, paddingSide, paddingSide, paddingSide],\n  series: [],\n  hooks: {},\n};\n\n/** @internal */\ninterface StackMeta {\n  totals: AlignedData;\n}\n\n/** @internal */\nexport interface StackingGroup {\n  series: number[];\n  dir: StackDirection;\n}\n\n/** @internal */\nconst enum StackDirection {\n  Pos = 1,\n  Neg = -1,\n}\n\n// generates bands between adjacent group series\n/** @internal */\nexport function getStackingBands(group: StackingGroup) {\n  let bands: uPlot.Band[] = [];\n  let { series, dir } = group;\n  let lastIdx = series.length - 1;\n\n  let rSeries = series.slice().reverse();\n\n  rSeries.forEach((si, i) => {\n    if (i !== lastIdx) {\n      let nextIdx = rSeries[i + 1];\n      bands.push({\n        series: [si, nextIdx],\n        // fill direction is inverted from stack direction\n        dir: (-1 * dir) as 1 | -1,\n      });\n    }\n  });\n\n  return bands;\n}\n\n// expects an AlignedFrame\n/** @internal */\nexport function getStackingGroups(frame: DataFrame) {\n  let groups: Map<string, StackingGroup> = new Map();\n\n  frame.fields.forEach(({ config, values }, i) => {\n    // skip x or time field\n    if (i === 0) {\n      return;\n    }\n\n    let { custom } = config;\n\n    if (custom == null) {\n      return;\n    }\n\n    // TODO: currently all AlignedFrame fields end up in uplot series & data, even custom.hideFrom?.viz\n    // ideally hideFrom.viz fields would be excluded so we can remove this\n    if (custom.hideFrom?.viz) {\n      return;\n    }\n\n    let { stacking } = custom;\n\n    if (stacking == null) {\n      return;\n    }\n\n    let { mode: stackingMode, group: stackingGroup } = stacking;\n\n    // not stacking\n    if (stackingMode === StackingMode.None) {\n      return;\n    }\n\n    // will this be stacked up or down after any transforms applied\n    let vals = values.toArray();\n    let transform = custom.transform;\n    let firstValue = vals.find((v) => v != null);\n    let stackDir =\n      transform === GraphTransform.Constant\n        ? firstValue >= 0\n          ? StackDirection.Pos\n          : StackDirection.Neg\n        : transform === GraphTransform.NegativeY\n        ? firstValue >= 0\n          ? StackDirection.Neg\n          : StackDirection.Pos\n        : firstValue >= 0\n        ? StackDirection.Pos\n        : StackDirection.Neg;\n\n    let drawStyle = custom.drawStyle as GraphDrawStyle;\n    let drawStyle2 =\n      drawStyle === GraphDrawStyle.Bars\n        ? (custom.barAlignment as BarAlignment)\n        : drawStyle === GraphDrawStyle.Line\n        ? (custom.lineInterpolation as LineInterpolation)\n        : null;\n\n    let stackKey = `${stackDir}|${stackingMode}|${stackingGroup}|${buildScaleKey(config)}|${drawStyle}|${drawStyle2}`;\n\n    let group = groups.get(stackKey);\n\n    if (group == null) {\n      group = {\n        series: [],\n        dir: stackDir,\n      };\n\n      groups.set(stackKey, group);\n    }\n\n    group.series.push(i);\n  });\n\n  return [...groups.values()];\n}\n\n/** @internal */\nexport function preparePlotData2(\n  frame: DataFrame,\n  stackingGroups: StackingGroup[],\n  onStackMeta?: (meta: StackMeta) => void\n) {\n  let data = Array(frame.fields.length) as AlignedData;\n\n  let stacksQty = stackingGroups.length;\n\n  let dataLen = frame.length;\n  let zeroArr = stacksQty > 0 ? Array(dataLen).fill(0) : [];\n  let falseArr = stacksQty > 0 ? Array(dataLen).fill(false) : [];\n  let accums = Array.from({ length: stacksQty }, () => zeroArr.slice());\n\n  let anyValsAtX = Array.from({ length: stacksQty }, () => falseArr.slice());\n\n  // figure out at which time indices each stacking group has any values\n  // (needed to avoid absorbing initial accum 0s at unrelated joined timestamps)\n  stackingGroups.forEach((group, groupIdx) => {\n    let groupValsAtX = anyValsAtX[groupIdx];\n\n    group.series.forEach((seriesIdx) => {\n      let field = frame.fields[seriesIdx];\n\n      if (field.config.custom?.hideFrom?.viz) {\n        return;\n      }\n\n      let vals = field.values.toArray();\n\n      for (let i = 0; i < dataLen; i++) {\n        if (vals[i] != null) {\n          groupValsAtX[i] = true;\n        }\n      }\n    });\n  });\n\n  frame.fields.forEach((field, i) => {\n    let vals = field.values.toArray();\n\n    if (i === 0) {\n      if (field.type === FieldType.time) {\n        data[i] = ensureTimeField(field).values.toArray();\n      } else {\n        data[i] = vals;\n      }\n      return;\n    }\n\n    let { custom } = field.config;\n\n    if (!custom || custom.hideFrom?.viz) {\n      data[i] = vals;\n      return;\n    }\n\n    // apply transforms\n    if (custom.transform === GraphTransform.Constant) {\n      vals = Array(vals.length).fill(vals[0]);\n    } else {\n      vals = vals.slice();\n\n      if (custom.transform === GraphTransform.NegativeY) {\n        for (let i = 0; i < vals.length; i++) {\n          if (vals[i] != null) {\n            vals[i] *= -1;\n          }\n        }\n      }\n    }\n\n    let stackingMode = custom.stacking?.mode;\n\n    if (!stackingMode || stackingMode === StackingMode.None) {\n      data[i] = vals;\n    } else {\n      let stackIdx = stackingGroups.findIndex((group) => group.series.indexOf(i) > -1);\n\n      let accum = accums[stackIdx];\n      let groupValsAtX = anyValsAtX[stackIdx];\n      let stacked = (data[i] = Array(dataLen));\n\n      for (let i = 0; i < dataLen; i++) {\n        let v = vals[i];\n\n        if (v != null) {\n          stacked[i] = accum[i] += v;\n        } else {\n          stacked[i] = groupValsAtX[i] ? accum[i] : v;\n        }\n      }\n    }\n  });\n\n  if (onStackMeta) {\n    let accumsBySeriesIdx = data.map((vals, i) => {\n      let stackIdx = stackingGroups.findIndex((group) => group.series.indexOf(i) > -1);\n      return stackIdx !== -1 ? accums[stackIdx] : vals;\n    });\n\n    onStackMeta({\n      totals: accumsBySeriesIdx as AlignedData,\n    });\n  }\n\n  // re-compute by percent\n  frame.fields.forEach((field, i) => {\n    if (i === 0 || field.config.custom?.hideFrom?.viz) {\n      return;\n    }\n\n    let stackingMode = field.config.custom?.stacking?.mode;\n\n    if (stackingMode === StackingMode.Percent) {\n      let stackIdx = stackingGroups.findIndex((group) => group.series.indexOf(i) > -1);\n      let accum = accums[stackIdx];\n      let group = stackingGroups[stackIdx];\n\n      let stacked = data[i];\n\n      for (let i = 0; i < dataLen; i++) {\n        let v = stacked[i];\n\n        if (v != null) {\n          // v / accum will always be pos, so properly (re)sign by group stacking dir\n          stacked[i] = group.dir * (v / accum[i]);\n        }\n      }\n    }\n  });\n\n  return data;\n}\n\n/**\n * Finds y axis midpoint for point at given idx (css pixels relative to uPlot canvas)\n * @internal\n **/\n\nexport function findMidPointYPosition(u: uPlot, idx: number) {\n  let y;\n  let sMaxIdx = 1;\n  let sMinIdx = 1;\n  // assume min/max being values of 1st series\n  let max = u.data[1][idx];\n  let min = u.data[1][idx];\n\n  // find min max values AND ids of the corresponding series to get the scales\n  for (let i = 1; i < u.data.length; i++) {\n    const sData = u.data[i];\n    const sVal = sData[idx];\n    if (sVal != null) {\n      if (max == null) {\n        max = sVal;\n      } else {\n        if (sVal > max) {\n          max = u.data[i][idx];\n          sMaxIdx = i;\n        }\n      }\n      if (min == null) {\n        min = sVal;\n      } else {\n        if (sVal < min) {\n          min = u.data[i][idx];\n          sMinIdx = i;\n        }\n      }\n    }\n  }\n\n  if (min == null && max == null) {\n    // no tooltip to show\n    y = undefined;\n  } else if (min != null && max != null) {\n    // find median position\n    y = (u.valToPos(min, u.series[sMinIdx].scale!) + u.valToPos(max, u.series[sMaxIdx].scale!)) / 2;\n  } else {\n    // snap tooltip to min OR max point, one of those is not null :)\n    y = u.valToPos((min || max)!, u.series[(sMaxIdx || sMinIdx)!].scale!);\n  }\n\n  // if y is out of canvas bounds, snap it to the bottom\n  if (y !== undefined && y < 0) {\n    y = u.bbox.height / devicePixelRatio;\n  }\n\n  return y;\n}\n\n// Dev helpers\n\n/** @internal */\nexport const pluginLogger = createLogger('uPlot');\nexport const pluginLog = pluginLogger.logger;\n// pluginLogger.enable();\nattachDebugger('graphng', undefined, pluginLogger);\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}