{"ast":null,"code":"import { isKeyHotkey } from 'is-hotkey';\nimport { Range as SlateRange } from 'slate';\nconst isIndentLeftHotkey = isKeyHotkey('mod+[');\nconst isShiftTabHotkey = isKeyHotkey('shift+tab');\nconst isIndentRightHotkey = isKeyHotkey('mod+]');\nconst SLATE_TAB = '  ';\n\nconst handleTabKey = (event, editor, next) => {\n  const {\n    startBlock,\n    endBlock,\n    selection: {\n      start: {\n        offset: startOffset,\n        key: startKey\n      },\n      end: {\n        offset: endOffset,\n        key: endKey\n      }\n    }\n  } = editor.value;\n  const first = startBlock.getFirstText();\n  const startBlockIsSelected = first && startOffset === 0 && startKey === first.key && endOffset === first.text.length && endKey === first.key;\n\n  if (startBlockIsSelected || !startBlock.equals(endBlock)) {\n    handleIndent(editor, 'right');\n  } else {\n    editor.insertText(SLATE_TAB);\n  }\n};\n\nconst handleIndent = (editor, indentDirection) => {\n  const curSelection = editor.value.selection;\n  const selectedBlocks = editor.value.document.getLeafBlocksAtRange(curSelection).toArray();\n\n  if (indentDirection === 'left') {\n    for (const block of selectedBlocks) {\n      const blockWhitespace = block.text.length - block.text.trimLeft().length;\n      const textKey = block.getFirstText().key;\n      const rangeProperties = {\n        anchor: {\n          key: textKey,\n          offset: blockWhitespace,\n          path: []\n        },\n        focus: {\n          key: textKey,\n          offset: blockWhitespace,\n          path: []\n        }\n      };\n      editor.deleteBackwardAtRange(SlateRange.create(rangeProperties), Math.min(SLATE_TAB.length, blockWhitespace));\n    }\n  } else {\n    const {\n      startText\n    } = editor.value;\n    const textBeforeCaret = startText.text.slice(0, curSelection.start.offset);\n    const isWhiteSpace = /^\\s*$/.test(textBeforeCaret);\n\n    for (const block of selectedBlocks) {\n      editor.insertTextByKey(block.getFirstText().key, 0, SLATE_TAB);\n    }\n\n    if (isWhiteSpace) {\n      editor.moveStartBackward(SLATE_TAB.length);\n    }\n  }\n}; // Clears the rest of the line after the caret\n\n\nexport function IndentationPlugin() {\n  return {\n    onKeyDown(event, editor, next) {\n      const keyEvent = event;\n\n      if (isIndentLeftHotkey(keyEvent) || isShiftTabHotkey(keyEvent)) {\n        keyEvent.preventDefault();\n        handleIndent(editor, 'left');\n      } else if (isIndentRightHotkey(keyEvent)) {\n        keyEvent.preventDefault();\n        handleIndent(editor, 'right');\n      } else if (keyEvent.key === 'Tab') {\n        keyEvent.preventDefault();\n        handleTabKey(keyEvent, editor, next);\n      } else {\n        return next();\n      }\n\n      return true;\n    }\n\n  };\n}","map":{"version":3,"names":["isKeyHotkey","Range","SlateRange","isIndentLeftHotkey","isShiftTabHotkey","isIndentRightHotkey","SLATE_TAB","handleTabKey","event","editor","next","startBlock","endBlock","selection","start","offset","startOffset","key","startKey","end","endOffset","endKey","value","first","getFirstText","startBlockIsSelected","text","length","equals","handleIndent","insertText","indentDirection","curSelection","selectedBlocks","document","getLeafBlocksAtRange","toArray","block","blockWhitespace","trimLeft","textKey","rangeProperties","anchor","path","focus","deleteBackwardAtRange","create","Math","min","startText","textBeforeCaret","slice","isWhiteSpace","test","insertTextByKey","moveStartBackward","IndentationPlugin","onKeyDown","keyEvent","preventDefault"],"sources":["/home/soula/grafana/packages/grafana-ui/src/slate-plugins/indentation.ts"],"sourcesContent":["import { isKeyHotkey } from 'is-hotkey';\nimport { RangeJSON, Range as SlateRange, Editor as CoreEditor } from 'slate';\n\nimport { Plugin } from '@grafana/slate-react';\n\nconst isIndentLeftHotkey = isKeyHotkey('mod+[');\nconst isShiftTabHotkey = isKeyHotkey('shift+tab');\nconst isIndentRightHotkey = isKeyHotkey('mod+]');\n\nconst SLATE_TAB = '  ';\n\nconst handleTabKey = (event: KeyboardEvent, editor: CoreEditor, next: Function): void => {\n  const {\n    startBlock,\n    endBlock,\n    selection: {\n      start: { offset: startOffset, key: startKey },\n      end: { offset: endOffset, key: endKey },\n    },\n  } = editor.value;\n\n  const first = startBlock.getFirstText();\n\n  const startBlockIsSelected =\n    first && startOffset === 0 && startKey === first.key && endOffset === first.text.length && endKey === first.key;\n\n  if (startBlockIsSelected || !startBlock.equals(endBlock)) {\n    handleIndent(editor, 'right');\n  } else {\n    editor.insertText(SLATE_TAB);\n  }\n};\n\nconst handleIndent = (editor: CoreEditor, indentDirection: 'left' | 'right') => {\n  const curSelection = editor.value.selection;\n  const selectedBlocks = editor.value.document.getLeafBlocksAtRange(curSelection).toArray();\n\n  if (indentDirection === 'left') {\n    for (const block of selectedBlocks) {\n      const blockWhitespace = block.text.length - block.text.trimLeft().length;\n\n      const textKey = block.getFirstText()!.key;\n\n      const rangeProperties: RangeJSON = {\n        anchor: {\n          key: textKey,\n          offset: blockWhitespace,\n          path: [],\n        },\n        focus: {\n          key: textKey,\n          offset: blockWhitespace,\n          path: [],\n        },\n      };\n\n      editor.deleteBackwardAtRange(SlateRange.create(rangeProperties), Math.min(SLATE_TAB.length, blockWhitespace));\n    }\n  } else {\n    const { startText } = editor.value;\n    const textBeforeCaret = startText.text.slice(0, curSelection.start.offset);\n    const isWhiteSpace = /^\\s*$/.test(textBeforeCaret);\n\n    for (const block of selectedBlocks) {\n      editor.insertTextByKey(block.getFirstText()!.key, 0, SLATE_TAB);\n    }\n\n    if (isWhiteSpace) {\n      editor.moveStartBackward(SLATE_TAB.length);\n    }\n  }\n};\n\n// Clears the rest of the line after the caret\nexport function IndentationPlugin(): Plugin {\n  return {\n    onKeyDown(event: Event, editor: CoreEditor, next: Function) {\n      const keyEvent = event as KeyboardEvent;\n      if (isIndentLeftHotkey(keyEvent) || isShiftTabHotkey(keyEvent)) {\n        keyEvent.preventDefault();\n        handleIndent(editor, 'left');\n      } else if (isIndentRightHotkey(keyEvent)) {\n        keyEvent.preventDefault();\n        handleIndent(editor, 'right');\n      } else if (keyEvent.key === 'Tab') {\n        keyEvent.preventDefault();\n        handleTabKey(keyEvent, editor, next);\n      } else {\n        return next();\n      }\n\n      return true;\n    },\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}