{"ast":null,"code":"import { isNumber } from 'lodash';\nimport { DashboardCursorSync, DataHoverClearEvent, DataHoverEvent, FieldType, formattedValueToString, getFieldColorModeForField, getFieldSeriesColor, getFieldDisplayName, getDisplayProcessor, FieldColorModeId } from '@grafana/data';\nimport { AxisPlacement, GraphDrawStyle, GraphTresholdsStyleMode, VisibilityMode, ScaleDirection, ScaleOrientation, StackingMode } from '@grafana/schema';\nimport { buildScaleKey } from '../GraphNG/utils';\nimport { UPlotConfigBuilder } from '../uPlot/config/UPlotConfigBuilder';\nimport { getStackingGroups, preparePlotData2 } from '../uPlot/utils';\n\nconst defaultFormatter = v => v == null ? '-' : v.toFixed(1);\n\nconst defaultConfig = {\n  drawStyle: GraphDrawStyle.Line,\n  showPoints: VisibilityMode.Auto,\n  axisPlacement: AxisPlacement.Auto\n};\nexport const preparePlotConfigBuilder = ({\n  frame,\n  theme,\n  timeZone,\n  getTimeRange,\n  eventBus,\n  sync,\n  allFrames,\n  renderers,\n  tweakScale = opts => opts,\n  tweakAxis = opts => opts\n}) => {\n  var _xField$config$custom, _xField$config$custom2, _renderers$flatMap;\n\n  const builder = new UPlotConfigBuilder(timeZone);\n  let alignedFrame;\n  builder.setPrepData(frames => {\n    // cache alignedFrame\n    alignedFrame = frames[0];\n    return preparePlotData2(frames[0], builder.getStackingGroups());\n  }); // X is the first field in the aligned frame\n\n  const xField = frame.fields[0];\n\n  if (!xField) {\n    return builder; // empty frame with no options\n  }\n\n  let seriesIndex = 0;\n  const xScaleKey = 'x';\n  let xScaleUnit = '_x';\n  let yScaleKey = '';\n  const xFieldAxisPlacement = ((_xField$config$custom = xField.config.custom) === null || _xField$config$custom === void 0 ? void 0 : _xField$config$custom.axisPlacement) !== AxisPlacement.Hidden ? AxisPlacement.Bottom : AxisPlacement.Hidden;\n  const xFieldAxisShow = ((_xField$config$custom2 = xField.config.custom) === null || _xField$config$custom2 === void 0 ? void 0 : _xField$config$custom2.axisPlacement) !== AxisPlacement.Hidden;\n\n  if (xField.type === FieldType.time) {\n    var _xField$config$custom3, _xField$config$custom4;\n\n    xScaleUnit = 'time';\n    builder.addScale({\n      scaleKey: xScaleKey,\n      orientation: ScaleOrientation.Horizontal,\n      direction: ScaleDirection.Right,\n      isTime: true,\n      range: () => {\n        const r = getTimeRange();\n        return [r.from.valueOf(), r.to.valueOf()];\n      }\n    });\n    builder.addAxis({\n      scaleKey: xScaleKey,\n      isTime: true,\n      placement: xFieldAxisPlacement,\n      show: xFieldAxisShow,\n      label: (_xField$config$custom3 = xField.config.custom) === null || _xField$config$custom3 === void 0 ? void 0 : _xField$config$custom3.axisLabel,\n      timeZone,\n      theme,\n      grid: {\n        show: (_xField$config$custom4 = xField.config.custom) === null || _xField$config$custom4 === void 0 ? void 0 : _xField$config$custom4.axisGridShow\n      }\n    });\n  } else {\n    var _xField$config$custom5, _xField$config$custom6;\n\n    // Not time!\n    if (xField.config.unit) {\n      xScaleUnit = xField.config.unit;\n    }\n\n    builder.addScale({\n      scaleKey: xScaleKey,\n      orientation: ScaleOrientation.Horizontal,\n      direction: ScaleDirection.Right\n    });\n    builder.addAxis({\n      scaleKey: xScaleKey,\n      placement: xFieldAxisPlacement,\n      show: xFieldAxisShow,\n      label: (_xField$config$custom5 = xField.config.custom) === null || _xField$config$custom5 === void 0 ? void 0 : _xField$config$custom5.axisLabel,\n      theme,\n      grid: {\n        show: (_xField$config$custom6 = xField.config.custom) === null || _xField$config$custom6 === void 0 ? void 0 : _xField$config$custom6.axisGridShow\n      }\n    });\n  }\n\n  let customRenderedFields = (_renderers$flatMap = renderers === null || renderers === void 0 ? void 0 : renderers.flatMap(r => Object.values(r.fieldMap).filter(name => r.indicesOnly.indexOf(name) === -1))) !== null && _renderers$flatMap !== void 0 ? _renderers$flatMap : [];\n  let indexByName;\n\n  for (let i = 1; i < frame.fields.length; i++) {\n    var _field$display, _field$config$custom, _field$config$custom$, _customConfig$scaleDi, _customConfig$scaleDi2, _field$state, _customConfig$lineCol, _customConfig$hideFro, _field$state2;\n\n    const field = frame.fields[i];\n    const config = Object.assign({}, field.config, {\n      custom: Object.assign({}, defaultConfig, field.config.custom)\n    });\n    const customConfig = config.custom;\n\n    if (field === xField || field.type !== FieldType.number) {\n      continue;\n    } // TODO: skip this for fields with custom renderers?\n\n\n    field.state.seriesIndex = seriesIndex++;\n    let fmt = (_field$display = field.display) !== null && _field$display !== void 0 ? _field$display : defaultFormatter;\n\n    if (((_field$config$custom = field.config.custom) === null || _field$config$custom === void 0 ? void 0 : (_field$config$custom$ = _field$config$custom.stacking) === null || _field$config$custom$ === void 0 ? void 0 : _field$config$custom$.mode) === StackingMode.Percent) {\n      fmt = getDisplayProcessor({\n        field: Object.assign({}, field, {\n          config: Object.assign({}, field.config, {\n            unit: 'percentunit'\n          })\n        }),\n        theme\n      });\n    }\n\n    const scaleKey = buildScaleKey(config);\n    const colorMode = getFieldColorModeForField(field);\n    const scaleColor = getFieldSeriesColor(field, theme);\n    const seriesColor = scaleColor.color; // The builder will manage unique scaleKeys and combine where appropriate\n\n    builder.addScale(tweakScale({\n      scaleKey,\n      orientation: ScaleOrientation.Vertical,\n      direction: ScaleDirection.Up,\n      distribution: (_customConfig$scaleDi = customConfig.scaleDistribution) === null || _customConfig$scaleDi === void 0 ? void 0 : _customConfig$scaleDi.type,\n      log: (_customConfig$scaleDi2 = customConfig.scaleDistribution) === null || _customConfig$scaleDi2 === void 0 ? void 0 : _customConfig$scaleDi2.log,\n      min: field.config.min,\n      max: field.config.max,\n      softMin: customConfig.axisSoftMin,\n      softMax: customConfig.axisSoftMax\n    }, field));\n\n    if (!yScaleKey) {\n      yScaleKey = scaleKey;\n    }\n\n    if (customConfig.axisPlacement !== AxisPlacement.Hidden) {\n      var _customConfig$axisPla;\n\n      builder.addAxis(tweakAxis({\n        scaleKey,\n        label: customConfig.axisLabel,\n        size: customConfig.axisWidth,\n        placement: (_customConfig$axisPla = customConfig.axisPlacement) !== null && _customConfig$axisPla !== void 0 ? _customConfig$axisPla : AxisPlacement.Auto,\n        formatValue: v => formattedValueToString(fmt(v)),\n        theme,\n        grid: {\n          show: customConfig.axisGridShow\n        }\n      }, field));\n    }\n\n    const showPoints = customConfig.drawStyle === GraphDrawStyle.Points ? VisibilityMode.Always : customConfig.showPoints;\n\n    let pointsFilter = () => null;\n\n    if (customConfig.spanNulls !== true) {\n      pointsFilter = (u, seriesIdx, show, gaps) => {\n        let filtered = [];\n        let series = u.series[seriesIdx];\n\n        if (!show && gaps && gaps.length) {\n          const [firstIdx, lastIdx] = series.idxs;\n          const xData = u.data[0];\n          const yData = u.data[seriesIdx];\n          const firstPos = Math.round(u.valToPos(xData[firstIdx], 'x', true));\n          const lastPos = Math.round(u.valToPos(xData[lastIdx], 'x', true));\n\n          if (gaps[0][0] === firstPos) {\n            filtered.push(firstIdx);\n          } // show single points between consecutive gaps that share end/start\n\n\n          for (let i = 0; i < gaps.length; i++) {\n            let thisGap = gaps[i];\n            let nextGap = gaps[i + 1];\n\n            if (nextGap && thisGap[1] === nextGap[0]) {\n              // approx when data density is > 1pt/px, since gap start/end pixels are rounded\n              let approxIdx = u.posToIdx(thisGap[1], true);\n\n              if (yData[approxIdx] == null) {\n                // scan left/right alternating to find closest index with non-null value\n                for (let j = 1; j < 100; j++) {\n                  if (yData[approxIdx + j] != null) {\n                    approxIdx += j;\n                    break;\n                  }\n\n                  if (yData[approxIdx - j] != null) {\n                    approxIdx -= j;\n                    break;\n                  }\n                }\n              }\n\n              filtered.push(approxIdx);\n            }\n          }\n\n          if (gaps[gaps.length - 1][1] === lastPos) {\n            filtered.push(lastIdx);\n          }\n        }\n\n        return filtered.length ? filtered : null;\n      };\n    }\n\n    let {\n      fillOpacity\n    } = customConfig;\n    let pathBuilder = null;\n    let pointsBuilder = null;\n\n    if ((_field$state = field.state) !== null && _field$state !== void 0 && _field$state.origin) {\n      if (!indexByName) {\n        indexByName = getNamesToFieldIndex(frame, allFrames);\n      }\n\n      const originFrame = allFrames[field.state.origin.frameIndex];\n      const originField = originFrame === null || originFrame === void 0 ? void 0 : originFrame.fields[field.state.origin.fieldIndex];\n      const dispName = getFieldDisplayName(originField !== null && originField !== void 0 ? originField : field, originFrame, allFrames); // disable default renderers\n\n      if (customRenderedFields.indexOf(dispName) >= 0) {\n        pathBuilder = () => null;\n\n        pointsBuilder = () => undefined;\n      }\n\n      if (customConfig.fillBelowTo) {\n        const t = indexByName.get(dispName);\n        const b = indexByName.get(customConfig.fillBelowTo);\n\n        if (isNumber(b) && isNumber(t)) {\n          builder.addBand({\n            series: [t, b],\n            fill: undefined // using null will have the band use fill options from `t`\n\n          });\n\n          if (!fillOpacity) {\n            fillOpacity = 35; // default from flot\n          }\n        } else {\n          fillOpacity = 0;\n        }\n      }\n    }\n\n    let dynamicSeriesColor = undefined;\n\n    if (colorMode.id === FieldColorModeId.Thresholds) {\n      dynamicSeriesColor = seriesIdx => getFieldSeriesColor(alignedFrame.fields[seriesIdx], theme).color;\n    }\n\n    builder.addSeries({\n      pathBuilder,\n      pointsBuilder,\n      scaleKey,\n      showPoints,\n      pointsFilter,\n      colorMode,\n      fillOpacity,\n      theme,\n      dynamicSeriesColor,\n      drawStyle: customConfig.drawStyle,\n      lineColor: (_customConfig$lineCol = customConfig.lineColor) !== null && _customConfig$lineCol !== void 0 ? _customConfig$lineCol : seriesColor,\n      lineWidth: customConfig.lineWidth,\n      lineInterpolation: customConfig.lineInterpolation,\n      lineStyle: customConfig.lineStyle,\n      barAlignment: customConfig.barAlignment,\n      barWidthFactor: customConfig.barWidthFactor,\n      barMaxWidth: customConfig.barMaxWidth,\n      pointSize: customConfig.pointSize,\n      spanNulls: customConfig.spanNulls || false,\n      show: !((_customConfig$hideFro = customConfig.hideFrom) !== null && _customConfig$hideFro !== void 0 && _customConfig$hideFro.viz),\n      gradientMode: customConfig.gradientMode,\n      thresholds: config.thresholds,\n      hardMin: field.config.min,\n      hardMax: field.config.max,\n      softMin: customConfig.axisSoftMin,\n      softMax: customConfig.axisSoftMax,\n      // The following properties are not used in the uPlot config, but are utilized as transport for legend config\n      dataFrameFieldIndex: (_field$state2 = field.state) === null || _field$state2 === void 0 ? void 0 : _field$state2.origin\n    }); // Render thresholds in graph\n\n    if (customConfig.thresholdsStyle && config.thresholds) {\n      var _customConfig$thresho;\n\n      const thresholdDisplay = (_customConfig$thresho = customConfig.thresholdsStyle.mode) !== null && _customConfig$thresho !== void 0 ? _customConfig$thresho : GraphTresholdsStyleMode.Off;\n\n      if (thresholdDisplay !== GraphTresholdsStyleMode.Off) {\n        builder.addThresholds({\n          config: customConfig.thresholdsStyle,\n          thresholds: config.thresholds,\n          scaleKey,\n          theme,\n          hardMin: field.config.min,\n          hardMax: field.config.max,\n          softMin: customConfig.axisSoftMin,\n          softMax: customConfig.axisSoftMax\n        });\n      }\n    }\n  }\n\n  let stackingGroups = getStackingGroups(frame);\n  builder.setStackingGroups(stackingGroups); // hook up custom/composite renderers\n\n  renderers === null || renderers === void 0 ? void 0 : renderers.forEach(r => {\n    if (!indexByName) {\n      indexByName = getNamesToFieldIndex(frame, allFrames);\n    }\n\n    let fieldIndices = {};\n\n    for (let key in r.fieldMap) {\n      let dispName = r.fieldMap[key];\n      fieldIndices[key] = indexByName.get(dispName);\n    }\n\n    r.init(builder, fieldIndices);\n  });\n  builder.scaleKeys = [xScaleKey, yScaleKey]; // if hovered value is null, how far we may scan left/right to hover nearest non-null\n\n  const hoverProximityPx = 15;\n  let cursor = {\n    // this scans left and right from cursor position to find nearest data index with value != null\n    // TODO: do we want to only scan past undefined values, but halt at explicit null values?\n    dataIdx: (self, seriesIdx, hoveredIdx, cursorXVal) => {\n      let seriesData = self.data[seriesIdx];\n\n      if (seriesData[hoveredIdx] == null) {\n        let nonNullLft = null,\n            nonNullRgt = null,\n            i;\n        i = hoveredIdx;\n\n        while (nonNullLft == null && i-- > 0) {\n          if (seriesData[i] != null) {\n            nonNullLft = i;\n          }\n        }\n\n        i = hoveredIdx;\n\n        while (nonNullRgt == null && i++ < seriesData.length) {\n          if (seriesData[i] != null) {\n            nonNullRgt = i;\n          }\n        }\n\n        let xVals = self.data[0];\n        let curPos = self.valToPos(cursorXVal, 'x');\n        let rgtPos = nonNullRgt == null ? Infinity : self.valToPos(xVals[nonNullRgt], 'x');\n        let lftPos = nonNullLft == null ? -Infinity : self.valToPos(xVals[nonNullLft], 'x');\n        let lftDelta = curPos - lftPos;\n        let rgtDelta = rgtPos - curPos;\n\n        if (lftDelta <= rgtDelta) {\n          if (lftDelta <= hoverProximityPx) {\n            hoveredIdx = nonNullLft;\n          }\n        } else {\n          if (rgtDelta <= hoverProximityPx) {\n            hoveredIdx = nonNullRgt;\n          }\n        }\n      }\n\n      return hoveredIdx;\n    }\n  };\n\n  if (sync && sync() !== DashboardCursorSync.Off) {\n    const payload = {\n      point: {\n        [xScaleKey]: null,\n        [yScaleKey]: null\n      },\n      data: frame\n    };\n    const hoverEvent = new DataHoverEvent(payload);\n    cursor.sync = {\n      key: '__global_',\n      filters: {\n        pub: (type, src, x, y, w, h, dataIdx) => {\n          if (sync && sync() === DashboardCursorSync.Off) {\n            return false;\n          }\n\n          payload.rowIndex = dataIdx;\n\n          if (x < 0 && y < 0) {\n            payload.point[xScaleUnit] = null;\n            payload.point[yScaleKey] = null;\n            eventBus.publish(new DataHoverClearEvent());\n          } else {\n            // convert the points\n            payload.point[xScaleUnit] = src.posToVal(x, xScaleKey);\n            payload.point[yScaleKey] = src.posToVal(y, yScaleKey);\n            payload.point.panelRelY = y > 0 ? y / h : 1; // used by old graph panel to position tooltip\n\n            eventBus.publish(hoverEvent);\n            hoverEvent.payload.down = undefined;\n          }\n\n          return true;\n        }\n      },\n      scales: [xScaleKey, yScaleKey] // match: [() => true, (a, b) => a === b],\n\n    };\n  }\n\n  builder.setSync();\n  builder.setCursor(cursor);\n  return builder;\n};\nexport function getNamesToFieldIndex(frame, allFrames) {\n  const originNames = new Map();\n  frame.fields.forEach((field, i) => {\n    var _field$state3;\n\n    const origin = (_field$state3 = field.state) === null || _field$state3 === void 0 ? void 0 : _field$state3.origin;\n\n    if (origin) {\n      var _allFrames$origin$fra;\n\n      const origField = (_allFrames$origin$fra = allFrames[origin.frameIndex]) === null || _allFrames$origin$fra === void 0 ? void 0 : _allFrames$origin$fra.fields[origin.fieldIndex];\n\n      if (origField) {\n        originNames.set(getFieldDisplayName(origField, allFrames[origin.frameIndex], allFrames), i);\n      }\n    }\n  });\n  return originNames;\n}","map":{"version":3,"names":["isNumber","DashboardCursorSync","DataHoverClearEvent","DataHoverEvent","FieldType","formattedValueToString","getFieldColorModeForField","getFieldSeriesColor","getFieldDisplayName","getDisplayProcessor","FieldColorModeId","AxisPlacement","GraphDrawStyle","GraphTresholdsStyleMode","VisibilityMode","ScaleDirection","ScaleOrientation","StackingMode","buildScaleKey","UPlotConfigBuilder","getStackingGroups","preparePlotData2","defaultFormatter","v","toFixed","defaultConfig","drawStyle","Line","showPoints","Auto","axisPlacement","preparePlotConfigBuilder","frame","theme","timeZone","getTimeRange","eventBus","sync","allFrames","renderers","tweakScale","opts","tweakAxis","builder","alignedFrame","setPrepData","frames","xField","fields","seriesIndex","xScaleKey","xScaleUnit","yScaleKey","xFieldAxisPlacement","config","custom","Hidden","Bottom","xFieldAxisShow","type","time","addScale","scaleKey","orientation","Horizontal","direction","Right","isTime","range","r","from","valueOf","to","addAxis","placement","show","label","axisLabel","grid","axisGridShow","unit","customRenderedFields","flatMap","Object","values","fieldMap","filter","name","indicesOnly","indexOf","indexByName","i","length","field","customConfig","number","state","fmt","display","stacking","mode","Percent","colorMode","scaleColor","seriesColor","color","Vertical","Up","distribution","scaleDistribution","log","min","max","softMin","axisSoftMin","softMax","axisSoftMax","size","axisWidth","formatValue","Points","Always","pointsFilter","spanNulls","u","seriesIdx","gaps","filtered","series","firstIdx","lastIdx","idxs","xData","data","yData","firstPos","Math","round","valToPos","lastPos","push","thisGap","nextGap","approxIdx","posToIdx","j","fillOpacity","pathBuilder","pointsBuilder","origin","getNamesToFieldIndex","originFrame","frameIndex","originField","fieldIndex","dispName","undefined","fillBelowTo","t","get","b","addBand","fill","dynamicSeriesColor","id","Thresholds","addSeries","lineColor","lineWidth","lineInterpolation","lineStyle","barAlignment","barWidthFactor","barMaxWidth","pointSize","hideFrom","viz","gradientMode","thresholds","hardMin","hardMax","dataFrameFieldIndex","thresholdsStyle","thresholdDisplay","Off","addThresholds","stackingGroups","setStackingGroups","forEach","fieldIndices","key","init","scaleKeys","hoverProximityPx","cursor","dataIdx","self","hoveredIdx","cursorXVal","seriesData","nonNullLft","nonNullRgt","xVals","curPos","rgtPos","Infinity","lftPos","lftDelta","rgtDelta","payload","point","hoverEvent","filters","pub","src","x","y","w","h","rowIndex","publish","posToVal","panelRelY","down","scales","setSync","setCursor","originNames","Map","origField","set"],"sources":["/home/soula/grafana/packages/grafana-ui/src/components/TimeSeries/utils.ts"],"sourcesContent":["import { isNumber } from 'lodash';\nimport uPlot from 'uplot';\n\nimport {\n  DashboardCursorSync,\n  DataFrame,\n  DataHoverClearEvent,\n  DataHoverEvent,\n  DataHoverPayload,\n  FieldConfig,\n  FieldType,\n  formattedValueToString,\n  getFieldColorModeForField,\n  getFieldSeriesColor,\n  getFieldDisplayName,\n  getDisplayProcessor,\n  FieldColorModeId,\n} from '@grafana/data';\nimport {\n  AxisPlacement,\n  GraphDrawStyle,\n  GraphFieldConfig,\n  GraphTresholdsStyleMode,\n  VisibilityMode,\n  ScaleDirection,\n  ScaleOrientation,\n  StackingMode,\n} from '@grafana/schema';\n\nimport { buildScaleKey } from '../GraphNG/utils';\nimport { UPlotConfigBuilder, UPlotConfigPrepFn } from '../uPlot/config/UPlotConfigBuilder';\nimport { getStackingGroups, preparePlotData2 } from '../uPlot/utils';\n\nconst defaultFormatter = (v: any) => (v == null ? '-' : v.toFixed(1));\n\nconst defaultConfig: GraphFieldConfig = {\n  drawStyle: GraphDrawStyle.Line,\n  showPoints: VisibilityMode.Auto,\n  axisPlacement: AxisPlacement.Auto,\n};\n\nexport const preparePlotConfigBuilder: UPlotConfigPrepFn<{\n  sync?: () => DashboardCursorSync;\n}> = ({\n  frame,\n  theme,\n  timeZone,\n  getTimeRange,\n  eventBus,\n  sync,\n  allFrames,\n  renderers,\n  tweakScale = (opts) => opts,\n  tweakAxis = (opts) => opts,\n}) => {\n  const builder = new UPlotConfigBuilder(timeZone);\n\n  let alignedFrame: DataFrame;\n\n  builder.setPrepData((frames) => {\n    // cache alignedFrame\n    alignedFrame = frames[0];\n\n    return preparePlotData2(frames[0], builder.getStackingGroups());\n  });\n\n  // X is the first field in the aligned frame\n  const xField = frame.fields[0];\n  if (!xField) {\n    return builder; // empty frame with no options\n  }\n\n  let seriesIndex = 0;\n\n  const xScaleKey = 'x';\n  let xScaleUnit = '_x';\n  let yScaleKey = '';\n\n  const xFieldAxisPlacement =\n    xField.config.custom?.axisPlacement !== AxisPlacement.Hidden ? AxisPlacement.Bottom : AxisPlacement.Hidden;\n  const xFieldAxisShow = xField.config.custom?.axisPlacement !== AxisPlacement.Hidden;\n\n  if (xField.type === FieldType.time) {\n    xScaleUnit = 'time';\n    builder.addScale({\n      scaleKey: xScaleKey,\n      orientation: ScaleOrientation.Horizontal,\n      direction: ScaleDirection.Right,\n      isTime: true,\n      range: () => {\n        const r = getTimeRange();\n        return [r.from.valueOf(), r.to.valueOf()];\n      },\n    });\n\n    builder.addAxis({\n      scaleKey: xScaleKey,\n      isTime: true,\n      placement: xFieldAxisPlacement,\n      show: xFieldAxisShow,\n      label: xField.config.custom?.axisLabel,\n      timeZone,\n      theme,\n      grid: { show: xField.config.custom?.axisGridShow },\n    });\n  } else {\n    // Not time!\n    if (xField.config.unit) {\n      xScaleUnit = xField.config.unit;\n    }\n\n    builder.addScale({\n      scaleKey: xScaleKey,\n      orientation: ScaleOrientation.Horizontal,\n      direction: ScaleDirection.Right,\n    });\n\n    builder.addAxis({\n      scaleKey: xScaleKey,\n      placement: xFieldAxisPlacement,\n      show: xFieldAxisShow,\n      label: xField.config.custom?.axisLabel,\n      theme,\n      grid: { show: xField.config.custom?.axisGridShow },\n    });\n  }\n\n  let customRenderedFields =\n    renderers?.flatMap((r) => Object.values(r.fieldMap).filter((name) => r.indicesOnly.indexOf(name) === -1)) ?? [];\n\n  let indexByName: Map<string, number> | undefined;\n\n  for (let i = 1; i < frame.fields.length; i++) {\n    const field = frame.fields[i];\n\n    const config = {\n      ...field.config,\n      custom: {\n        ...defaultConfig,\n        ...field.config.custom,\n      },\n    } as FieldConfig<GraphFieldConfig>;\n\n    const customConfig: GraphFieldConfig = config.custom!;\n\n    if (field === xField || field.type !== FieldType.number) {\n      continue;\n    }\n\n    // TODO: skip this for fields with custom renderers?\n    field.state!.seriesIndex = seriesIndex++;\n\n    let fmt = field.display ?? defaultFormatter;\n    if (field.config.custom?.stacking?.mode === StackingMode.Percent) {\n      fmt = getDisplayProcessor({\n        field: {\n          ...field,\n          config: {\n            ...field.config,\n            unit: 'percentunit',\n          },\n        },\n        theme,\n      });\n    }\n    const scaleKey = buildScaleKey(config);\n    const colorMode = getFieldColorModeForField(field);\n    const scaleColor = getFieldSeriesColor(field, theme);\n    const seriesColor = scaleColor.color;\n\n    // The builder will manage unique scaleKeys and combine where appropriate\n    builder.addScale(\n      tweakScale(\n        {\n          scaleKey,\n          orientation: ScaleOrientation.Vertical,\n          direction: ScaleDirection.Up,\n          distribution: customConfig.scaleDistribution?.type,\n          log: customConfig.scaleDistribution?.log,\n          min: field.config.min,\n          max: field.config.max,\n          softMin: customConfig.axisSoftMin,\n          softMax: customConfig.axisSoftMax,\n        },\n        field\n      )\n    );\n\n    if (!yScaleKey) {\n      yScaleKey = scaleKey;\n    }\n\n    if (customConfig.axisPlacement !== AxisPlacement.Hidden) {\n      builder.addAxis(\n        tweakAxis(\n          {\n            scaleKey,\n            label: customConfig.axisLabel,\n            size: customConfig.axisWidth,\n            placement: customConfig.axisPlacement ?? AxisPlacement.Auto,\n            formatValue: (v) => formattedValueToString(fmt(v)),\n            theme,\n            grid: { show: customConfig.axisGridShow },\n          },\n          field\n        )\n      );\n    }\n\n    const showPoints =\n      customConfig.drawStyle === GraphDrawStyle.Points ? VisibilityMode.Always : customConfig.showPoints;\n\n    let pointsFilter: uPlot.Series.Points.Filter = () => null;\n\n    if (customConfig.spanNulls !== true) {\n      pointsFilter = (u, seriesIdx, show, gaps) => {\n        let filtered = [];\n\n        let series = u.series[seriesIdx];\n\n        if (!show && gaps && gaps.length) {\n          const [firstIdx, lastIdx] = series.idxs!;\n          const xData = u.data[0];\n          const yData = u.data[seriesIdx];\n          const firstPos = Math.round(u.valToPos(xData[firstIdx], 'x', true));\n          const lastPos = Math.round(u.valToPos(xData[lastIdx], 'x', true));\n\n          if (gaps[0][0] === firstPos) {\n            filtered.push(firstIdx);\n          }\n\n          // show single points between consecutive gaps that share end/start\n          for (let i = 0; i < gaps.length; i++) {\n            let thisGap = gaps[i];\n            let nextGap = gaps[i + 1];\n\n            if (nextGap && thisGap[1] === nextGap[0]) {\n              // approx when data density is > 1pt/px, since gap start/end pixels are rounded\n              let approxIdx = u.posToIdx(thisGap[1], true);\n\n              if (yData[approxIdx] == null) {\n                // scan left/right alternating to find closest index with non-null value\n                for (let j = 1; j < 100; j++) {\n                  if (yData[approxIdx + j] != null) {\n                    approxIdx += j;\n                    break;\n                  }\n                  if (yData[approxIdx - j] != null) {\n                    approxIdx -= j;\n                    break;\n                  }\n                }\n              }\n\n              filtered.push(approxIdx);\n            }\n          }\n\n          if (gaps[gaps.length - 1][1] === lastPos) {\n            filtered.push(lastIdx);\n          }\n        }\n\n        return filtered.length ? filtered : null;\n      };\n    }\n\n    let { fillOpacity } = customConfig;\n\n    let pathBuilder: uPlot.Series.PathBuilder | null = null;\n    let pointsBuilder: uPlot.Series.Points.Show | null = null;\n\n    if (field.state?.origin) {\n      if (!indexByName) {\n        indexByName = getNamesToFieldIndex(frame, allFrames);\n      }\n\n      const originFrame = allFrames[field.state.origin.frameIndex];\n      const originField = originFrame?.fields[field.state.origin.fieldIndex];\n\n      const dispName = getFieldDisplayName(originField ?? field, originFrame, allFrames);\n\n      // disable default renderers\n      if (customRenderedFields.indexOf(dispName) >= 0) {\n        pathBuilder = () => null;\n        pointsBuilder = () => undefined;\n      }\n\n      if (customConfig.fillBelowTo) {\n        const t = indexByName.get(dispName);\n        const b = indexByName.get(customConfig.fillBelowTo);\n        if (isNumber(b) && isNumber(t)) {\n          builder.addBand({\n            series: [t, b],\n            fill: undefined, // using null will have the band use fill options from `t`\n          });\n\n          if (!fillOpacity) {\n            fillOpacity = 35; // default from flot\n          }\n        } else {\n          fillOpacity = 0;\n        }\n      }\n    }\n\n    let dynamicSeriesColor: ((seriesIdx: number) => string | undefined) | undefined = undefined;\n\n    if (colorMode.id === FieldColorModeId.Thresholds) {\n      dynamicSeriesColor = (seriesIdx) => getFieldSeriesColor(alignedFrame.fields[seriesIdx], theme).color;\n    }\n\n    builder.addSeries({\n      pathBuilder,\n      pointsBuilder,\n      scaleKey,\n      showPoints,\n      pointsFilter,\n      colorMode,\n      fillOpacity,\n      theme,\n      dynamicSeriesColor,\n      drawStyle: customConfig.drawStyle!,\n      lineColor: customConfig.lineColor ?? seriesColor,\n      lineWidth: customConfig.lineWidth,\n      lineInterpolation: customConfig.lineInterpolation,\n      lineStyle: customConfig.lineStyle,\n      barAlignment: customConfig.barAlignment,\n      barWidthFactor: customConfig.barWidthFactor,\n      barMaxWidth: customConfig.barMaxWidth,\n      pointSize: customConfig.pointSize,\n      spanNulls: customConfig.spanNulls || false,\n      show: !customConfig.hideFrom?.viz,\n      gradientMode: customConfig.gradientMode,\n      thresholds: config.thresholds,\n      hardMin: field.config.min,\n      hardMax: field.config.max,\n      softMin: customConfig.axisSoftMin,\n      softMax: customConfig.axisSoftMax,\n      // The following properties are not used in the uPlot config, but are utilized as transport for legend config\n      dataFrameFieldIndex: field.state?.origin,\n    });\n\n    // Render thresholds in graph\n    if (customConfig.thresholdsStyle && config.thresholds) {\n      const thresholdDisplay = customConfig.thresholdsStyle.mode ?? GraphTresholdsStyleMode.Off;\n      if (thresholdDisplay !== GraphTresholdsStyleMode.Off) {\n        builder.addThresholds({\n          config: customConfig.thresholdsStyle,\n          thresholds: config.thresholds,\n          scaleKey,\n          theme,\n          hardMin: field.config.min,\n          hardMax: field.config.max,\n          softMin: customConfig.axisSoftMin,\n          softMax: customConfig.axisSoftMax,\n        });\n      }\n    }\n  }\n\n  let stackingGroups = getStackingGroups(frame);\n\n  builder.setStackingGroups(stackingGroups);\n\n  // hook up custom/composite renderers\n  renderers?.forEach((r) => {\n    if (!indexByName) {\n      indexByName = getNamesToFieldIndex(frame, allFrames);\n    }\n    let fieldIndices: Record<string, number> = {};\n\n    for (let key in r.fieldMap) {\n      let dispName = r.fieldMap[key];\n      fieldIndices[key] = indexByName.get(dispName)!;\n    }\n\n    r.init(builder, fieldIndices);\n  });\n\n  builder.scaleKeys = [xScaleKey, yScaleKey];\n\n  // if hovered value is null, how far we may scan left/right to hover nearest non-null\n  const hoverProximityPx = 15;\n\n  let cursor: Partial<uPlot.Cursor> = {\n    // this scans left and right from cursor position to find nearest data index with value != null\n    // TODO: do we want to only scan past undefined values, but halt at explicit null values?\n    dataIdx: (self, seriesIdx, hoveredIdx, cursorXVal) => {\n      let seriesData = self.data[seriesIdx];\n\n      if (seriesData[hoveredIdx] == null) {\n        let nonNullLft = null,\n          nonNullRgt = null,\n          i;\n\n        i = hoveredIdx;\n        while (nonNullLft == null && i-- > 0) {\n          if (seriesData[i] != null) {\n            nonNullLft = i;\n          }\n        }\n\n        i = hoveredIdx;\n        while (nonNullRgt == null && i++ < seriesData.length) {\n          if (seriesData[i] != null) {\n            nonNullRgt = i;\n          }\n        }\n\n        let xVals = self.data[0];\n\n        let curPos = self.valToPos(cursorXVal, 'x');\n        let rgtPos = nonNullRgt == null ? Infinity : self.valToPos(xVals[nonNullRgt], 'x');\n        let lftPos = nonNullLft == null ? -Infinity : self.valToPos(xVals[nonNullLft], 'x');\n\n        let lftDelta = curPos - lftPos;\n        let rgtDelta = rgtPos - curPos;\n\n        if (lftDelta <= rgtDelta) {\n          if (lftDelta <= hoverProximityPx) {\n            hoveredIdx = nonNullLft!;\n          }\n        } else {\n          if (rgtDelta <= hoverProximityPx) {\n            hoveredIdx = nonNullRgt!;\n          }\n        }\n      }\n\n      return hoveredIdx;\n    },\n  };\n\n  if (sync && sync() !== DashboardCursorSync.Off) {\n    const payload: DataHoverPayload = {\n      point: {\n        [xScaleKey]: null,\n        [yScaleKey]: null,\n      },\n      data: frame,\n    };\n    const hoverEvent = new DataHoverEvent(payload);\n    cursor.sync = {\n      key: '__global_',\n      filters: {\n        pub: (type: string, src: uPlot, x: number, y: number, w: number, h: number, dataIdx: number) => {\n          if (sync && sync() === DashboardCursorSync.Off) {\n            return false;\n          }\n\n          payload.rowIndex = dataIdx;\n          if (x < 0 && y < 0) {\n            payload.point[xScaleUnit] = null;\n            payload.point[yScaleKey] = null;\n            eventBus.publish(new DataHoverClearEvent());\n          } else {\n            // convert the points\n            payload.point[xScaleUnit] = src.posToVal(x, xScaleKey);\n            payload.point[yScaleKey] = src.posToVal(y, yScaleKey);\n            payload.point.panelRelY = y > 0 ? y / h : 1; // used by old graph panel to position tooltip\n            eventBus.publish(hoverEvent);\n            hoverEvent.payload.down = undefined;\n          }\n          return true;\n        },\n      },\n      scales: [xScaleKey, yScaleKey],\n      // match: [() => true, (a, b) => a === b],\n    };\n  }\n\n  builder.setSync();\n  builder.setCursor(cursor);\n\n  return builder;\n};\n\nexport function getNamesToFieldIndex(frame: DataFrame, allFrames: DataFrame[]): Map<string, number> {\n  const originNames = new Map<string, number>();\n  frame.fields.forEach((field, i) => {\n    const origin = field.state?.origin;\n    if (origin) {\n      const origField = allFrames[origin.frameIndex]?.fields[origin.fieldIndex];\n      if (origField) {\n        originNames.set(getFieldDisplayName(origField, allFrames[origin.frameIndex], allFrames), i);\n      }\n    }\n  });\n  return originNames;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}