{"ast":null,"code":"const _excluded = [\"instant\", \"range\"],\n      _excluded2 = [\"instant\", \"range\"],\n      _excluded3 = [\"instant\", \"range\"];\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport { escapeRegExp } from 'lodash';\nimport { LokiQueryType } from './types';\nexport function formatQuery(selector) {\n  return `${selector || ''}`.trim();\n}\n/**\n * Returns search terms from a LogQL query.\n * E.g., `{} |= foo |=bar != baz` returns `['foo', 'bar']`.\n */\n\nexport function getHighlighterExpressionsFromQuery(input) {\n  let expression = input;\n  const results = []; // Consume filter expression from left to right\n\n  while (expression) {\n    const filterStart = expression.search(/\\|=|\\|~|!=|!~/); // Nothing more to search\n\n    if (filterStart === -1) {\n      break;\n    } // Drop terms for negative filters\n\n\n    const filterOperator = expression.slice(filterStart, filterStart + 2);\n    const skip = expression.slice(filterStart).search(/!=|!~/) === 0;\n    expression = expression.slice(filterStart + 2);\n\n    if (skip) {\n      continue;\n    } // Check if there is more chained\n\n\n    const filterEnd = expression.search(/\\|=|\\|~|!=|!~/);\n    let filterTerm;\n\n    if (filterEnd === -1) {\n      filterTerm = expression.trim();\n    } else {\n      filterTerm = expression.slice(0, filterEnd).trim();\n      expression = expression.slice(filterEnd);\n    }\n\n    const quotedTerm = filterTerm.match(/\"(.*?)\"/);\n    const backtickedTerm = filterTerm.match(/`(.*?)`/);\n    const term = quotedTerm || backtickedTerm;\n\n    if (term) {\n      const unwrappedFilterTerm = term[1];\n      const regexOperator = filterOperator === '|~'; // Only filter expressions with |~ operator are treated as regular expressions\n\n      if (regexOperator) {\n        // When using backticks, Loki doesn't require to escape special characters and we can just push regular expression to highlights array\n        // When using quotes, we have extra backslash escaping and we need to replace \\\\ with \\\n        results.push(backtickedTerm ? unwrappedFilterTerm : unwrappedFilterTerm.replace(/\\\\\\\\/g, '\\\\'));\n      } else {\n        // We need to escape this string so it is not matched as regular expression\n        results.push(escapeRegExp(unwrappedFilterTerm));\n      }\n    } else {\n      return results;\n    }\n  }\n\n  return results;\n} // we are migrating from `.instant` and `.range` to `.queryType`\n// this function returns a new query object that:\n// - has `.queryType`\n// - does not have `.instant`\n// - does not have `.range`\n\nexport function getNormalizedLokiQuery(query) {\n  //  if queryType field contains invalid data we behave as if the queryType is empty\n  const {\n    queryType\n  } = query;\n  const hasValidQueryType = queryType === LokiQueryType.Range || queryType === LokiQueryType.Instant || queryType === LokiQueryType.Stream; // if queryType exists, it is respected\n\n  if (hasValidQueryType) {\n    const rest = _objectWithoutPropertiesLoose(query, _excluded);\n\n    return rest;\n  } // if no queryType, and instant===true, it's instant\n\n\n  if (query.instant === true) {\n    const rest = _objectWithoutPropertiesLoose(query, _excluded2);\n\n    return Object.assign({}, rest, {\n      queryType: LokiQueryType.Instant\n    });\n  } // otherwise it is range\n\n\n  const rest = _objectWithoutPropertiesLoose(query, _excluded3);\n\n  return Object.assign({}, rest, {\n    queryType: LokiQueryType.Range\n  });\n}","map":{"version":3,"names":["escapeRegExp","LokiQueryType","formatQuery","selector","trim","getHighlighterExpressionsFromQuery","input","expression","results","filterStart","search","filterOperator","slice","skip","filterEnd","filterTerm","quotedTerm","match","backtickedTerm","term","unwrappedFilterTerm","regexOperator","push","replace","getNormalizedLokiQuery","query","queryType","hasValidQueryType","Range","Instant","Stream","rest","instant"],"sources":["/home/soula/grafana/public/app/plugins/datasource/loki/query_utils.ts"],"sourcesContent":["import { escapeRegExp } from 'lodash';\n\nimport { LokiQuery, LokiQueryType } from './types';\n\nexport function formatQuery(selector: string | undefined): string {\n  return `${selector || ''}`.trim();\n}\n\n/**\n * Returns search terms from a LogQL query.\n * E.g., `{} |= foo |=bar != baz` returns `['foo', 'bar']`.\n */\nexport function getHighlighterExpressionsFromQuery(input: string): string[] {\n  let expression = input;\n  const results = [];\n\n  // Consume filter expression from left to right\n  while (expression) {\n    const filterStart = expression.search(/\\|=|\\|~|!=|!~/);\n    // Nothing more to search\n    if (filterStart === -1) {\n      break;\n    }\n    // Drop terms for negative filters\n    const filterOperator = expression.slice(filterStart, filterStart + 2);\n    const skip = expression.slice(filterStart).search(/!=|!~/) === 0;\n    expression = expression.slice(filterStart + 2);\n    if (skip) {\n      continue;\n    }\n    // Check if there is more chained\n    const filterEnd = expression.search(/\\|=|\\|~|!=|!~/);\n    let filterTerm;\n    if (filterEnd === -1) {\n      filterTerm = expression.trim();\n    } else {\n      filterTerm = expression.slice(0, filterEnd).trim();\n      expression = expression.slice(filterEnd);\n    }\n\n    const quotedTerm = filterTerm.match(/\"(.*?)\"/);\n    const backtickedTerm = filterTerm.match(/`(.*?)`/);\n    const term = quotedTerm || backtickedTerm;\n\n    if (term) {\n      const unwrappedFilterTerm = term[1];\n      const regexOperator = filterOperator === '|~';\n\n      // Only filter expressions with |~ operator are treated as regular expressions\n      if (regexOperator) {\n        // When using backticks, Loki doesn't require to escape special characters and we can just push regular expression to highlights array\n        // When using quotes, we have extra backslash escaping and we need to replace \\\\ with \\\n        results.push(backtickedTerm ? unwrappedFilterTerm : unwrappedFilterTerm.replace(/\\\\\\\\/g, '\\\\'));\n      } else {\n        // We need to escape this string so it is not matched as regular expression\n        results.push(escapeRegExp(unwrappedFilterTerm));\n      }\n    } else {\n      return results;\n    }\n  }\n\n  return results;\n}\n\n// we are migrating from `.instant` and `.range` to `.queryType`\n// this function returns a new query object that:\n// - has `.queryType`\n// - does not have `.instant`\n// - does not have `.range`\nexport function getNormalizedLokiQuery(query: LokiQuery): LokiQuery {\n  //  if queryType field contains invalid data we behave as if the queryType is empty\n  const { queryType } = query;\n  const hasValidQueryType =\n    queryType === LokiQueryType.Range || queryType === LokiQueryType.Instant || queryType === LokiQueryType.Stream;\n\n  // if queryType exists, it is respected\n  if (hasValidQueryType) {\n    const { instant, range, ...rest } = query;\n    return rest;\n  }\n\n  // if no queryType, and instant===true, it's instant\n  if (query.instant === true) {\n    const { instant, range, ...rest } = query;\n    return { ...rest, queryType: LokiQueryType.Instant };\n  }\n\n  // otherwise it is range\n  const { instant, range, ...rest } = query;\n  return { ...rest, queryType: LokiQueryType.Range };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}