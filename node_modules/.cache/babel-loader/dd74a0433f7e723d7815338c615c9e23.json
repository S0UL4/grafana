{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { Subject } from 'rxjs';\nexport let FetchStatus;\n\n(function (FetchStatus) {\n  FetchStatus[FetchStatus[\"Pending\"] = 0] = \"Pending\";\n  FetchStatus[FetchStatus[\"InProgress\"] = 1] = \"InProgress\";\n  FetchStatus[FetchStatus[\"Done\"] = 2] = \"Done\";\n})(FetchStatus || (FetchStatus = {}));\n\nexport class FetchQueue {\n  // internal queue state\n  // internal stream for requests that are to be queued\n  // external stream with updates to the queue state\n  constructor(_debug = false) {\n    _defineProperty(this, \"state\", {});\n\n    _defineProperty(this, \"queue\", new Subject());\n\n    _defineProperty(this, \"updates\", new Subject());\n\n    _defineProperty(this, \"add\", (id, options) => this.queue.next({\n      id,\n      options,\n      state: FetchStatus.Pending\n    }));\n\n    _defineProperty(this, \"setInProgress\", id => this.queue.next({\n      id,\n      state: FetchStatus.InProgress\n    }));\n\n    _defineProperty(this, \"setDone\", id => this.queue.next({\n      id,\n      state: FetchStatus.Done\n    }));\n\n    _defineProperty(this, \"getUpdates\", () => this.updates.asObservable());\n\n    _defineProperty(this, \"getUpdate\", state => {\n      const noOfInProgress = Object.keys(state).filter(key => state[key].state === FetchStatus.InProgress).length;\n      const noOfPending = Object.keys(state).filter(key => state[key].state === FetchStatus.Pending).length;\n      return {\n        noOfPending,\n        noOfInProgress,\n        state\n      };\n    });\n\n    _defineProperty(this, \"publishUpdate\", (update, debug) => {\n      this.printState(update, debug);\n      this.updates.next(update);\n    });\n\n    _defineProperty(this, \"printState\", (update, debug) => {\n      if (!debug) {\n        return;\n      }\n\n      const entriesWithoutOptions = Object.keys(update.state).reduce((all, key) => {\n        const entry = {\n          id: key,\n          state: update.state[key].state\n        };\n        all.push(entry);\n        return all;\n      }, []);\n      console.log('FetchQueue noOfStarted', update.noOfInProgress);\n      console.log('FetchQueue noOfNotStarted', update.noOfPending);\n      console.log('FetchQueue state', entriesWithoutOptions);\n    });\n\n    // This will create an implicit live subscription for as long as this class lives.\n    // But as FetchQueue is used by the singleton backendSrv that also lives for as long as Grafana app lives\n    // I think this ok. We could add some disposable pattern later if the need arises.\n    this.queue.subscribe(entry => {\n      const {\n        id,\n        state,\n        options\n      } = entry;\n\n      if (!this.state[id]) {\n        this.state[id] = {\n          state: FetchStatus.Pending,\n          options: {}\n        };\n      }\n\n      if (state === FetchStatus.Done) {\n        delete this.state[id];\n        const update = this.getUpdate(this.state);\n        this.publishUpdate(update, _debug);\n        return;\n      }\n\n      this.state[id].state = state;\n\n      if (options) {\n        this.state[id].options = options;\n      }\n\n      const update = this.getUpdate(this.state);\n      this.publishUpdate(update, _debug);\n    });\n  }\n\n}","map":{"version":3,"names":["Subject","FetchStatus","FetchQueue","constructor","debug","id","options","queue","next","state","Pending","InProgress","Done","updates","asObservable","noOfInProgress","Object","keys","filter","key","length","noOfPending","update","printState","entriesWithoutOptions","reduce","all","entry","push","console","log","subscribe","getUpdate","publishUpdate"],"sources":["/home/soula/grafana/public/app/core/services/FetchQueue.ts"],"sourcesContent":["import { Observable, Subject } from 'rxjs';\n\nimport { BackendSrvRequest } from '@grafana/runtime';\n\nexport interface QueueState extends Record<string, { state: FetchStatus; options: BackendSrvRequest }> {}\n\nexport enum FetchStatus {\n  Pending,\n  InProgress,\n  Done,\n}\n\nexport interface FetchQueueUpdate {\n  noOfInProgress: number;\n  noOfPending: number;\n  state: QueueState;\n}\n\ninterface QueueStateEntry {\n  id: string;\n  options?: BackendSrvRequest;\n  state: FetchStatus;\n}\n\nexport class FetchQueue {\n  private state: QueueState = {}; // internal queue state\n  private queue: Subject<QueueStateEntry> = new Subject<QueueStateEntry>(); // internal stream for requests that are to be queued\n  private updates: Subject<FetchQueueUpdate> = new Subject<FetchQueueUpdate>(); // external stream with updates to the queue state\n\n  constructor(debug = false) {\n    // This will create an implicit live subscription for as long as this class lives.\n    // But as FetchQueue is used by the singleton backendSrv that also lives for as long as Grafana app lives\n    // I think this ok. We could add some disposable pattern later if the need arises.\n    this.queue.subscribe((entry) => {\n      const { id, state, options } = entry;\n\n      if (!this.state[id]) {\n        this.state[id] = { state: FetchStatus.Pending, options: {} as BackendSrvRequest };\n      }\n\n      if (state === FetchStatus.Done) {\n        delete this.state[id];\n        const update = this.getUpdate(this.state);\n        this.publishUpdate(update, debug);\n        return;\n      }\n\n      this.state[id].state = state;\n\n      if (options) {\n        this.state[id].options = options;\n      }\n\n      const update = this.getUpdate(this.state);\n      this.publishUpdate(update, debug);\n    });\n  }\n\n  add = (id: string, options: BackendSrvRequest): void => this.queue.next({ id, options, state: FetchStatus.Pending });\n\n  setInProgress = (id: string): void => this.queue.next({ id, state: FetchStatus.InProgress });\n\n  setDone = (id: string): void => this.queue.next({ id, state: FetchStatus.Done });\n\n  getUpdates = (): Observable<FetchQueueUpdate> => this.updates.asObservable();\n\n  private getUpdate = (state: QueueState): FetchQueueUpdate => {\n    const noOfInProgress = Object.keys(state).filter((key) => state[key].state === FetchStatus.InProgress).length;\n    const noOfPending = Object.keys(state).filter((key) => state[key].state === FetchStatus.Pending).length;\n\n    return { noOfPending, noOfInProgress, state };\n  };\n\n  private publishUpdate = (update: FetchQueueUpdate, debug: boolean): void => {\n    this.printState(update, debug);\n    this.updates.next(update);\n  };\n\n  private printState = (update: FetchQueueUpdate, debug: boolean): void => {\n    if (!debug) {\n      return;\n    }\n\n    const entriesWithoutOptions = Object.keys(update.state).reduce((all, key) => {\n      const entry = { id: key, state: update.state[key].state };\n      all.push(entry);\n      return all;\n    }, [] as Array<{ id: string; state: FetchStatus }>);\n\n    console.log('FetchQueue noOfStarted', update.noOfInProgress);\n    console.log('FetchQueue noOfNotStarted', update.noOfPending);\n    console.log('FetchQueue state', entriesWithoutOptions);\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}