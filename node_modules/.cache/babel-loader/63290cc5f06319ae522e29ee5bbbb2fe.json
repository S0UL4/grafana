{"ast":null,"code":"import { isString } from 'lodash';\nimport { from, merge, of } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport { DataFrameView, isValidLiveChannelAddress, MutableDataFrame, parseLiveChannelAddress, toDataFrame } from '@grafana/data';\nimport { DataSourceWithBackend, getBackendSrv, getGrafanaLiveSrv, getTemplateSrv } from '@grafana/runtime';\nimport { migrateDatasourceNameToRef } from 'app/features/dashboard/state/DashboardMigrator';\nimport { getDashboardSrv } from '../../../features/dashboard/services/DashboardSrv';\nimport AnnotationQueryEditor from './components/AnnotationQueryEditor';\nimport { GrafanaAnnotationType, GrafanaQueryType } from './types';\nlet counter = 100;\nexport class GrafanaDatasource extends DataSourceWithBackend {\n  constructor(instanceSettings) {\n    super(instanceSettings);\n    this.annotations = {\n      QueryEditor: AnnotationQueryEditor,\n\n      prepareAnnotation(json) {\n        var _json$target, _json$type, _json$limit, _json$tags, _json$matchAny;\n\n        // Previously, these properties lived outside of target\n        // This should handle migrating them\n        json.target = (_json$target = json.target) !== null && _json$target !== void 0 ? _json$target : {\n          type: (_json$type = json.type) !== null && _json$type !== void 0 ? _json$type : GrafanaAnnotationType.Dashboard,\n          limit: (_json$limit = json.limit) !== null && _json$limit !== void 0 ? _json$limit : 100,\n          tags: (_json$tags = json.tags) !== null && _json$tags !== void 0 ? _json$tags : [],\n          matchAny: (_json$matchAny = json.matchAny) !== null && _json$matchAny !== void 0 ? _json$matchAny : false\n        }; // using spread syntax caused an infinite loop in StandardAnnotationQueryEditor\n\n        return json;\n      },\n\n      prepareQuery(anno) {\n        let datasource = undefined;\n\n        if (isString(anno.datasource)) {\n          const ref = migrateDatasourceNameToRef(anno.datasource, {\n            returnDefaultAsNull: false\n          });\n\n          if (ref) {\n            datasource = ref;\n          }\n        } else {\n          datasource = anno.datasource;\n        }\n\n        return Object.assign({}, anno, {\n          refId: anno.name,\n          queryType: GrafanaQueryType.Annotations,\n          datasource\n        });\n      }\n\n    };\n  }\n\n  query(request) {\n    const results = [];\n    const targets = [];\n    const templateSrv = getTemplateSrv();\n\n    for (const target of request.targets) {\n      if (target.queryType === GrafanaQueryType.Annotations) {\n        return from(this.getAnnotations({\n          range: request.range,\n          rangeRaw: request.range.raw,\n          annotation: target,\n          dashboard: getDashboardSrv().getCurrent()\n        }));\n      }\n\n      if (target.hide) {\n        continue;\n      }\n\n      if (target.queryType === GrafanaQueryType.LiveMeasurements) {\n        var _request$maxDataPoint, _request$rangeRaw;\n\n        let channel = templateSrv.replace(target.channel, request.scopedVars);\n        const {\n          filter\n        } = target;\n        const addr = parseLiveChannelAddress(channel);\n\n        if (!isValidLiveChannelAddress(addr)) {\n          continue;\n        }\n\n        const buffer = {\n          maxLength: (_request$maxDataPoint = request.maxDataPoints) !== null && _request$maxDataPoint !== void 0 ? _request$maxDataPoint : 500\n        };\n\n        if (target.buffer) {\n          buffer.maxDelta = target.buffer;\n          buffer.maxLength = buffer.maxLength * 2; //??\n        } else if (((_request$rangeRaw = request.rangeRaw) === null || _request$rangeRaw === void 0 ? void 0 : _request$rangeRaw.to) === 'now') {\n          buffer.maxDelta = request.range.to.valueOf() - request.range.from.valueOf();\n        }\n\n        results.push(getGrafanaLiveSrv().getDataStream({\n          key: `${request.requestId}.${counter++}`,\n          addr: addr,\n          filter,\n          buffer\n        }));\n      } else {\n        if (!target.queryType) {\n          target.queryType = GrafanaQueryType.RandomWalk;\n        }\n\n        targets.push(target);\n      }\n    }\n\n    if (targets.length) {\n      results.push(super.query(Object.assign({}, request, {\n        targets\n      })));\n    }\n\n    if (results.length) {\n      // With a single query just return the results\n      if (results.length === 1) {\n        return results[0];\n      }\n\n      return merge(...results);\n    }\n\n    return of(); // nothing\n  }\n\n  listFiles(path) {\n    return this.query({\n      targets: [{\n        refId: 'A',\n        queryType: GrafanaQueryType.List,\n        path\n      }]\n    }).pipe(map(v => {\n      var _v$data$;\n\n      const frame = (_v$data$ = v.data[0]) !== null && _v$data$ !== void 0 ? _v$data$ : new MutableDataFrame();\n      return new DataFrameView(frame);\n    }));\n  }\n\n  metricFindQuery(options) {\n    return Promise.resolve([]);\n  }\n\n  async getAnnotations(options) {\n    var _options$dashboard;\n\n    const templateSrv = getTemplateSrv();\n    const annotation = options.annotation;\n    const target = annotation.target;\n    const params = {\n      from: options.range.from.valueOf(),\n      to: options.range.to.valueOf(),\n      limit: target.limit,\n      tags: target.tags,\n      matchAny: target.matchAny\n    };\n\n    if (target.type === GrafanaAnnotationType.Dashboard) {\n      // if no dashboard id yet return\n      if (!options.dashboard.id) {\n        return Promise.resolve({\n          data: []\n        });\n      } // filter by dashboard id\n\n\n      params.dashboardId = options.dashboard.id; // remove tags filter if any\n\n      delete params.tags;\n    } else {\n      // require at least one tag\n      if (!Array.isArray(target.tags) || target.tags.length === 0) {\n        return Promise.resolve({\n          data: []\n        });\n      }\n\n      const delimiter = '__delimiter__';\n      const tags = [];\n\n      for (const t of params.tags) {\n        const renderedValues = templateSrv.replace(t, {}, value => {\n          if (typeof value === 'string') {\n            return value;\n          }\n\n          return value.join(delimiter);\n        });\n\n        for (const tt of renderedValues.split(delimiter)) {\n          tags.push(tt);\n        }\n      }\n\n      params.tags = tags;\n    }\n\n    const annotations = await getBackendSrv().get('/api/annotations', params, `grafana-data-source-annotations-${annotation.name}-${(_options$dashboard = options.dashboard) === null || _options$dashboard === void 0 ? void 0 : _options$dashboard.id}`);\n    return {\n      data: [toDataFrame(annotations)]\n    };\n  }\n\n  testDatasource() {\n    return Promise.resolve();\n  }\n\n}","map":{"version":3,"names":["isString","from","merge","of","map","DataFrameView","isValidLiveChannelAddress","MutableDataFrame","parseLiveChannelAddress","toDataFrame","DataSourceWithBackend","getBackendSrv","getGrafanaLiveSrv","getTemplateSrv","migrateDatasourceNameToRef","getDashboardSrv","AnnotationQueryEditor","GrafanaAnnotationType","GrafanaQueryType","counter","GrafanaDatasource","constructor","instanceSettings","annotations","QueryEditor","prepareAnnotation","json","target","type","Dashboard","limit","tags","matchAny","prepareQuery","anno","datasource","undefined","ref","returnDefaultAsNull","refId","name","queryType","Annotations","query","request","results","targets","templateSrv","getAnnotations","range","rangeRaw","raw","annotation","dashboard","getCurrent","hide","LiveMeasurements","channel","replace","scopedVars","filter","addr","buffer","maxLength","maxDataPoints","maxDelta","to","valueOf","push","getDataStream","key","requestId","RandomWalk","length","listFiles","path","List","pipe","v","frame","data","metricFindQuery","options","Promise","resolve","params","id","dashboardId","Array","isArray","delimiter","t","renderedValues","value","join","tt","split","get","testDatasource"],"sources":["/home/soula/grafana/public/app/plugins/datasource/grafana/datasource.ts"],"sourcesContent":["import { isString } from 'lodash';\nimport { from, merge, Observable, of } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nimport {\n  AnnotationQuery,\n  AnnotationQueryRequest,\n  DataFrameView,\n  DataQueryRequest,\n  DataQueryResponse,\n  DataSourceInstanceSettings,\n  DataSourceRef,\n  isValidLiveChannelAddress,\n  MutableDataFrame,\n  parseLiveChannelAddress,\n  toDataFrame,\n} from '@grafana/data';\nimport {\n  DataSourceWithBackend,\n  getBackendSrv,\n  getGrafanaLiveSrv,\n  getTemplateSrv,\n  StreamingFrameOptions,\n} from '@grafana/runtime';\nimport { migrateDatasourceNameToRef } from 'app/features/dashboard/state/DashboardMigrator';\n\nimport { getDashboardSrv } from '../../../features/dashboard/services/DashboardSrv';\n\nimport AnnotationQueryEditor from './components/AnnotationQueryEditor';\nimport { GrafanaAnnotationQuery, GrafanaAnnotationType, GrafanaQuery, GrafanaQueryType } from './types';\n\nlet counter = 100;\n\nexport class GrafanaDatasource extends DataSourceWithBackend<GrafanaQuery> {\n  constructor(instanceSettings: DataSourceInstanceSettings) {\n    super(instanceSettings);\n    this.annotations = {\n      QueryEditor: AnnotationQueryEditor,\n      prepareAnnotation(json: any): AnnotationQuery<GrafanaAnnotationQuery> {\n        // Previously, these properties lived outside of target\n        // This should handle migrating them\n        json.target = json.target ?? {\n          type: json.type ?? GrafanaAnnotationType.Dashboard,\n          limit: json.limit ?? 100,\n          tags: json.tags ?? [],\n          matchAny: json.matchAny ?? false,\n        }; // using spread syntax caused an infinite loop in StandardAnnotationQueryEditor\n        return json;\n      },\n      prepareQuery(anno: AnnotationQuery<GrafanaAnnotationQuery>): GrafanaQuery {\n        let datasource: DataSourceRef | undefined | null = undefined;\n        if (isString(anno.datasource)) {\n          const ref = migrateDatasourceNameToRef(anno.datasource, { returnDefaultAsNull: false });\n          if (ref) {\n            datasource = ref;\n          }\n        } else {\n          datasource = anno.datasource as DataSourceRef;\n        }\n\n        return { ...anno, refId: anno.name, queryType: GrafanaQueryType.Annotations, datasource };\n      },\n    };\n  }\n\n  query(request: DataQueryRequest<GrafanaQuery>): Observable<DataQueryResponse> {\n    const results: Array<Observable<DataQueryResponse>> = [];\n    const targets: GrafanaQuery[] = [];\n    const templateSrv = getTemplateSrv();\n    for (const target of request.targets) {\n      if (target.queryType === GrafanaQueryType.Annotations) {\n        return from(\n          this.getAnnotations({\n            range: request.range,\n            rangeRaw: request.range.raw,\n            annotation: target as unknown as AnnotationQuery<GrafanaAnnotationQuery>,\n            dashboard: getDashboardSrv().getCurrent(),\n          })\n        );\n      }\n      if (target.hide) {\n        continue;\n      }\n      if (target.queryType === GrafanaQueryType.LiveMeasurements) {\n        let channel = templateSrv.replace(target.channel, request.scopedVars);\n        const { filter } = target;\n\n        const addr = parseLiveChannelAddress(channel);\n        if (!isValidLiveChannelAddress(addr)) {\n          continue;\n        }\n        const buffer: Partial<StreamingFrameOptions> = {\n          maxLength: request.maxDataPoints ?? 500,\n        };\n        if (target.buffer) {\n          buffer.maxDelta = target.buffer;\n          buffer.maxLength = buffer.maxLength! * 2; //??\n        } else if (request.rangeRaw?.to === 'now') {\n          buffer.maxDelta = request.range.to.valueOf() - request.range.from.valueOf();\n        }\n\n        results.push(\n          getGrafanaLiveSrv().getDataStream({\n            key: `${request.requestId}.${counter++}`,\n            addr: addr!,\n            filter,\n            buffer,\n          })\n        );\n      } else {\n        if (!target.queryType) {\n          target.queryType = GrafanaQueryType.RandomWalk;\n        }\n        targets.push(target);\n      }\n    }\n\n    if (targets.length) {\n      results.push(\n        super.query({\n          ...request,\n          targets,\n        })\n      );\n    }\n\n    if (results.length) {\n      // With a single query just return the results\n      if (results.length === 1) {\n        return results[0];\n      }\n      return merge(...results);\n    }\n    return of(); // nothing\n  }\n\n  listFiles(path: string): Observable<DataFrameView<FileElement>> {\n    return this.query({\n      targets: [\n        {\n          refId: 'A',\n          queryType: GrafanaQueryType.List,\n          path,\n        },\n      ],\n    } as any).pipe(\n      map((v) => {\n        const frame = v.data[0] ?? new MutableDataFrame();\n        return new DataFrameView<FileElement>(frame);\n      })\n    );\n  }\n\n  metricFindQuery(options: any) {\n    return Promise.resolve([]);\n  }\n\n  async getAnnotations(options: AnnotationQueryRequest<GrafanaQuery>): Promise<DataQueryResponse> {\n    const templateSrv = getTemplateSrv();\n    const annotation = options.annotation as unknown as AnnotationQuery<GrafanaAnnotationQuery>;\n    const target = annotation.target!;\n    const params: any = {\n      from: options.range.from.valueOf(),\n      to: options.range.to.valueOf(),\n      limit: target.limit,\n      tags: target.tags,\n      matchAny: target.matchAny,\n    };\n\n    if (target.type === GrafanaAnnotationType.Dashboard) {\n      // if no dashboard id yet return\n      if (!options.dashboard.id) {\n        return Promise.resolve({ data: [] });\n      }\n      // filter by dashboard id\n      params.dashboardId = options.dashboard.id;\n      // remove tags filter if any\n      delete params.tags;\n    } else {\n      // require at least one tag\n      if (!Array.isArray(target.tags) || target.tags.length === 0) {\n        return Promise.resolve({ data: [] });\n      }\n      const delimiter = '__delimiter__';\n      const tags = [];\n      for (const t of params.tags) {\n        const renderedValues = templateSrv.replace(t, {}, (value: any) => {\n          if (typeof value === 'string') {\n            return value;\n          }\n\n          return value.join(delimiter);\n        });\n        for (const tt of renderedValues.split(delimiter)) {\n          tags.push(tt);\n        }\n      }\n      params.tags = tags;\n    }\n\n    const annotations = await getBackendSrv().get(\n      '/api/annotations',\n      params,\n      `grafana-data-source-annotations-${annotation.name}-${options.dashboard?.id}`\n    );\n    return { data: [toDataFrame(annotations)] };\n  }\n\n  testDatasource() {\n    return Promise.resolve();\n  }\n}\n\nexport interface FileElement {\n  name: string;\n  ['media-type']: string;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}