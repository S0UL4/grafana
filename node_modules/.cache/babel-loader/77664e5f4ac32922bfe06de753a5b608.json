{"ast":null,"code":"import { concatMap, filter } from 'rxjs/operators';\nimport { isDataQuery } from '../utils/query';\nimport { FetchStatus } from './FetchQueue';\nexport class FetchQueueWorker {\n  constructor(fetchQueue, responseQueue, config) {\n    const maxParallelRequests = config !== null && config !== void 0 && config.http2Enabled ? 1000 : 5; // for tests that don't mock GrafanaBootConfig the config param will be undefined\n    // This will create an implicit live subscription for as long as this class lives.\n    // But as FetchQueueWorker is used by the singleton backendSrv that also lives for as long as Grafana app lives\n    // I think this ok. We could add some disposable pattern later if the need arises.\n\n    fetchQueue.getUpdates().pipe(filter(({\n      noOfPending\n    }) => noOfPending > 0), // no reason to act if there is nothing to act upon\n    // Using concatMap instead of mergeMap so that the order with apiRequests first is preserved\n    // https://rxjs.dev/api/operators/concatMap\n    concatMap(({\n      state,\n      noOfInProgress\n    }) => {\n      const apiRequests = Object.keys(state).filter(k => state[k].state === FetchStatus.Pending && !isDataQuery(state[k].options.url)).reduce((all, key) => {\n        const entry = {\n          id: key,\n          options: state[key].options\n        };\n        all.push(entry);\n        return all;\n      }, []);\n      const dataRequests = Object.keys(state).filter(key => state[key].state === FetchStatus.Pending && isDataQuery(state[key].options.url)).reduce((all, key) => {\n        const entry = {\n          id: key,\n          options: state[key].options\n        };\n        all.push(entry);\n        return all;\n      }, []); // apiRequests have precedence over data requests and should always be called directly\n      // this means we can end up with a negative value.\n      // Because the way Array.toSlice works with negative numbers we use Math.max below.\n\n      const noOfAllowedDataRequests = Math.max(maxParallelRequests - noOfInProgress - apiRequests.length, 0);\n      const dataRequestToFetch = dataRequests.slice(0, noOfAllowedDataRequests);\n      return apiRequests.concat(dataRequestToFetch);\n    })).subscribe(({\n      id,\n      options\n    }) => {\n      // This will add an entry to the responseQueue\n      responseQueue.add(id, options);\n    });\n  }\n\n}","map":{"version":3,"names":["concatMap","filter","isDataQuery","FetchStatus","FetchQueueWorker","constructor","fetchQueue","responseQueue","config","maxParallelRequests","http2Enabled","getUpdates","pipe","noOfPending","state","noOfInProgress","apiRequests","Object","keys","k","Pending","options","url","reduce","all","key","entry","id","push","dataRequests","noOfAllowedDataRequests","Math","max","length","dataRequestToFetch","slice","concat","subscribe","add"],"sources":["/home/soula/grafana/public/app/core/services/FetchQueueWorker.ts"],"sourcesContent":["import { concatMap, filter } from 'rxjs/operators';\n\nimport { BackendSrvRequest, GrafanaBootConfig } from '@grafana/runtime';\n\nimport { isDataQuery } from '../utils/query';\n\nimport { FetchQueue, FetchStatus } from './FetchQueue';\nimport { ResponseQueue } from './ResponseQueue';\n\ninterface WorkerEntry {\n  id: string;\n  options: BackendSrvRequest;\n}\n\nexport class FetchQueueWorker {\n  constructor(fetchQueue: FetchQueue, responseQueue: ResponseQueue, config: GrafanaBootConfig) {\n    const maxParallelRequests = config?.http2Enabled ? 1000 : 5; // for tests that don't mock GrafanaBootConfig the config param will be undefined\n\n    // This will create an implicit live subscription for as long as this class lives.\n    // But as FetchQueueWorker is used by the singleton backendSrv that also lives for as long as Grafana app lives\n    // I think this ok. We could add some disposable pattern later if the need arises.\n    fetchQueue\n      .getUpdates()\n      .pipe(\n        filter(({ noOfPending }) => noOfPending > 0), // no reason to act if there is nothing to act upon\n        // Using concatMap instead of mergeMap so that the order with apiRequests first is preserved\n        // https://rxjs.dev/api/operators/concatMap\n        concatMap(({ state, noOfInProgress }) => {\n          const apiRequests = Object.keys(state)\n            .filter((k) => state[k].state === FetchStatus.Pending && !isDataQuery(state[k].options.url))\n            .reduce((all, key) => {\n              const entry = { id: key, options: state[key].options };\n              all.push(entry);\n              return all;\n            }, [] as WorkerEntry[]);\n\n          const dataRequests = Object.keys(state)\n            .filter((key) => state[key].state === FetchStatus.Pending && isDataQuery(state[key].options.url))\n            .reduce((all, key) => {\n              const entry = { id: key, options: state[key].options };\n              all.push(entry);\n              return all;\n            }, [] as WorkerEntry[]);\n\n          // apiRequests have precedence over data requests and should always be called directly\n          // this means we can end up with a negative value.\n          // Because the way Array.toSlice works with negative numbers we use Math.max below.\n          const noOfAllowedDataRequests = Math.max(maxParallelRequests - noOfInProgress - apiRequests.length, 0);\n          const dataRequestToFetch = dataRequests.slice(0, noOfAllowedDataRequests);\n\n          return apiRequests.concat(dataRequestToFetch);\n        })\n      )\n      .subscribe(({ id, options }) => {\n        // This will add an entry to the responseQueue\n        responseQueue.add(id, options);\n      });\n  }\n}\n"],"mappings":"AAAA,SAASA,SAAT,EAAoBC,MAApB,QAAkC,gBAAlC;AAIA,SAASC,WAAT,QAA4B,gBAA5B;AAEA,SAAqBC,WAArB,QAAwC,cAAxC;AAQA,OAAO,MAAMC,gBAAN,CAAuB;EAC5BC,WAAW,CAACC,UAAD,EAAyBC,aAAzB,EAAuDC,MAAvD,EAAkF;IAC3F,MAAMC,mBAAmB,GAAGD,MAAM,SAAN,IAAAA,MAAM,WAAN,IAAAA,MAAM,CAAEE,YAAR,GAAuB,IAAvB,GAA8B,CAA1D,CAD2F,CAC9B;IAE7D;IACA;IACA;;IACAJ,UAAU,CACPK,UADH,GAEGC,IAFH,CAGIX,MAAM,CAAC,CAAC;MAAEY;IAAF,CAAD,KAAqBA,WAAW,GAAG,CAApC,CAHV,EAGkD;IAC9C;IACA;IACAb,SAAS,CAAC,CAAC;MAAEc,KAAF;MAASC;IAAT,CAAD,KAA+B;MACvC,MAAMC,WAAW,GAAGC,MAAM,CAACC,IAAP,CAAYJ,KAAZ,EACjBb,MADiB,CACTkB,CAAD,IAAOL,KAAK,CAACK,CAAD,CAAL,CAASL,KAAT,KAAmBX,WAAW,CAACiB,OAA/B,IAA0C,CAAClB,WAAW,CAACY,KAAK,CAACK,CAAD,CAAL,CAASE,OAAT,CAAiBC,GAAlB,CADnD,EAEjBC,MAFiB,CAEV,CAACC,GAAD,EAAMC,GAAN,KAAc;QACpB,MAAMC,KAAK,GAAG;UAAEC,EAAE,EAAEF,GAAN;UAAWJ,OAAO,EAAEP,KAAK,CAACW,GAAD,CAAL,CAAWJ;QAA/B,CAAd;QACAG,GAAG,CAACI,IAAJ,CAASF,KAAT;QACA,OAAOF,GAAP;MACD,CANiB,EAMf,EANe,CAApB;MAQA,MAAMK,YAAY,GAAGZ,MAAM,CAACC,IAAP,CAAYJ,KAAZ,EAClBb,MADkB,CACVwB,GAAD,IAASX,KAAK,CAACW,GAAD,CAAL,CAAWX,KAAX,KAAqBX,WAAW,CAACiB,OAAjC,IAA4ClB,WAAW,CAACY,KAAK,CAACW,GAAD,CAAL,CAAWJ,OAAX,CAAmBC,GAApB,CADrD,EAElBC,MAFkB,CAEX,CAACC,GAAD,EAAMC,GAAN,KAAc;QACpB,MAAMC,KAAK,GAAG;UAAEC,EAAE,EAAEF,GAAN;UAAWJ,OAAO,EAAEP,KAAK,CAACW,GAAD,CAAL,CAAWJ;QAA/B,CAAd;QACAG,GAAG,CAACI,IAAJ,CAASF,KAAT;QACA,OAAOF,GAAP;MACD,CANkB,EAMhB,EANgB,CAArB,CATuC,CAiBvC;MACA;MACA;;MACA,MAAMM,uBAAuB,GAAGC,IAAI,CAACC,GAAL,CAASvB,mBAAmB,GAAGM,cAAtB,GAAuCC,WAAW,CAACiB,MAA5D,EAAoE,CAApE,CAAhC;MACA,MAAMC,kBAAkB,GAAGL,YAAY,CAACM,KAAb,CAAmB,CAAnB,EAAsBL,uBAAtB,CAA3B;MAEA,OAAOd,WAAW,CAACoB,MAAZ,CAAmBF,kBAAnB,CAAP;IACD,CAxBQ,CANb,EAgCGG,SAhCH,CAgCa,CAAC;MAAEV,EAAF;MAAMN;IAAN,CAAD,KAAqB;MAC9B;MACAd,aAAa,CAAC+B,GAAd,CAAkBX,EAAlB,EAAsBN,OAAtB;IACD,CAnCH;EAoCD;;AA3C2B"},"metadata":{},"sourceType":"module"}