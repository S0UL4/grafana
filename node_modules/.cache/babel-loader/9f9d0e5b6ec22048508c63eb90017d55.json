{"ast":null,"code":"import uPlot from 'uplot';\nimport { DashboardCursorSync, DataFrameType, DataHoverClearEvent, DataHoverEvent, formattedValueToString, getValueFormat, incrRoundDn, incrRoundUp } from '@grafana/data';\nimport { AxisPlacement, ScaleDirection, ScaleDistribution, ScaleOrientation } from '@grafana/schema';\nimport { UPlotConfigBuilder } from '@grafana/ui';\nimport { isHeatmapCellsDense, readHeatmapRowsCustomMeta } from 'app/features/transformers/calculateHeatmap/heatmap';\nimport { HeatmapCellLayout } from 'app/features/transformers/calculateHeatmap/models.gen';\nimport { pointWithin, Quadtree } from '../barchart/quadtree';\nexport function prepConfig(opts) {\n  var _dataRef$current, _dataRef$current$heat, _dataRef$current$heat2, _dataRef$current2, _dataRef$current3, _dataRef$current3$hea, _yField$config, _yFieldConfig$scaleDi, _dataRef$current4, _dataRef$current5, _yScale$log, _yField$display, _dataRef$current14, _dataRef$current15, _dataRef$current16, _dataRef$current17;\n\n  const {\n    dataRef,\n    theme,\n    eventBus,\n    onhover,\n    onclick,\n    onzoom,\n    isToolTipOpen,\n    timeZone,\n    getTimeRange,\n    palette,\n    cellGap,\n    hideLE,\n    hideGE,\n    yAxisConfig,\n    ySizeDivisor,\n    sync\n  } = opts;\n  const xScaleKey = 'x';\n  const xScaleUnit = 'time';\n  const pxRatio = devicePixelRatio;\n  let heatmapType = (_dataRef$current = dataRef.current) === null || _dataRef$current === void 0 ? void 0 : (_dataRef$current$heat = _dataRef$current.heatmap) === null || _dataRef$current$heat === void 0 ? void 0 : (_dataRef$current$heat2 = _dataRef$current$heat.meta) === null || _dataRef$current$heat2 === void 0 ? void 0 : _dataRef$current$heat2.type;\n  const exemplarFillColor = theme.visualization.getColorByName(opts.exemplarColor);\n  let qt;\n  let hRect;\n  let builder = new UPlotConfigBuilder(timeZone);\n  let rect;\n  builder.addHook('init', u => {\n    u.root.querySelectorAll('.u-cursor-pt').forEach(el => {\n      Object.assign(el.style, {\n        borderRadius: '0',\n        border: '1px solid white',\n        background: 'transparent'\n      });\n    });\n    onclick && u.over.addEventListener('mouseup', e => {\n      // @ts-ignore\n      let isDragging = u.cursor.drag._x || u.cursor.drag._y;\n\n      if (!isDragging) {\n        onclick(e);\n      }\n    }, true);\n  });\n  onzoom && builder.addHook('setSelect', u => {\n    onzoom({\n      xMin: u.posToVal(u.select.left, xScaleKey),\n      xMax: u.posToVal(u.select.left + u.select.width, xScaleKey)\n    });\n    u.setSelect({\n      left: 0,\n      top: 0,\n      width: 0,\n      height: 0\n    }, false);\n  }); // this is a tmp hack because in mode: 2, uplot does not currently call scales.x.range() for setData() calls\n  // scales.x.range() typically reads back from drilled-down panelProps.timeRange via getTimeRange()\n\n  builder.addHook('setData', u => {\n    //let [min, max] = (u.scales!.x!.range! as uPlot.Range.Function)(u, 0, 100, xScaleKey);\n    let {\n      min: xMin,\n      max: xMax\n    } = u.scales.x;\n    let min = getTimeRange().from.valueOf();\n    let max = getTimeRange().to.valueOf();\n\n    if (xMin !== min || xMax !== max) {\n      queueMicrotask(() => {\n        u.setScale(xScaleKey, {\n          min,\n          max\n        });\n      });\n    }\n  }); // rect of .u-over (grid area)\n\n  builder.addHook('syncRect', (u, r) => {\n    rect = r;\n  });\n  const payload = {\n    point: {\n      [xScaleUnit]: null\n    },\n    data: (_dataRef$current2 = dataRef.current) === null || _dataRef$current2 === void 0 ? void 0 : _dataRef$current2.heatmap\n  };\n  const hoverEvent = new DataHoverEvent(payload);\n  let pendingOnleave;\n  onhover && builder.addHook('setLegend', u => {\n    if (u.cursor.idxs != null) {\n      for (let i = 0; i < u.cursor.idxs.length; i++) {\n        const sel = u.cursor.idxs[i];\n\n        if (sel != null) {\n          const {\n            left,\n            top\n          } = u.cursor;\n          payload.rowIndex = sel;\n          payload.point[xScaleUnit] = u.posToVal(left, xScaleKey);\n          eventBus.publish(hoverEvent);\n\n          if (!isToolTipOpen.current) {\n            if (pendingOnleave) {\n              clearTimeout(pendingOnleave);\n              pendingOnleave = 0;\n            }\n\n            onhover({\n              seriesIdx: i,\n              dataIdx: sel,\n              pageX: rect.left + left,\n              pageY: rect.top + top\n            });\n          }\n\n          return;\n        }\n      }\n    }\n\n    if (!isToolTipOpen.current) {\n      // if tiles have gaps, reduce flashing / re-render (debounce onleave by 100ms)\n      if (!pendingOnleave) {\n        pendingOnleave = setTimeout(() => {\n          onhover(null);\n          payload.rowIndex = undefined;\n          payload.point[xScaleUnit] = null;\n          eventBus.publish(hoverEvent);\n        }, 100);\n      }\n    }\n  });\n  builder.addHook('drawClear', u => {\n    qt = qt || new Quadtree(0, 0, u.bbox.width, u.bbox.height);\n    qt.clear(); // force-clear the path cache to cause drawBars() to rebuild new quadtree\n\n    u.series.forEach((s, i) => {\n      if (i > 0) {\n        // @ts-ignore\n        s._paths = null;\n      }\n    });\n  });\n  builder.setMode(2);\n  builder.addScale({\n    scaleKey: xScaleKey,\n    isTime: true,\n    orientation: ScaleOrientation.Horizontal,\n    direction: ScaleDirection.Right,\n    // TODO: expand by x bucket size and layout\n    range: () => {\n      return [getTimeRange().from.valueOf(), getTimeRange().to.valueOf()];\n    }\n  });\n  builder.addAxis({\n    scaleKey: xScaleKey,\n    placement: AxisPlacement.Bottom,\n    isTime: true,\n    theme: theme\n  });\n  const yField = (_dataRef$current3 = dataRef.current) === null || _dataRef$current3 === void 0 ? void 0 : (_dataRef$current3$hea = _dataRef$current3.heatmap) === null || _dataRef$current3$hea === void 0 ? void 0 : _dataRef$current3$hea.fields[1];\n\n  if (!yField) {\n    return builder; // early abort (avoids error)\n  } // eslint-ignore @typescript-eslint/no-explicit-any\n\n\n  const yFieldConfig = (_yField$config = yField.config) === null || _yField$config === void 0 ? void 0 : _yField$config.custom;\n  const yScale = (_yFieldConfig$scaleDi = yFieldConfig === null || yFieldConfig === void 0 ? void 0 : yFieldConfig.scaleDistribution) !== null && _yFieldConfig$scaleDi !== void 0 ? _yFieldConfig$scaleDi : {\n    type: ScaleDistribution.Linear\n  };\n  const yAxisReverse = Boolean(yAxisConfig.reverse);\n  const isSparseHeatmap = heatmapType === DataFrameType.HeatmapCells && !isHeatmapCellsDense((_dataRef$current4 = dataRef.current) === null || _dataRef$current4 === void 0 ? void 0 : _dataRef$current4.heatmap);\n  const shouldUseLogScale = yScale.type !== ScaleDistribution.Linear || isSparseHeatmap;\n  const isOrdianalY = readHeatmapRowsCustomMeta((_dataRef$current5 = dataRef.current) === null || _dataRef$current5 === void 0 ? void 0 : _dataRef$current5.heatmap).yOrdinalDisplay != null; // random to prevent syncing y in other heatmaps\n  // TODO: try to match TimeSeries y keygen algo to sync with TimeSeries panels (when not isOrdianalY)\n\n  const yScaleKey = 'y_' + (Math.random() + 1).toString(36).substring(7);\n  builder.addScale({\n    scaleKey: yScaleKey,\n    isTime: false,\n    // distribution: ScaleDistribution.Ordinal, // does not work with facets/scatter yet\n    orientation: ScaleOrientation.Vertical,\n    direction: yAxisReverse ? ScaleDirection.Down : ScaleDirection.Up,\n    // should be tweakable manually\n    distribution: shouldUseLogScale ? ScaleDistribution.Log : ScaleDistribution.Linear,\n    log: (_yScale$log = yScale.log) !== null && _yScale$log !== void 0 ? _yScale$log : 2,\n    range: // sparse already accounts for le/ge by explicit yMin & yMax cell bounds, so no need to expand y range\n    isSparseHeatmap ? (u, dataMin, dataMax) => {\n      var _yScale$log2;\n\n      let scaleMin, scaleMax;\n      [scaleMin, scaleMax] = shouldUseLogScale ? uPlot.rangeLog(dataMin, dataMax, (_yScale$log2 = yScale.log) !== null && _yScale$log2 !== void 0 ? _yScale$log2 : 2, true) : [dataMin, dataMax];\n\n      if (shouldUseLogScale && !isOrdianalY) {\n        let {\n          min: explicitMin,\n          max: explicitMax\n        } = yAxisConfig; // guard against <= 0\n\n        if (explicitMin != null && explicitMin > 0) {\n          scaleMin = explicitMin;\n        }\n\n        if (explicitMax != null && explicitMax > 0) {\n          scaleMax = explicitMax;\n        }\n      }\n\n      return [scaleMin, scaleMax];\n    } : // dense and ordinal only have one of yMin|yMax|y, so expand range by one cell in the direction of le/ge/unknown\n    (u, dataMin, dataMax) => {\n      let {\n        min: explicitMin,\n        max: explicitMax\n      } = yAxisConfig; // logarithmic expansion\n\n      if (shouldUseLogScale) {\n        var _dataRef$current6, _dataRef$current7;\n\n        let yExp = u.scales[yScaleKey].log;\n        let minExpanded = false;\n        let maxExpanded = false;\n\n        if (ySizeDivisor !== 1) {\n          let log = yExp === 2 ? Math.log2 : Math.log10;\n          let minLog = log(dataMin);\n          let maxLog = log(dataMax);\n\n          if (!Number.isInteger(minLog)) {\n            dataMin = yExp ** incrRoundDn(minLog, 1);\n            minExpanded = true;\n          }\n\n          if (!Number.isInteger(maxLog)) {\n            dataMax = yExp ** incrRoundUp(maxLog, 1);\n            maxExpanded = true;\n          }\n        }\n\n        if (((_dataRef$current6 = dataRef.current) === null || _dataRef$current6 === void 0 ? void 0 : _dataRef$current6.yLayout) === HeatmapCellLayout.le) {\n          if (!minExpanded) {\n            dataMin /= yExp;\n          }\n        } else if (((_dataRef$current7 = dataRef.current) === null || _dataRef$current7 === void 0 ? void 0 : _dataRef$current7.yLayout) === HeatmapCellLayout.ge) {\n          if (!maxExpanded) {\n            dataMax *= yExp;\n          }\n        } else {\n          dataMin /= yExp / 2;\n          dataMax *= yExp / 2;\n        }\n\n        if (!isOrdianalY) {\n          // guard against <= 0\n          if (explicitMin != null && explicitMin > 0) {\n            dataMin = explicitMin;\n          }\n\n          if (explicitMax != null && explicitMax > 0) {\n            dataMax = explicitMax;\n          }\n        }\n      } // linear expansion\n      else {\n        var _dataRef$current8;\n\n        let bucketSize = (_dataRef$current8 = dataRef.current) === null || _dataRef$current8 === void 0 ? void 0 : _dataRef$current8.yBucketSize;\n\n        if (bucketSize === 0) {\n          bucketSize = 1;\n        }\n\n        if (bucketSize) {\n          var _dataRef$current9, _dataRef$current10;\n\n          if (((_dataRef$current9 = dataRef.current) === null || _dataRef$current9 === void 0 ? void 0 : _dataRef$current9.yLayout) === HeatmapCellLayout.le) {\n            dataMin -= bucketSize;\n          } else if (((_dataRef$current10 = dataRef.current) === null || _dataRef$current10 === void 0 ? void 0 : _dataRef$current10.yLayout) === HeatmapCellLayout.ge) {\n            dataMax += bucketSize;\n          } else {\n            dataMin -= bucketSize / 2;\n            dataMax += bucketSize / 2;\n          }\n        } else {// how to expand scale range if inferred non-regular or log buckets?\n        }\n\n        if (!isOrdianalY) {\n          dataMin = explicitMin !== null && explicitMin !== void 0 ? explicitMin : dataMin;\n          dataMax = explicitMax !== null && explicitMax !== void 0 ? explicitMax : dataMax;\n        }\n      }\n\n      return [dataMin, dataMax];\n    }\n  });\n  const dispY = (_yField$display = yField.display) !== null && _yField$display !== void 0 ? _yField$display : getValueFormat('short');\n  builder.addAxis({\n    scaleKey: yScaleKey,\n    show: yAxisConfig.axisPlacement !== AxisPlacement.Hidden,\n    placement: yAxisConfig.axisPlacement || AxisPlacement.Left,\n    size: yAxisConfig.axisWidth || null,\n    label: yAxisConfig.axisLabel,\n    theme: theme,\n    formatValue: v => formattedValueToString(dispY(v)),\n    splits: isOrdianalY ? self => {\n      var _dataRef$current11, _dataRef$current12;\n\n      const meta = readHeatmapRowsCustomMeta((_dataRef$current11 = dataRef.current) === null || _dataRef$current11 === void 0 ? void 0 : _dataRef$current11.heatmap);\n\n      if (!meta.yOrdinalDisplay) {\n        return [0, 1]; //?\n      }\n\n      let splits = meta.yOrdinalDisplay.map((v, idx) => idx);\n\n      switch ((_dataRef$current12 = dataRef.current) === null || _dataRef$current12 === void 0 ? void 0 : _dataRef$current12.yLayout) {\n        case HeatmapCellLayout.le:\n          splits.unshift(-1);\n          break;\n\n        case HeatmapCellLayout.ge:\n          splits.push(splits.length);\n          break;\n      } // Skip labels when the height is too small\n\n\n      if (self.height < 60) {\n        splits = [splits[0], splits[splits.length - 1]];\n      } else {\n        while (splits.length > 3 && (self.height - 15) / splits.length < 10) {\n          splits = splits.filter((v, idx) => idx % 2 === 0); // remove half the items\n        }\n      }\n\n      return splits;\n    } : undefined,\n    values: isOrdianalY ? (self, splits) => {\n      var _dataRef$current13;\n\n      const meta = readHeatmapRowsCustomMeta((_dataRef$current13 = dataRef.current) === null || _dataRef$current13 === void 0 ? void 0 : _dataRef$current13.heatmap);\n\n      if (meta.yOrdinalDisplay) {\n        return splits.map(v => {\n          var _meta$yMinDisplay, _meta$yOrdinalDisplay;\n\n          return v < 0 ? (_meta$yMinDisplay = meta.yMinDisplay) !== null && _meta$yMinDisplay !== void 0 ? _meta$yMinDisplay : '' // Check prometheus style labels\n          : (_meta$yOrdinalDisplay = meta.yOrdinalDisplay[v]) !== null && _meta$yOrdinalDisplay !== void 0 ? _meta$yOrdinalDisplay : '';\n        });\n      }\n\n      return splits;\n    } : undefined\n  });\n  const pathBuilder = isSparseHeatmap ? heatmapPathsSparse : heatmapPathsDense; // heatmap layer\n\n  builder.addSeries({\n    facets: [{\n      scale: xScaleKey,\n      auto: true,\n      sorted: 1\n    }, {\n      scale: yScaleKey,\n      auto: true\n    }],\n    pathBuilder: pathBuilder({\n      each: (u, seriesIdx, dataIdx, x, y, xSize, ySize) => {\n        qt.add({\n          x: x - u.bbox.left,\n          y: y - u.bbox.top,\n          w: xSize,\n          h: ySize,\n          sidx: seriesIdx,\n          didx: dataIdx\n        });\n      },\n      gap: cellGap,\n      hideLE,\n      hideGE,\n      xAlign: ((_dataRef$current14 = dataRef.current) === null || _dataRef$current14 === void 0 ? void 0 : _dataRef$current14.xLayout) === HeatmapCellLayout.le ? -1 : ((_dataRef$current15 = dataRef.current) === null || _dataRef$current15 === void 0 ? void 0 : _dataRef$current15.xLayout) === HeatmapCellLayout.ge ? 1 : 0,\n      yAlign: (((_dataRef$current16 = dataRef.current) === null || _dataRef$current16 === void 0 ? void 0 : _dataRef$current16.yLayout) === HeatmapCellLayout.le ? -1 : ((_dataRef$current17 = dataRef.current) === null || _dataRef$current17 === void 0 ? void 0 : _dataRef$current17.yLayout) === HeatmapCellLayout.ge ? 1 : 0) * (yAxisReverse ? -1 : 1),\n      ySizeDivisor,\n      disp: {\n        fill: {\n          values: (u, seriesIdx) => {\n            var _dataRef$current18, _dataRef$current19;\n\n            let countFacetIdx = !isSparseHeatmap ? 2 : 3;\n            return valuesToFills(u.data[seriesIdx][countFacetIdx], palette, (_dataRef$current18 = dataRef.current) === null || _dataRef$current18 === void 0 ? void 0 : _dataRef$current18.minValue, (_dataRef$current19 = dataRef.current) === null || _dataRef$current19 === void 0 ? void 0 : _dataRef$current19.maxValue);\n          },\n          index: palette\n        }\n      }\n    }),\n    theme,\n    scaleKey: '' // facets' scales used (above)\n\n  }); // exemplars layer\n\n  builder.addSeries({\n    facets: [{\n      scale: xScaleKey,\n      auto: true,\n      sorted: 1\n    }, {\n      scale: yScaleKey,\n      auto: true\n    }],\n    pathBuilder: heatmapPathsPoints({\n      each: (u, seriesIdx, dataIdx, x, y, xSize, ySize) => {\n        qt.add({\n          x: x - u.bbox.left,\n          y: y - u.bbox.top,\n          w: xSize,\n          h: ySize,\n          sidx: seriesIdx,\n          didx: dataIdx\n        });\n      }\n    }, exemplarFillColor),\n    theme,\n    scaleKey: '' // facets' scales used (above)\n\n  });\n  const cursor = {\n    drag: {\n      x: true,\n      y: false,\n      setScale: false\n    },\n    dataIdx: (u, seriesIdx) => {\n      if (seriesIdx === 1) {\n        hRect = null;\n        let cx = u.cursor.left * pxRatio;\n        let cy = u.cursor.top * pxRatio;\n        qt.get(cx, cy, 1, 1, o => {\n          if (pointWithin(cx, cy, o.x, o.y, o.x + o.w, o.y + o.h)) {\n            hRect = o;\n          }\n        });\n      }\n\n      return hRect && seriesIdx === hRect.sidx ? hRect.didx : null;\n    },\n    points: {\n      fill: 'rgba(255,255,255, 0.3)',\n      bbox: (u, seriesIdx) => {\n        let isHovered = hRect && seriesIdx === hRect.sidx;\n        return {\n          left: isHovered ? hRect.x / pxRatio : -10,\n          top: isHovered ? hRect.y / pxRatio : -10,\n          width: isHovered ? hRect.w / pxRatio : 0,\n          height: isHovered ? hRect.h / pxRatio : 0\n        };\n      }\n    }\n  };\n\n  if (sync && sync() !== DashboardCursorSync.Off) {\n    cursor.sync = {\n      key: '__global_',\n      scales: [xScaleKey, yScaleKey],\n      filters: {\n        pub: (type, src, x, y, w, h, dataIdx) => {\n          if (x < 0) {\n            payload.point[xScaleUnit] = null;\n            eventBus.publish(new DataHoverClearEvent());\n          } else {\n            payload.point[xScaleUnit] = src.posToVal(x, xScaleKey);\n            eventBus.publish(hoverEvent);\n          }\n\n          return true;\n        }\n      }\n    };\n    builder.setSync();\n  }\n\n  builder.setCursor(cursor);\n  return builder;\n}\nconst CRISP_EDGES_GAP_MIN = 4;\nexport function heatmapPathsDense(opts) {\n  const {\n    disp,\n    each,\n    gap = 1,\n    hideLE = -Infinity,\n    hideGE = Infinity,\n    xAlign = 1,\n    yAlign = 1,\n    ySizeDivisor = 1\n  } = opts;\n  const pxRatio = devicePixelRatio;\n  const round = gap >= CRISP_EDGES_GAP_MIN ? Math.round : v => v;\n  const cellGap = Math.round(gap * pxRatio);\n  return (u, seriesIdx) => {\n    uPlot.orient(u, seriesIdx, (series, dataX, dataY, scaleX, scaleY, valToPosX, valToPosY, xOff, yOff, xDim, yDim, moveTo, lineTo, rect, arc) => {\n      var _disp$fill$index;\n\n      let d = u.data[seriesIdx];\n      const xs = d[0];\n      const ys = d[1];\n      const counts = d[2];\n      const dlen = xs.length; // fill colors are mapped from interpolating densities / counts along some gradient\n      // (should be quantized to 64 colors/levels max. e.g. 16)\n\n      let fills = disp.fill.values(u, seriesIdx);\n      let fillPalette = (_disp$fill$index = disp.fill.index) !== null && _disp$fill$index !== void 0 ? _disp$fill$index : [...new Set(fills)];\n      let fillPaths = fillPalette.map(color => new Path2D()); // detect x and y bin qtys by detecting layout repetition in x & y data\n\n      let yBinQty = dlen - ys.lastIndexOf(ys[0]);\n      let xBinQty = dlen / yBinQty;\n      let yBinIncr = ys[1] - ys[0] || scaleY.max - scaleY.min;\n      let xBinIncr = xs[yBinQty] - xs[0]; // uniform tile sizes based on zoom level\n\n      let xSize;\n      let ySize;\n\n      if (scaleX.distr === 3) {\n        xSize = Math.abs(valToPosX(xs[0] * scaleX.log, scaleX, xDim, xOff) - valToPosX(xs[0], scaleX, xDim, xOff));\n      } else {\n        xSize = Math.abs(valToPosX(xBinIncr, scaleX, xDim, xOff) - valToPosX(0, scaleX, xDim, xOff));\n      }\n\n      if (scaleY.distr === 3) {\n        ySize = Math.abs(valToPosY(ys[0] * scaleY.log, scaleY, yDim, yOff) - valToPosY(ys[0], scaleY, yDim, yOff)) / ySizeDivisor;\n      } else {\n        ySize = Math.abs(valToPosY(yBinIncr, scaleY, yDim, yOff) - valToPosY(0, scaleY, yDim, yOff)) / ySizeDivisor;\n      } // clamp min tile size to 1px\n\n\n      xSize = Math.max(1, round(xSize - cellGap));\n      ySize = Math.max(1, round(ySize - cellGap)); // bucket agg direction\n      // let xCeil = false;\n      // let yCeil = false;\n\n      let xOffset = xAlign === -1 ? -xSize : xAlign === 0 ? -xSize / 2 : 0;\n      let yOffset = yAlign === 1 ? -ySize : yAlign === 0 ? -ySize / 2 : 0; // pre-compute x and y offsets\n\n      let cys = ys.slice(0, yBinQty).map(y => round(valToPosY(y, scaleY, yDim, yOff) + yOffset));\n      let cxs = Array.from({\n        length: xBinQty\n      }, (v, i) => round(valToPosX(xs[i * yBinQty], scaleX, xDim, xOff) + xOffset));\n\n      for (let i = 0; i < dlen; i++) {\n        if (counts[i] > hideLE && counts[i] < hideGE) {\n          let cx = cxs[~~(i / yBinQty)];\n          let cy = cys[i % yBinQty];\n          let fillPath = fillPaths[fills[i]];\n          rect(fillPath, cx, cy, xSize, ySize);\n          each(u, 1, i, cx, cy, xSize, ySize);\n        }\n      }\n\n      u.ctx.save(); //\tu.ctx.globalAlpha = 0.8;\n\n      u.ctx.rect(u.bbox.left, u.bbox.top, u.bbox.width, u.bbox.height);\n      u.ctx.clip();\n      fillPaths.forEach((p, i) => {\n        u.ctx.fillStyle = fillPalette[i];\n        u.ctx.fill(p);\n      });\n      u.ctx.restore();\n      return null;\n    });\n    return null;\n  };\n}\nexport function heatmapPathsPoints(opts, exemplarColor) {\n  return (u, seriesIdx) => {\n    uPlot.orient(u, seriesIdx, (series, dataX, dataY, scaleX, scaleY, valToPosX, valToPosY, xOff, yOff, xDim, yDim, moveTo, lineTo, rect, arc) => {\n      //console.time('heatmapPathsSparse');\n      [dataX, dataY] = dataY;\n      let points = new Path2D();\n      let fillPaths = [points];\n      let fillPalette = [exemplarColor !== null && exemplarColor !== void 0 ? exemplarColor : 'rgba(255,0,255,0.7)'];\n\n      for (let i = 0; i < dataX.length; i++) {\n        let yVal = dataY[i];\n        yVal -= 0.5; // center vertically in bucket (when tiles are le)\n        // y-randomize vertically to distribute exemplars in same bucket at same time\n\n        let randSign = Math.round(Math.random()) * 2 - 1;\n        yVal += randSign * 0.5 * Math.random();\n        let x = valToPosX(dataX[i], scaleX, xDim, xOff);\n        let y = valToPosY(yVal, scaleY, yDim, yOff);\n        let w = 8;\n        let h = 8;\n        rect(points, x - w / 2, y - h / 2, w, h);\n        opts.each(u, seriesIdx, i, x - w / 2, y - h / 2, w, h);\n      }\n\n      u.ctx.save();\n      u.ctx.rect(u.bbox.left, u.bbox.top, u.bbox.width, u.bbox.height);\n      u.ctx.clip();\n      fillPaths.forEach((p, i) => {\n        u.ctx.fillStyle = fillPalette[i];\n        u.ctx.fill(p);\n      });\n      u.ctx.restore();\n    });\n    return null;\n  };\n} // accepts xMax, yMin, yMax, count\n// xbinsize? x tile sizes are uniform?\n\nexport function heatmapPathsSparse(opts) {\n  const {\n    disp,\n    each,\n    gap = 1,\n    hideLE = -Infinity,\n    hideGE = Infinity\n  } = opts;\n  const pxRatio = devicePixelRatio;\n  const round = gap >= CRISP_EDGES_GAP_MIN ? Math.round : v => v;\n  const cellGap = Math.round(gap * pxRatio);\n  return (u, seriesIdx) => {\n    uPlot.orient(u, seriesIdx, (series, dataX, dataY, scaleX, scaleY, valToPosX, valToPosY, xOff, yOff, xDim, yDim, moveTo, lineTo, rect, arc) => {\n      var _disp$fill$index2;\n\n      //console.time('heatmapPathsSparse');\n      let d = u.data[seriesIdx];\n      const xMaxs = d[0]; // xMax, do we get interval?\n\n      const yMins = d[1];\n      const yMaxs = d[2];\n      const counts = d[3];\n      const dlen = xMaxs.length; // fill colors are mapped from interpolating densities / counts along some gradient\n      // (should be quantized to 64 colors/levels max. e.g. 16)\n\n      let fills = disp.fill.values(u, seriesIdx);\n      let fillPalette = (_disp$fill$index2 = disp.fill.index) !== null && _disp$fill$index2 !== void 0 ? _disp$fill$index2 : [...new Set(fills)];\n      let fillPaths = fillPalette.map(color => new Path2D()); // cache all tile bounds\n\n      let xOffs = new Map();\n      let yOffs = new Map();\n\n      for (let i = 0; i < xMaxs.length; i++) {\n        let xMax = xMaxs[i];\n        let yMin = yMins[i];\n        let yMax = yMaxs[i];\n\n        if (!xOffs.has(xMax)) {\n          xOffs.set(xMax, round(valToPosX(xMax, scaleX, xDim, xOff)));\n        }\n\n        if (!yOffs.has(yMin)) {\n          yOffs.set(yMin, round(valToPosY(yMin, scaleY, yDim, yOff)));\n        }\n\n        if (!yOffs.has(yMax)) {\n          yOffs.set(yMax, round(valToPosY(yMax, scaleY, yDim, yOff)));\n        }\n      } // uniform x size (interval, step)\n\n\n      let xSizeUniform = xOffs.get(xMaxs.find(v => v !== xMaxs[0])) - xOffs.get(xMaxs[0]);\n\n      for (let i = 0; i < dlen; i++) {\n        if (counts[i] <= hideLE || counts[i] >= hideGE) {\n          continue;\n        }\n\n        let xMax = xMaxs[i];\n        let yMin = yMins[i];\n        let yMax = yMaxs[i];\n        let xMaxPx = xOffs.get(xMax); // xSize is from interval, or inferred delta?\n\n        let yMinPx = yOffs.get(yMin);\n        let yMaxPx = yOffs.get(yMax);\n        let xSize = xSizeUniform;\n        let ySize = yMinPx - yMaxPx; // clamp min tile size to 1px\n\n        xSize = Math.max(1, xSize - cellGap);\n        ySize = Math.max(1, ySize - cellGap);\n        let x = xMaxPx;\n        let y = yMinPx;\n        let fillPath = fillPaths[fills[i]];\n        rect(fillPath, x, y, xSize, ySize);\n        each(u, 1, i, x, y, xSize, ySize);\n      }\n\n      u.ctx.save(); //\tu.ctx.globalAlpha = 0.8;\n\n      u.ctx.rect(u.bbox.left, u.bbox.top, u.bbox.width, u.bbox.height);\n      u.ctx.clip();\n      fillPaths.forEach((p, i) => {\n        u.ctx.fillStyle = fillPalette[i];\n        u.ctx.fill(p);\n      });\n      u.ctx.restore(); //console.timeEnd('heatmapPathsSparse');\n    });\n    return null;\n  };\n}\nexport const boundedMinMax = (values, minValue, maxValue, hideLE = -Infinity, hideGE = Infinity) => {\n  if (minValue == null) {\n    minValue = Infinity;\n\n    for (let i = 0; i < values.length; i++) {\n      if (values[i] > hideLE && values[i] < hideGE) {\n        minValue = Math.min(minValue, values[i]);\n      }\n    }\n  }\n\n  if (maxValue == null) {\n    maxValue = -Infinity;\n\n    for (let i = 0; i < values.length; i++) {\n      if (values[i] > hideLE && values[i] < hideGE) {\n        maxValue = Math.max(maxValue, values[i]);\n      }\n    }\n  }\n\n  return [minValue, maxValue];\n};\nexport const valuesToFills = (values, palette, minValue, maxValue) => {\n  let range = Math.max(maxValue - minValue, 1);\n  let paletteSize = palette.length;\n  let indexedFills = Array(values.length);\n\n  for (let i = 0; i < values.length; i++) {\n    indexedFills[i] = values[i] < minValue ? 0 : values[i] > maxValue ? paletteSize - 1 : Math.min(paletteSize - 1, Math.floor(paletteSize * (values[i] - minValue) / range));\n  }\n\n  return indexedFills;\n};","map":{"version":3,"names":["uPlot","DashboardCursorSync","DataFrameType","DataHoverClearEvent","DataHoverEvent","formattedValueToString","getValueFormat","incrRoundDn","incrRoundUp","AxisPlacement","ScaleDirection","ScaleDistribution","ScaleOrientation","UPlotConfigBuilder","isHeatmapCellsDense","readHeatmapRowsCustomMeta","HeatmapCellLayout","pointWithin","Quadtree","prepConfig","opts","dataRef","theme","eventBus","onhover","onclick","onzoom","isToolTipOpen","timeZone","getTimeRange","palette","cellGap","hideLE","hideGE","yAxisConfig","ySizeDivisor","sync","xScaleKey","xScaleUnit","pxRatio","devicePixelRatio","heatmapType","current","heatmap","meta","type","exemplarFillColor","visualization","getColorByName","exemplarColor","qt","hRect","builder","rect","addHook","u","root","querySelectorAll","forEach","el","Object","assign","style","borderRadius","border","background","over","addEventListener","e","isDragging","cursor","drag","_x","_y","xMin","posToVal","select","left","xMax","width","setSelect","top","height","min","max","scales","x","from","valueOf","to","queueMicrotask","setScale","r","payload","point","data","hoverEvent","pendingOnleave","idxs","i","length","sel","rowIndex","publish","clearTimeout","seriesIdx","dataIdx","pageX","pageY","setTimeout","undefined","bbox","clear","series","s","_paths","setMode","addScale","scaleKey","isTime","orientation","Horizontal","direction","Right","range","addAxis","placement","Bottom","yField","fields","yFieldConfig","config","custom","yScale","scaleDistribution","Linear","yAxisReverse","Boolean","reverse","isSparseHeatmap","HeatmapCells","shouldUseLogScale","isOrdianalY","yOrdinalDisplay","yScaleKey","Math","random","toString","substring","Vertical","Down","Up","distribution","Log","log","dataMin","dataMax","scaleMin","scaleMax","rangeLog","explicitMin","explicitMax","yExp","minExpanded","maxExpanded","log2","log10","minLog","maxLog","Number","isInteger","yLayout","le","ge","bucketSize","yBucketSize","dispY","display","show","axisPlacement","Hidden","Left","size","axisWidth","label","axisLabel","formatValue","v","splits","self","map","idx","unshift","push","filter","values","yMinDisplay","pathBuilder","heatmapPathsSparse","heatmapPathsDense","addSeries","facets","scale","auto","sorted","each","y","xSize","ySize","add","w","h","sidx","didx","gap","xAlign","xLayout","yAlign","disp","fill","countFacetIdx","valuesToFills","minValue","maxValue","index","heatmapPathsPoints","cx","cy","get","o","points","isHovered","Off","key","filters","pub","src","setSync","setCursor","CRISP_EDGES_GAP_MIN","Infinity","round","orient","dataX","dataY","scaleX","scaleY","valToPosX","valToPosY","xOff","yOff","xDim","yDim","moveTo","lineTo","arc","d","xs","ys","counts","dlen","fills","fillPalette","Set","fillPaths","color","Path2D","yBinQty","lastIndexOf","xBinQty","yBinIncr","xBinIncr","distr","abs","xOffset","yOffset","cys","slice","cxs","Array","fillPath","ctx","save","clip","p","fillStyle","restore","yVal","randSign","xMaxs","yMins","yMaxs","xOffs","Map","yOffs","yMin","yMax","has","set","xSizeUniform","find","xMaxPx","yMinPx","yMaxPx","boundedMinMax","paletteSize","indexedFills","floor"],"sources":["/home/soula/grafana/public/app/plugins/panel/heatmap/utils.ts"],"sourcesContent":["import { MutableRefObject, RefObject } from 'react';\nimport uPlot, { Cursor } from 'uplot';\n\nimport {\n  DashboardCursorSync,\n  DataFrameType,\n  DataHoverClearEvent,\n  DataHoverEvent,\n  DataHoverPayload,\n  EventBus,\n  formattedValueToString,\n  getValueFormat,\n  GrafanaTheme2,\n  incrRoundDn,\n  incrRoundUp,\n  TimeRange,\n} from '@grafana/data';\nimport { AxisPlacement, ScaleDirection, ScaleDistribution, ScaleOrientation } from '@grafana/schema';\nimport { UPlotConfigBuilder } from '@grafana/ui';\nimport { isHeatmapCellsDense, readHeatmapRowsCustomMeta } from 'app/features/transformers/calculateHeatmap/heatmap';\nimport { HeatmapCellLayout } from 'app/features/transformers/calculateHeatmap/models.gen';\n\nimport { pointWithin, Quadtree, Rect } from '../barchart/quadtree';\n\nimport { HeatmapData } from './fields';\nimport { PanelFieldConfig, YAxisConfig } from './models.gen';\n\ninterface PathbuilderOpts {\n  each: (u: uPlot, seriesIdx: number, dataIdx: number, lft: number, top: number, wid: number, hgt: number) => void;\n  gap?: number | null;\n  hideLE?: number;\n  hideGE?: number;\n  xAlign?: -1 | 0 | 1;\n  yAlign?: -1 | 0 | 1;\n  ySizeDivisor?: number;\n  disp: {\n    fill: {\n      values: (u: uPlot, seriesIndex: number) => number[];\n      index: Array<CanvasRenderingContext2D['fillStyle']>;\n    };\n  };\n}\n\ninterface PointsBuilderOpts {\n  each: (u: uPlot, seriesIdx: number, dataIdx: number, lft: number, top: number, wid: number, hgt: number) => void;\n}\n\nexport interface HeatmapHoverEvent {\n  seriesIdx: number;\n  dataIdx: number;\n  pageX: number;\n  pageY: number;\n}\n\nexport interface HeatmapZoomEvent {\n  xMin: number;\n  xMax: number;\n}\n\ninterface PrepConfigOpts {\n  dataRef: RefObject<HeatmapData>;\n  theme: GrafanaTheme2;\n  eventBus: EventBus;\n  onhover?: null | ((evt?: HeatmapHoverEvent | null) => void);\n  onclick?: null | ((evt?: Object) => void);\n  onzoom?: null | ((evt: HeatmapZoomEvent) => void);\n  isToolTipOpen: MutableRefObject<boolean>;\n  timeZone: string;\n  getTimeRange: () => TimeRange;\n  palette: string[];\n  exemplarColor: string;\n  cellGap?: number | null; // in css pixels\n  hideLE?: number;\n  hideGE?: number;\n  yAxisConfig: YAxisConfig;\n  ySizeDivisor?: number;\n  sync?: () => DashboardCursorSync;\n}\n\nexport function prepConfig(opts: PrepConfigOpts) {\n  const {\n    dataRef,\n    theme,\n    eventBus,\n    onhover,\n    onclick,\n    onzoom,\n    isToolTipOpen,\n    timeZone,\n    getTimeRange,\n    palette,\n    cellGap,\n    hideLE,\n    hideGE,\n    yAxisConfig,\n    ySizeDivisor,\n    sync,\n  } = opts;\n\n  const xScaleKey = 'x';\n  const xScaleUnit = 'time';\n\n  const pxRatio = devicePixelRatio;\n\n  let heatmapType = dataRef.current?.heatmap?.meta?.type;\n  const exemplarFillColor = theme.visualization.getColorByName(opts.exemplarColor);\n\n  let qt: Quadtree;\n  let hRect: Rect | null;\n\n  let builder = new UPlotConfigBuilder(timeZone);\n\n  let rect: DOMRect;\n\n  builder.addHook('init', (u) => {\n    u.root.querySelectorAll<HTMLElement>('.u-cursor-pt').forEach((el) => {\n      Object.assign(el.style, {\n        borderRadius: '0',\n        border: '1px solid white',\n        background: 'transparent',\n      });\n    });\n\n    onclick &&\n      u.over.addEventListener(\n        'mouseup',\n        (e) => {\n          // @ts-ignore\n          let isDragging: boolean = u.cursor.drag._x || u.cursor.drag._y;\n\n          if (!isDragging) {\n            onclick(e);\n          }\n        },\n        true\n      );\n  });\n\n  onzoom &&\n    builder.addHook('setSelect', (u) => {\n      onzoom({\n        xMin: u.posToVal(u.select.left, xScaleKey),\n        xMax: u.posToVal(u.select.left + u.select.width, xScaleKey),\n      });\n      u.setSelect({ left: 0, top: 0, width: 0, height: 0 }, false);\n    });\n\n  // this is a tmp hack because in mode: 2, uplot does not currently call scales.x.range() for setData() calls\n  // scales.x.range() typically reads back from drilled-down panelProps.timeRange via getTimeRange()\n  builder.addHook('setData', (u) => {\n    //let [min, max] = (u.scales!.x!.range! as uPlot.Range.Function)(u, 0, 100, xScaleKey);\n\n    let { min: xMin, max: xMax } = u.scales!.x;\n\n    let min = getTimeRange().from.valueOf();\n    let max = getTimeRange().to.valueOf();\n\n    if (xMin !== min || xMax !== max) {\n      queueMicrotask(() => {\n        u.setScale(xScaleKey, { min, max });\n      });\n    }\n  });\n\n  // rect of .u-over (grid area)\n  builder.addHook('syncRect', (u, r) => {\n    rect = r;\n  });\n\n  const payload: DataHoverPayload = {\n    point: {\n      [xScaleUnit]: null,\n    },\n    data: dataRef.current?.heatmap,\n  };\n  const hoverEvent = new DataHoverEvent(payload);\n\n  let pendingOnleave: ReturnType<typeof setTimeout> | 0;\n\n  onhover &&\n    builder.addHook('setLegend', (u) => {\n      if (u.cursor.idxs != null) {\n        for (let i = 0; i < u.cursor.idxs.length; i++) {\n          const sel = u.cursor.idxs[i];\n          if (sel != null) {\n            const { left, top } = u.cursor;\n            payload.rowIndex = sel;\n            payload.point[xScaleUnit] = u.posToVal(left!, xScaleKey);\n            eventBus.publish(hoverEvent);\n\n            if (!isToolTipOpen.current) {\n              if (pendingOnleave) {\n                clearTimeout(pendingOnleave);\n                pendingOnleave = 0;\n              }\n              onhover({\n                seriesIdx: i,\n                dataIdx: sel,\n                pageX: rect.left + left!,\n                pageY: rect.top + top!,\n              });\n            }\n            return;\n          }\n        }\n      }\n\n      if (!isToolTipOpen.current) {\n        // if tiles have gaps, reduce flashing / re-render (debounce onleave by 100ms)\n        if (!pendingOnleave) {\n          pendingOnleave = setTimeout(() => {\n            onhover(null);\n            payload.rowIndex = undefined;\n            payload.point[xScaleUnit] = null;\n            eventBus.publish(hoverEvent);\n          }, 100);\n        }\n      }\n    });\n\n  builder.addHook('drawClear', (u) => {\n    qt = qt || new Quadtree(0, 0, u.bbox.width, u.bbox.height);\n\n    qt.clear();\n\n    // force-clear the path cache to cause drawBars() to rebuild new quadtree\n    u.series.forEach((s, i) => {\n      if (i > 0) {\n        // @ts-ignore\n        s._paths = null;\n      }\n    });\n  });\n\n  builder.setMode(2);\n\n  builder.addScale({\n    scaleKey: xScaleKey,\n    isTime: true,\n    orientation: ScaleOrientation.Horizontal,\n    direction: ScaleDirection.Right,\n    // TODO: expand by x bucket size and layout\n    range: () => {\n      return [getTimeRange().from.valueOf(), getTimeRange().to.valueOf()];\n    },\n  });\n\n  builder.addAxis({\n    scaleKey: xScaleKey,\n    placement: AxisPlacement.Bottom,\n    isTime: true,\n    theme: theme,\n  });\n\n  const yField = dataRef.current?.heatmap?.fields[1]!;\n  if (!yField) {\n    return builder; // early abort (avoids error)\n  }\n\n  // eslint-ignore @typescript-eslint/no-explicit-any\n  const yFieldConfig = yField.config?.custom as PanelFieldConfig | undefined;\n  const yScale = yFieldConfig?.scaleDistribution ?? { type: ScaleDistribution.Linear };\n  const yAxisReverse = Boolean(yAxisConfig.reverse);\n  const isSparseHeatmap = heatmapType === DataFrameType.HeatmapCells && !isHeatmapCellsDense(dataRef.current?.heatmap!);\n  const shouldUseLogScale = yScale.type !== ScaleDistribution.Linear || isSparseHeatmap;\n  const isOrdianalY = readHeatmapRowsCustomMeta(dataRef.current?.heatmap).yOrdinalDisplay != null;\n\n  // random to prevent syncing y in other heatmaps\n  // TODO: try to match TimeSeries y keygen algo to sync with TimeSeries panels (when not isOrdianalY)\n  const yScaleKey = 'y_' + (Math.random() + 1).toString(36).substring(7);\n\n  builder.addScale({\n    scaleKey: yScaleKey,\n    isTime: false,\n    // distribution: ScaleDistribution.Ordinal, // does not work with facets/scatter yet\n    orientation: ScaleOrientation.Vertical,\n    direction: yAxisReverse ? ScaleDirection.Down : ScaleDirection.Up,\n    // should be tweakable manually\n    distribution: shouldUseLogScale ? ScaleDistribution.Log : ScaleDistribution.Linear,\n    log: yScale.log ?? 2,\n    range:\n      // sparse already accounts for le/ge by explicit yMin & yMax cell bounds, so no need to expand y range\n      isSparseHeatmap\n        ? (u, dataMin, dataMax) => {\n            let scaleMin: number | null, scaleMax: number | null;\n\n            [scaleMin, scaleMax] = shouldUseLogScale\n              ? uPlot.rangeLog(dataMin, dataMax, (yScale.log ?? 2) as unknown as uPlot.Scale.LogBase, true)\n              : [dataMin, dataMax];\n\n            if (shouldUseLogScale && !isOrdianalY) {\n              let { min: explicitMin, max: explicitMax } = yAxisConfig;\n\n              // guard against <= 0\n              if (explicitMin != null && explicitMin > 0) {\n                scaleMin = explicitMin;\n              }\n\n              if (explicitMax != null && explicitMax > 0) {\n                scaleMax = explicitMax;\n              }\n            }\n\n            return [scaleMin, scaleMax];\n          }\n        : // dense and ordinal only have one of yMin|yMax|y, so expand range by one cell in the direction of le/ge/unknown\n          (u, dataMin, dataMax) => {\n            let { min: explicitMin, max: explicitMax } = yAxisConfig;\n\n            // logarithmic expansion\n            if (shouldUseLogScale) {\n              let yExp = u.scales[yScaleKey].log!;\n\n              let minExpanded = false;\n              let maxExpanded = false;\n\n              if (ySizeDivisor !== 1) {\n                let log = yExp === 2 ? Math.log2 : Math.log10;\n\n                let minLog = log(dataMin);\n                let maxLog = log(dataMax);\n\n                if (!Number.isInteger(minLog)) {\n                  dataMin = yExp ** incrRoundDn(minLog, 1);\n                  minExpanded = true;\n                }\n\n                if (!Number.isInteger(maxLog)) {\n                  dataMax = yExp ** incrRoundUp(maxLog, 1);\n                  maxExpanded = true;\n                }\n              }\n\n              if (dataRef.current?.yLayout === HeatmapCellLayout.le) {\n                if (!minExpanded) {\n                  dataMin /= yExp;\n                }\n              } else if (dataRef.current?.yLayout === HeatmapCellLayout.ge) {\n                if (!maxExpanded) {\n                  dataMax *= yExp;\n                }\n              } else {\n                dataMin /= yExp / 2;\n                dataMax *= yExp / 2;\n              }\n\n              if (!isOrdianalY) {\n                // guard against <= 0\n                if (explicitMin != null && explicitMin > 0) {\n                  dataMin = explicitMin;\n                }\n\n                if (explicitMax != null && explicitMax > 0) {\n                  dataMax = explicitMax;\n                }\n              }\n            }\n            // linear expansion\n            else {\n              let bucketSize = dataRef.current?.yBucketSize;\n\n              if (bucketSize === 0) {\n                bucketSize = 1;\n              }\n\n              if (bucketSize) {\n                if (dataRef.current?.yLayout === HeatmapCellLayout.le) {\n                  dataMin -= bucketSize!;\n                } else if (dataRef.current?.yLayout === HeatmapCellLayout.ge) {\n                  dataMax += bucketSize!;\n                } else {\n                  dataMin -= bucketSize! / 2;\n                  dataMax += bucketSize! / 2;\n                }\n              } else {\n                // how to expand scale range if inferred non-regular or log buckets?\n              }\n\n              if (!isOrdianalY) {\n                dataMin = explicitMin ?? dataMin;\n                dataMax = explicitMax ?? dataMax;\n              }\n            }\n\n            return [dataMin, dataMax];\n          },\n  });\n\n  const dispY = yField.display ?? getValueFormat('short');\n\n  builder.addAxis({\n    scaleKey: yScaleKey,\n    show: yAxisConfig.axisPlacement !== AxisPlacement.Hidden,\n    placement: yAxisConfig.axisPlacement || AxisPlacement.Left,\n    size: yAxisConfig.axisWidth || null,\n    label: yAxisConfig.axisLabel,\n    theme: theme,\n    formatValue: (v: number) => formattedValueToString(dispY(v)),\n    splits: isOrdianalY\n      ? (self: uPlot) => {\n          const meta = readHeatmapRowsCustomMeta(dataRef.current?.heatmap);\n          if (!meta.yOrdinalDisplay) {\n            return [0, 1]; //?\n          }\n          let splits = meta.yOrdinalDisplay.map((v, idx) => idx);\n\n          switch (dataRef.current?.yLayout) {\n            case HeatmapCellLayout.le:\n              splits.unshift(-1);\n              break;\n            case HeatmapCellLayout.ge:\n              splits.push(splits.length);\n              break;\n          }\n\n          // Skip labels when the height is too small\n          if (self.height < 60) {\n            splits = [splits[0], splits[splits.length - 1]];\n          } else {\n            while (splits.length > 3 && (self.height - 15) / splits.length < 10) {\n              splits = splits.filter((v, idx) => idx % 2 === 0); // remove half the items\n            }\n          }\n          return splits;\n        }\n      : undefined,\n    values: isOrdianalY\n      ? (self: uPlot, splits) => {\n          const meta = readHeatmapRowsCustomMeta(dataRef.current?.heatmap);\n          if (meta.yOrdinalDisplay) {\n            return splits.map((v) =>\n              v < 0\n                ? meta.yMinDisplay ?? '' // Check prometheus style labels\n                : meta.yOrdinalDisplay[v] ?? ''\n            );\n          }\n          return splits;\n        }\n      : undefined,\n  });\n\n  const pathBuilder = isSparseHeatmap ? heatmapPathsSparse : heatmapPathsDense;\n\n  // heatmap layer\n  builder.addSeries({\n    facets: [\n      {\n        scale: xScaleKey,\n        auto: true,\n        sorted: 1,\n      },\n      {\n        scale: yScaleKey,\n        auto: true,\n      },\n    ],\n    pathBuilder: pathBuilder({\n      each: (u, seriesIdx, dataIdx, x, y, xSize, ySize) => {\n        qt.add({\n          x: x - u.bbox.left,\n          y: y - u.bbox.top,\n          w: xSize,\n          h: ySize,\n          sidx: seriesIdx,\n          didx: dataIdx,\n        });\n      },\n      gap: cellGap,\n      hideLE,\n      hideGE,\n      xAlign:\n        dataRef.current?.xLayout === HeatmapCellLayout.le\n          ? -1\n          : dataRef.current?.xLayout === HeatmapCellLayout.ge\n          ? 1\n          : 0,\n      yAlign: ((dataRef.current?.yLayout === HeatmapCellLayout.le\n        ? -1\n        : dataRef.current?.yLayout === HeatmapCellLayout.ge\n        ? 1\n        : 0) * (yAxisReverse ? -1 : 1)) as -1 | 0 | 1,\n      ySizeDivisor,\n      disp: {\n        fill: {\n          values: (u, seriesIdx) => {\n            let countFacetIdx = !isSparseHeatmap ? 2 : 3;\n            return valuesToFills(\n              u.data[seriesIdx][countFacetIdx] as unknown as number[],\n              palette,\n              dataRef.current?.minValue!,\n              dataRef.current?.maxValue!\n            );\n          },\n          index: palette,\n        },\n      },\n    }),\n    theme,\n    scaleKey: '', // facets' scales used (above)\n  });\n\n  // exemplars layer\n  builder.addSeries({\n    facets: [\n      {\n        scale: xScaleKey,\n        auto: true,\n        sorted: 1,\n      },\n      {\n        scale: yScaleKey,\n        auto: true,\n      },\n    ],\n    pathBuilder: heatmapPathsPoints(\n      {\n        each: (u, seriesIdx, dataIdx, x, y, xSize, ySize) => {\n          qt.add({\n            x: x - u.bbox.left,\n            y: y - u.bbox.top,\n            w: xSize,\n            h: ySize,\n            sidx: seriesIdx,\n            didx: dataIdx,\n          });\n        },\n      },\n      exemplarFillColor\n    ),\n    theme,\n    scaleKey: '', // facets' scales used (above)\n  });\n\n  const cursor: Cursor = {\n    drag: {\n      x: true,\n      y: false,\n      setScale: false,\n    },\n    dataIdx: (u, seriesIdx) => {\n      if (seriesIdx === 1) {\n        hRect = null;\n\n        let cx = u.cursor.left! * pxRatio;\n        let cy = u.cursor.top! * pxRatio;\n\n        qt.get(cx, cy, 1, 1, (o) => {\n          if (pointWithin(cx, cy, o.x, o.y, o.x + o.w, o.y + o.h)) {\n            hRect = o;\n          }\n        });\n      }\n\n      return hRect && seriesIdx === hRect.sidx ? hRect.didx : null;\n    },\n    points: {\n      fill: 'rgba(255,255,255, 0.3)',\n      bbox: (u, seriesIdx) => {\n        let isHovered = hRect && seriesIdx === hRect.sidx;\n\n        return {\n          left: isHovered ? hRect!.x / pxRatio : -10,\n          top: isHovered ? hRect!.y / pxRatio : -10,\n          width: isHovered ? hRect!.w / pxRatio : 0,\n          height: isHovered ? hRect!.h / pxRatio : 0,\n        };\n      },\n    },\n  };\n\n  if (sync && sync() !== DashboardCursorSync.Off) {\n    cursor.sync = {\n      key: '__global_',\n      scales: [xScaleKey, yScaleKey],\n      filters: {\n        pub: (type: string, src: uPlot, x: number, y: number, w: number, h: number, dataIdx: number) => {\n          if (x < 0) {\n            payload.point[xScaleUnit] = null;\n            eventBus.publish(new DataHoverClearEvent());\n          } else {\n            payload.point[xScaleUnit] = src.posToVal(x, xScaleKey);\n            eventBus.publish(hoverEvent);\n          }\n\n          return true;\n        },\n      },\n    };\n\n    builder.setSync();\n  }\n\n  builder.setCursor(cursor);\n\n  return builder;\n}\n\nconst CRISP_EDGES_GAP_MIN = 4;\n\nexport function heatmapPathsDense(opts: PathbuilderOpts) {\n  const { disp, each, gap = 1, hideLE = -Infinity, hideGE = Infinity, xAlign = 1, yAlign = 1, ySizeDivisor = 1 } = opts;\n\n  const pxRatio = devicePixelRatio;\n\n  const round = gap! >= CRISP_EDGES_GAP_MIN ? Math.round : (v: number) => v;\n\n  const cellGap = Math.round(gap! * pxRatio);\n\n  return (u: uPlot, seriesIdx: number) => {\n    uPlot.orient(\n      u,\n      seriesIdx,\n      (\n        series,\n        dataX,\n        dataY,\n        scaleX,\n        scaleY,\n        valToPosX,\n        valToPosY,\n        xOff,\n        yOff,\n        xDim,\n        yDim,\n        moveTo,\n        lineTo,\n        rect,\n        arc\n      ) => {\n        let d = u.data[seriesIdx];\n        const xs = d[0] as unknown as number[];\n        const ys = d[1] as unknown as number[];\n        const counts = d[2] as unknown as number[];\n        const dlen = xs.length;\n\n        // fill colors are mapped from interpolating densities / counts along some gradient\n        // (should be quantized to 64 colors/levels max. e.g. 16)\n        let fills = disp.fill.values(u, seriesIdx);\n        let fillPalette = disp.fill.index ?? [...new Set(fills)];\n\n        let fillPaths = fillPalette.map((color) => new Path2D());\n\n        // detect x and y bin qtys by detecting layout repetition in x & y data\n        let yBinQty = dlen - ys.lastIndexOf(ys[0]);\n        let xBinQty = dlen / yBinQty;\n        let yBinIncr = ys[1] - ys[0] || scaleY.max! - scaleY.min!;\n        let xBinIncr = xs[yBinQty] - xs[0];\n\n        // uniform tile sizes based on zoom level\n        let xSize: number;\n        let ySize: number;\n\n        if (scaleX.distr === 3) {\n          xSize = Math.abs(valToPosX(xs[0] * scaleX.log!, scaleX, xDim, xOff) - valToPosX(xs[0], scaleX, xDim, xOff));\n        } else {\n          xSize = Math.abs(valToPosX(xBinIncr, scaleX, xDim, xOff) - valToPosX(0, scaleX, xDim, xOff));\n        }\n\n        if (scaleY.distr === 3) {\n          ySize =\n            Math.abs(valToPosY(ys[0] * scaleY.log!, scaleY, yDim, yOff) - valToPosY(ys[0], scaleY, yDim, yOff)) /\n            ySizeDivisor;\n        } else {\n          ySize = Math.abs(valToPosY(yBinIncr, scaleY, yDim, yOff) - valToPosY(0, scaleY, yDim, yOff)) / ySizeDivisor;\n        }\n\n        // clamp min tile size to 1px\n        xSize = Math.max(1, round(xSize - cellGap));\n        ySize = Math.max(1, round(ySize - cellGap));\n\n        // bucket agg direction\n        // let xCeil = false;\n        // let yCeil = false;\n\n        let xOffset = xAlign === -1 ? -xSize : xAlign === 0 ? -xSize / 2 : 0;\n        let yOffset = yAlign === 1 ? -ySize : yAlign === 0 ? -ySize / 2 : 0;\n\n        // pre-compute x and y offsets\n        let cys = ys.slice(0, yBinQty).map((y) => round(valToPosY(y, scaleY, yDim, yOff) + yOffset));\n        let cxs = Array.from({ length: xBinQty }, (v, i) =>\n          round(valToPosX(xs[i * yBinQty], scaleX, xDim, xOff) + xOffset)\n        );\n\n        for (let i = 0; i < dlen; i++) {\n          if (counts[i] > hideLE && counts[i] < hideGE) {\n            let cx = cxs[~~(i / yBinQty)];\n            let cy = cys[i % yBinQty];\n\n            let fillPath = fillPaths[fills[i]];\n\n            rect(fillPath, cx, cy, xSize, ySize);\n\n            each(u, 1, i, cx, cy, xSize, ySize);\n          }\n        }\n\n        u.ctx.save();\n        //\tu.ctx.globalAlpha = 0.8;\n        u.ctx.rect(u.bbox.left, u.bbox.top, u.bbox.width, u.bbox.height);\n        u.ctx.clip();\n        fillPaths.forEach((p, i) => {\n          u.ctx.fillStyle = fillPalette[i];\n          u.ctx.fill(p);\n        });\n        u.ctx.restore();\n\n        return null;\n      }\n    );\n\n    return null;\n  };\n}\n\nexport function heatmapPathsPoints(opts: PointsBuilderOpts, exemplarColor: string) {\n  return (u: uPlot, seriesIdx: number) => {\n    uPlot.orient(\n      u,\n      seriesIdx,\n      (\n        series,\n        dataX,\n        dataY,\n        scaleX,\n        scaleY,\n        valToPosX,\n        valToPosY,\n        xOff,\n        yOff,\n        xDim,\n        yDim,\n        moveTo,\n        lineTo,\n        rect,\n        arc\n      ) => {\n        //console.time('heatmapPathsSparse');\n\n        [dataX, dataY] = dataY as unknown as number[][];\n\n        let points = new Path2D();\n        let fillPaths = [points];\n        let fillPalette = [exemplarColor ?? 'rgba(255,0,255,0.7)'];\n\n        for (let i = 0; i < dataX.length; i++) {\n          let yVal = dataY[i]!;\n          yVal -= 0.5; // center vertically in bucket (when tiles are le)\n          // y-randomize vertically to distribute exemplars in same bucket at same time\n          let randSign = Math.round(Math.random()) * 2 - 1;\n          yVal += randSign * 0.5 * Math.random();\n\n          let x = valToPosX(dataX[i], scaleX, xDim, xOff);\n          let y = valToPosY(yVal, scaleY, yDim, yOff);\n          let w = 8;\n          let h = 8;\n\n          rect(points, x - w / 2, y - h / 2, w, h);\n\n          opts.each(u, seriesIdx, i, x - w / 2, y - h / 2, w, h);\n        }\n\n        u.ctx.save();\n        u.ctx.rect(u.bbox.left, u.bbox.top, u.bbox.width, u.bbox.height);\n        u.ctx.clip();\n        fillPaths.forEach((p, i) => {\n          u.ctx.fillStyle = fillPalette[i];\n          u.ctx.fill(p);\n        });\n        u.ctx.restore();\n      }\n    );\n\n    return null;\n  };\n}\n// accepts xMax, yMin, yMax, count\n// xbinsize? x tile sizes are uniform?\nexport function heatmapPathsSparse(opts: PathbuilderOpts) {\n  const { disp, each, gap = 1, hideLE = -Infinity, hideGE = Infinity } = opts;\n\n  const pxRatio = devicePixelRatio;\n\n  const round = gap! >= CRISP_EDGES_GAP_MIN ? Math.round : (v: number) => v;\n\n  const cellGap = Math.round(gap! * pxRatio);\n\n  return (u: uPlot, seriesIdx: number) => {\n    uPlot.orient(\n      u,\n      seriesIdx,\n      (\n        series,\n        dataX,\n        dataY,\n        scaleX,\n        scaleY,\n        valToPosX,\n        valToPosY,\n        xOff,\n        yOff,\n        xDim,\n        yDim,\n        moveTo,\n        lineTo,\n        rect,\n        arc\n      ) => {\n        //console.time('heatmapPathsSparse');\n\n        let d = u.data[seriesIdx];\n        const xMaxs = d[0] as unknown as number[]; // xMax, do we get interval?\n        const yMins = d[1] as unknown as number[];\n        const yMaxs = d[2] as unknown as number[];\n        const counts = d[3] as unknown as number[];\n        const dlen = xMaxs.length;\n\n        // fill colors are mapped from interpolating densities / counts along some gradient\n        // (should be quantized to 64 colors/levels max. e.g. 16)\n        let fills = disp.fill.values(u, seriesIdx);\n        let fillPalette = disp.fill.index ?? [...new Set(fills)];\n\n        let fillPaths = fillPalette.map((color) => new Path2D());\n\n        // cache all tile bounds\n        let xOffs = new Map();\n        let yOffs = new Map();\n\n        for (let i = 0; i < xMaxs.length; i++) {\n          let xMax = xMaxs[i];\n          let yMin = yMins[i];\n          let yMax = yMaxs[i];\n\n          if (!xOffs.has(xMax)) {\n            xOffs.set(xMax, round(valToPosX(xMax, scaleX, xDim, xOff)));\n          }\n\n          if (!yOffs.has(yMin)) {\n            yOffs.set(yMin, round(valToPosY(yMin, scaleY, yDim, yOff)));\n          }\n\n          if (!yOffs.has(yMax)) {\n            yOffs.set(yMax, round(valToPosY(yMax, scaleY, yDim, yOff)));\n          }\n        }\n\n        // uniform x size (interval, step)\n        let xSizeUniform = xOffs.get(xMaxs.find((v) => v !== xMaxs[0])) - xOffs.get(xMaxs[0]);\n\n        for (let i = 0; i < dlen; i++) {\n          if (counts[i] <= hideLE || counts[i] >= hideGE) {\n            continue;\n          }\n\n          let xMax = xMaxs[i];\n          let yMin = yMins[i];\n          let yMax = yMaxs[i];\n\n          let xMaxPx = xOffs.get(xMax); // xSize is from interval, or inferred delta?\n          let yMinPx = yOffs.get(yMin);\n          let yMaxPx = yOffs.get(yMax);\n\n          let xSize = xSizeUniform;\n          let ySize = yMinPx - yMaxPx;\n\n          // clamp min tile size to 1px\n          xSize = Math.max(1, xSize - cellGap);\n          ySize = Math.max(1, ySize - cellGap);\n\n          let x = xMaxPx;\n          let y = yMinPx;\n\n          let fillPath = fillPaths[fills[i]];\n\n          rect(fillPath, x, y, xSize, ySize);\n\n          each(u, 1, i, x, y, xSize, ySize);\n        }\n\n        u.ctx.save();\n        //\tu.ctx.globalAlpha = 0.8;\n        u.ctx.rect(u.bbox.left, u.bbox.top, u.bbox.width, u.bbox.height);\n        u.ctx.clip();\n        fillPaths.forEach((p, i) => {\n          u.ctx.fillStyle = fillPalette[i];\n          u.ctx.fill(p);\n        });\n        u.ctx.restore();\n\n        //console.timeEnd('heatmapPathsSparse');\n      }\n    );\n\n    return null;\n  };\n}\n\nexport const boundedMinMax = (\n  values: number[],\n  minValue?: number,\n  maxValue?: number,\n  hideLE = -Infinity,\n  hideGE = Infinity\n) => {\n  if (minValue == null) {\n    minValue = Infinity;\n\n    for (let i = 0; i < values.length; i++) {\n      if (values[i] > hideLE && values[i] < hideGE) {\n        minValue = Math.min(minValue, values[i]);\n      }\n    }\n  }\n\n  if (maxValue == null) {\n    maxValue = -Infinity;\n\n    for (let i = 0; i < values.length; i++) {\n      if (values[i] > hideLE && values[i] < hideGE) {\n        maxValue = Math.max(maxValue, values[i]);\n      }\n    }\n  }\n\n  return [minValue, maxValue];\n};\n\nexport const valuesToFills = (values: number[], palette: string[], minValue: number, maxValue: number) => {\n  let range = Math.max(maxValue - minValue, 1);\n\n  let paletteSize = palette.length;\n\n  let indexedFills = Array(values.length);\n\n  for (let i = 0; i < values.length; i++) {\n    indexedFills[i] =\n      values[i] < minValue\n        ? 0\n        : values[i] > maxValue\n        ? paletteSize - 1\n        : Math.min(paletteSize - 1, Math.floor((paletteSize * (values[i] - minValue)) / range));\n  }\n\n  return indexedFills;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}