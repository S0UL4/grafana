{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { find, map } from 'lodash';\nexport default class PostgresQueryModel {\n  /** @ngInject */\n  constructor(target, templateSrv, scopedVars) {\n    _defineProperty(this, \"target\", void 0);\n\n    _defineProperty(this, \"templateSrv\", void 0);\n\n    _defineProperty(this, \"scopedVars\", void 0);\n\n    this.target = target;\n    this.templateSrv = templateSrv;\n    this.scopedVars = scopedVars;\n    target.format = target.format || 'time_series';\n    target.timeColumn = target.timeColumn || 'time';\n    target.metricColumn = target.metricColumn || 'none';\n    target.group = target.group || [];\n    target.where = target.where || [{\n      type: 'macro',\n      name: '$__timeFilter',\n      params: []\n    }];\n    target.select = target.select || [[{\n      type: 'column',\n      params: ['value']\n    }]]; // handle pre query gui panels gracefully\n\n    if (!('rawQuery' in this.target)) {\n      if ('rawSql' in target) {\n        // pre query gui panel\n        target.rawQuery = true;\n      } else {\n        // new panel\n        target.rawQuery = false;\n      }\n    } // give interpolateQueryStr access to this\n\n\n    this.interpolateQueryStr = this.interpolateQueryStr.bind(this);\n  } // remove identifier quoting from identifier to use in metadata queries\n\n\n  unquoteIdentifier(value) {\n    if (value[0] === '\"' && value[value.length - 1] === '\"') {\n      return value.substring(1, value.length - 1).replace(/\"\"/g, '\"');\n    } else {\n      return value;\n    }\n  }\n\n  quoteIdentifier(value) {\n    return '\"' + String(value).replace(/\"/g, '\"\"') + '\"';\n  }\n\n  quoteLiteral(value) {\n    return \"'\" + String(value).replace(/'/g, \"''\") + \"'\";\n  }\n\n  escapeLiteral(value) {\n    return String(value).replace(/'/g, \"''\");\n  }\n\n  hasTimeGroup() {\n    return find(this.target.group, g => g.type === 'time');\n  }\n\n  hasMetricColumn() {\n    return this.target.metricColumn !== 'none';\n  }\n\n  interpolateQueryStr(value, variable, defaultFormatFn) {\n    // if no multi or include all do not regexEscape\n    if (!variable.multi && !variable.includeAll) {\n      return this.escapeLiteral(value);\n    }\n\n    if (typeof value === 'string') {\n      return this.quoteLiteral(value);\n    }\n\n    const escapedValues = map(value, this.quoteLiteral);\n    return escapedValues.join(',');\n  }\n\n  render(interpolate) {\n    const target = this.target; // new query with no table set yet\n\n    if (!this.target.rawQuery && !('table' in this.target)) {\n      return '';\n    }\n\n    if (!target.rawQuery) {\n      target.rawSql = this.buildQuery();\n    }\n\n    if (interpolate) {\n      return this.templateSrv.replace(target.rawSql, this.scopedVars, this.interpolateQueryStr);\n    } else {\n      return target.rawSql;\n    }\n  }\n\n  hasUnixEpochTimecolumn() {\n    return ['int4', 'int8', 'float4', 'float8', 'numeric'].indexOf(this.target.timeColumnType) > -1;\n  }\n\n  buildTimeColumn(alias = true) {\n    const timeGroup = this.hasTimeGroup();\n    let query;\n    let macro = '$__timeGroup';\n\n    if (timeGroup) {\n      let args;\n\n      if (timeGroup.params.length > 1 && timeGroup.params[1] !== 'none') {\n        args = timeGroup.params.join(',');\n      } else {\n        args = timeGroup.params[0];\n      }\n\n      if (this.hasUnixEpochTimecolumn()) {\n        macro = '$__unixEpochGroup';\n      }\n\n      if (alias) {\n        macro += 'Alias';\n      }\n\n      query = macro + '(' + this.target.timeColumn + ',' + args + ')';\n    } else {\n      query = this.target.timeColumn;\n\n      if (alias) {\n        query += ' AS \"time\"';\n      }\n    }\n\n    return query;\n  }\n\n  buildMetricColumn() {\n    if (this.hasMetricColumn()) {\n      return this.target.metricColumn + ' AS metric';\n    }\n\n    return '';\n  }\n\n  buildValueColumns() {\n    let query = '';\n\n    for (const column of this.target.select) {\n      query += ',\\n  ' + this.buildValueColumn(column);\n    }\n\n    return query;\n  }\n\n  buildValueColumn(column) {\n    let query = '';\n    const columnName = find(column, g => g.type === 'column');\n    query = columnName.params[0];\n    const aggregate = find(column, g => g.type === 'aggregate' || g.type === 'percentile');\n    const windows = find(column, g => g.type === 'window' || g.type === 'moving_window');\n\n    if (aggregate) {\n      const func = aggregate.params[0];\n\n      switch (aggregate.type) {\n        case 'aggregate':\n          if (func === 'first' || func === 'last') {\n            query = func + '(' + query + ',' + this.target.timeColumn + ')';\n          } else {\n            query = func + '(' + query + ')';\n          }\n\n          break;\n\n        case 'percentile':\n          query = func + '(' + aggregate.params[1] + ') WITHIN GROUP (ORDER BY ' + query + ')';\n          break;\n      }\n    }\n\n    if (windows) {\n      const overParts = [];\n\n      if (this.hasMetricColumn()) {\n        overParts.push('PARTITION BY ' + this.target.metricColumn);\n      }\n\n      overParts.push('ORDER BY ' + this.buildTimeColumn(false));\n      const over = overParts.join(' ');\n      let curr;\n      let prev;\n\n      switch (windows.type) {\n        case 'window':\n          switch (windows.params[0]) {\n            case 'delta':\n              curr = query;\n              prev = 'lag(' + curr + ') OVER (' + over + ')';\n              query = curr + ' - ' + prev;\n              break;\n\n            case 'increase':\n              curr = query;\n              prev = 'lag(' + curr + ') OVER (' + over + ')';\n              query = '(CASE WHEN ' + curr + ' >= ' + prev + ' THEN ' + curr + ' - ' + prev;\n              query += ' WHEN ' + prev + ' IS NULL THEN NULL ELSE ' + curr + ' END)';\n              break;\n\n            case 'rate':\n              let timeColumn = this.target.timeColumn;\n\n              if (aggregate) {\n                timeColumn = 'min(' + timeColumn + ')';\n              }\n\n              curr = query;\n              prev = 'lag(' + curr + ') OVER (' + over + ')';\n              query = '(CASE WHEN ' + curr + ' >= ' + prev + ' THEN ' + curr + ' - ' + prev;\n              query += ' WHEN ' + prev + ' IS NULL THEN NULL ELSE ' + curr + ' END)';\n              query += '/extract(epoch from ' + timeColumn + ' - lag(' + timeColumn + ') OVER (' + over + '))';\n              break;\n\n            default:\n              query = windows.params[0] + '(' + query + ') OVER (' + over + ')';\n              break;\n          }\n\n          break;\n\n        case 'moving_window':\n          query = windows.params[0] + '(' + query + ') OVER (' + over + ' ROWS ' + windows.params[1] + ' PRECEDING)';\n          break;\n      }\n    }\n\n    const alias = find(column, g => g.type === 'alias');\n\n    if (alias) {\n      query += ' AS ' + this.quoteIdentifier(alias.params[0]);\n    }\n\n    return query;\n  }\n\n  buildWhereClause() {\n    let query = '';\n    const conditions = map(this.target.where, (tag, index) => {\n      switch (tag.type) {\n        case 'macro':\n          return tag.name + '(' + this.target.timeColumn + ')';\n          break;\n\n        case 'expression':\n          return tag.params.join(' ');\n          break;\n      }\n    });\n\n    if (conditions.length > 0) {\n      query = '\\nWHERE\\n  ' + conditions.join(' AND\\n  ');\n    }\n\n    return query;\n  }\n\n  buildGroupClause() {\n    let query = '';\n    let groupSection = '';\n\n    for (let i = 0; i < this.target.group.length; i++) {\n      const part = this.target.group[i];\n\n      if (i > 0) {\n        groupSection += ', ';\n      }\n\n      if (part.type === 'time') {\n        groupSection += '1';\n      } else {\n        groupSection += part.params[0];\n      }\n    }\n\n    if (groupSection.length) {\n      query = '\\nGROUP BY ' + groupSection;\n\n      if (this.hasMetricColumn()) {\n        query += ',2';\n      }\n    }\n\n    return query;\n  }\n\n  buildQuery() {\n    let query = 'SELECT';\n    query += '\\n  ' + this.buildTimeColumn();\n\n    if (this.hasMetricColumn()) {\n      query += ',\\n  ' + this.buildMetricColumn();\n    }\n\n    query += this.buildValueColumns();\n    query += '\\nFROM ' + this.target.table;\n    query += this.buildWhereClause();\n    query += this.buildGroupClause();\n    query += '\\nORDER BY 1';\n\n    if (this.hasMetricColumn()) {\n      query += ',2';\n    }\n\n    return query;\n  }\n\n}\nPostgresQueryModel.$inject = [\"target\", \"templateSrv\", \"scopedVars\"];","map":{"version":3,"names":["find","map","PostgresQueryModel","constructor","target","templateSrv","scopedVars","format","timeColumn","metricColumn","group","where","type","name","params","select","rawQuery","interpolateQueryStr","bind","unquoteIdentifier","value","length","substring","replace","quoteIdentifier","String","quoteLiteral","escapeLiteral","hasTimeGroup","g","hasMetricColumn","variable","defaultFormatFn","multi","includeAll","escapedValues","join","render","interpolate","rawSql","buildQuery","hasUnixEpochTimecolumn","indexOf","timeColumnType","buildTimeColumn","alias","timeGroup","query","macro","args","buildMetricColumn","buildValueColumns","column","buildValueColumn","columnName","aggregate","windows","func","overParts","push","over","curr","prev","buildWhereClause","conditions","tag","index","buildGroupClause","groupSection","i","part","table"],"sources":["/home/soula/grafana/public/app/plugins/datasource/postgres/postgres_query_model.ts"],"sourcesContent":["import { find, map } from 'lodash';\n\nimport { ScopedVars } from '@grafana/data';\nimport { TemplateSrv } from '@grafana/runtime';\n\nexport default class PostgresQueryModel {\n  target: any;\n  templateSrv: any;\n  scopedVars: any;\n\n  /** @ngInject */\n  constructor(target: any, templateSrv?: TemplateSrv, scopedVars?: ScopedVars) {\n    this.target = target;\n    this.templateSrv = templateSrv;\n    this.scopedVars = scopedVars;\n\n    target.format = target.format || 'time_series';\n    target.timeColumn = target.timeColumn || 'time';\n    target.metricColumn = target.metricColumn || 'none';\n\n    target.group = target.group || [];\n    target.where = target.where || [{ type: 'macro', name: '$__timeFilter', params: [] }];\n    target.select = target.select || [[{ type: 'column', params: ['value'] }]];\n\n    // handle pre query gui panels gracefully\n    if (!('rawQuery' in this.target)) {\n      if ('rawSql' in target) {\n        // pre query gui panel\n        target.rawQuery = true;\n      } else {\n        // new panel\n        target.rawQuery = false;\n      }\n    }\n\n    // give interpolateQueryStr access to this\n    this.interpolateQueryStr = this.interpolateQueryStr.bind(this);\n  }\n\n  // remove identifier quoting from identifier to use in metadata queries\n  unquoteIdentifier(value: string) {\n    if (value[0] === '\"' && value[value.length - 1] === '\"') {\n      return value.substring(1, value.length - 1).replace(/\"\"/g, '\"');\n    } else {\n      return value;\n    }\n  }\n\n  quoteIdentifier(value: any) {\n    return '\"' + String(value).replace(/\"/g, '\"\"') + '\"';\n  }\n\n  quoteLiteral(value: any) {\n    return \"'\" + String(value).replace(/'/g, \"''\") + \"'\";\n  }\n\n  escapeLiteral(value: any) {\n    return String(value).replace(/'/g, \"''\");\n  }\n\n  hasTimeGroup() {\n    return find(this.target.group, (g: any) => g.type === 'time');\n  }\n\n  hasMetricColumn() {\n    return this.target.metricColumn !== 'none';\n  }\n\n  interpolateQueryStr(value: any, variable: { multi: any; includeAll: any }, defaultFormatFn: any) {\n    // if no multi or include all do not regexEscape\n    if (!variable.multi && !variable.includeAll) {\n      return this.escapeLiteral(value);\n    }\n\n    if (typeof value === 'string') {\n      return this.quoteLiteral(value);\n    }\n\n    const escapedValues = map(value, this.quoteLiteral);\n    return escapedValues.join(',');\n  }\n\n  render(interpolate?: any) {\n    const target = this.target;\n\n    // new query with no table set yet\n    if (!this.target.rawQuery && !('table' in this.target)) {\n      return '';\n    }\n\n    if (!target.rawQuery) {\n      target.rawSql = this.buildQuery();\n    }\n\n    if (interpolate) {\n      return this.templateSrv.replace(target.rawSql, this.scopedVars, this.interpolateQueryStr);\n    } else {\n      return target.rawSql;\n    }\n  }\n\n  hasUnixEpochTimecolumn() {\n    return ['int4', 'int8', 'float4', 'float8', 'numeric'].indexOf(this.target.timeColumnType) > -1;\n  }\n\n  buildTimeColumn(alias = true) {\n    const timeGroup = this.hasTimeGroup();\n    let query;\n    let macro = '$__timeGroup';\n\n    if (timeGroup) {\n      let args;\n      if (timeGroup.params.length > 1 && timeGroup.params[1] !== 'none') {\n        args = timeGroup.params.join(',');\n      } else {\n        args = timeGroup.params[0];\n      }\n      if (this.hasUnixEpochTimecolumn()) {\n        macro = '$__unixEpochGroup';\n      }\n      if (alias) {\n        macro += 'Alias';\n      }\n      query = macro + '(' + this.target.timeColumn + ',' + args + ')';\n    } else {\n      query = this.target.timeColumn;\n      if (alias) {\n        query += ' AS \"time\"';\n      }\n    }\n\n    return query;\n  }\n\n  buildMetricColumn() {\n    if (this.hasMetricColumn()) {\n      return this.target.metricColumn + ' AS metric';\n    }\n\n    return '';\n  }\n\n  buildValueColumns() {\n    let query = '';\n    for (const column of this.target.select) {\n      query += ',\\n  ' + this.buildValueColumn(column);\n    }\n\n    return query;\n  }\n\n  buildValueColumn(column: any) {\n    let query = '';\n\n    const columnName: any = find(column, (g: any) => g.type === 'column');\n    query = columnName.params[0];\n\n    const aggregate: any = find(column, (g: any) => g.type === 'aggregate' || g.type === 'percentile');\n    const windows: any = find(column, (g: any) => g.type === 'window' || g.type === 'moving_window');\n\n    if (aggregate) {\n      const func = aggregate.params[0];\n      switch (aggregate.type) {\n        case 'aggregate':\n          if (func === 'first' || func === 'last') {\n            query = func + '(' + query + ',' + this.target.timeColumn + ')';\n          } else {\n            query = func + '(' + query + ')';\n          }\n          break;\n        case 'percentile':\n          query = func + '(' + aggregate.params[1] + ') WITHIN GROUP (ORDER BY ' + query + ')';\n          break;\n      }\n    }\n\n    if (windows) {\n      const overParts = [];\n      if (this.hasMetricColumn()) {\n        overParts.push('PARTITION BY ' + this.target.metricColumn);\n      }\n      overParts.push('ORDER BY ' + this.buildTimeColumn(false));\n\n      const over = overParts.join(' ');\n      let curr: string;\n      let prev: string;\n      switch (windows.type) {\n        case 'window':\n          switch (windows.params[0]) {\n            case 'delta':\n              curr = query;\n              prev = 'lag(' + curr + ') OVER (' + over + ')';\n              query = curr + ' - ' + prev;\n              break;\n            case 'increase':\n              curr = query;\n              prev = 'lag(' + curr + ') OVER (' + over + ')';\n              query = '(CASE WHEN ' + curr + ' >= ' + prev + ' THEN ' + curr + ' - ' + prev;\n              query += ' WHEN ' + prev + ' IS NULL THEN NULL ELSE ' + curr + ' END)';\n              break;\n            case 'rate':\n              let timeColumn = this.target.timeColumn;\n              if (aggregate) {\n                timeColumn = 'min(' + timeColumn + ')';\n              }\n\n              curr = query;\n              prev = 'lag(' + curr + ') OVER (' + over + ')';\n              query = '(CASE WHEN ' + curr + ' >= ' + prev + ' THEN ' + curr + ' - ' + prev;\n              query += ' WHEN ' + prev + ' IS NULL THEN NULL ELSE ' + curr + ' END)';\n              query += '/extract(epoch from ' + timeColumn + ' - lag(' + timeColumn + ') OVER (' + over + '))';\n              break;\n            default:\n              query = windows.params[0] + '(' + query + ') OVER (' + over + ')';\n              break;\n          }\n          break;\n        case 'moving_window':\n          query = windows.params[0] + '(' + query + ') OVER (' + over + ' ROWS ' + windows.params[1] + ' PRECEDING)';\n          break;\n      }\n    }\n\n    const alias: any = find(column, (g: any) => g.type === 'alias');\n    if (alias) {\n      query += ' AS ' + this.quoteIdentifier(alias.params[0]);\n    }\n\n    return query;\n  }\n\n  buildWhereClause() {\n    let query = '';\n    const conditions = map(this.target.where, (tag, index) => {\n      switch (tag.type) {\n        case 'macro':\n          return tag.name + '(' + this.target.timeColumn + ')';\n          break;\n        case 'expression':\n          return tag.params.join(' ');\n          break;\n      }\n    });\n\n    if (conditions.length > 0) {\n      query = '\\nWHERE\\n  ' + conditions.join(' AND\\n  ');\n    }\n\n    return query;\n  }\n\n  buildGroupClause() {\n    let query = '';\n    let groupSection = '';\n\n    for (let i = 0; i < this.target.group.length; i++) {\n      const part = this.target.group[i];\n      if (i > 0) {\n        groupSection += ', ';\n      }\n      if (part.type === 'time') {\n        groupSection += '1';\n      } else {\n        groupSection += part.params[0];\n      }\n    }\n\n    if (groupSection.length) {\n      query = '\\nGROUP BY ' + groupSection;\n      if (this.hasMetricColumn()) {\n        query += ',2';\n      }\n    }\n    return query;\n  }\n\n  buildQuery() {\n    let query = 'SELECT';\n\n    query += '\\n  ' + this.buildTimeColumn();\n    if (this.hasMetricColumn()) {\n      query += ',\\n  ' + this.buildMetricColumn();\n    }\n    query += this.buildValueColumns();\n\n    query += '\\nFROM ' + this.target.table;\n\n    query += this.buildWhereClause();\n    query += this.buildGroupClause();\n\n    query += '\\nORDER BY 1';\n    if (this.hasMetricColumn()) {\n      query += ',2';\n    }\n\n    return query;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}