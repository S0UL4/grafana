{"ast":null,"code":"import { each, flatten, groupBy, isArray } from 'lodash';\nimport { FieldType } from '@grafana/data';\nimport { toDataQueryResponse } from '@grafana/runtime';\nimport TableModel from 'app/core/table_model';\nexport default class ResponseParser {\n  parse(query, results) {\n    if (!(results !== null && results !== void 0 && results.results) || results.results.length === 0) {\n      return [];\n    }\n\n    const influxResults = results.results[0];\n\n    if (!influxResults.series) {\n      return [];\n    }\n\n    const normalizedQuery = query.toLowerCase();\n    const isValueFirst = normalizedQuery.indexOf('show field keys') >= 0 || normalizedQuery.indexOf('show retention policies') >= 0;\n    const res = new Set();\n    each(influxResults.series, serie => {\n      each(serie.values, value => {\n        if (isArray(value)) {\n          // In general, there are 2 possible shapes for the returned value.\n          // The first one is a two-element array,\n          // where the first element is somewhat a metadata value:\n          // the tag name for SHOW TAG VALUES queries,\n          // the time field for SELECT queries, etc.\n          // The second shape is an one-element array,\n          // that is containing an immediate value.\n          // For example, SHOW FIELD KEYS queries return such shape.\n          // Note, pre-0.11 versions return\n          // the second shape for SHOW TAG VALUES queries\n          // (while the newer versions—first).\n          if (isValueFirst) {\n            addUnique(res, value[0]);\n          } else if (value[1] !== undefined) {\n            addUnique(res, value[1]);\n          } else {\n            addUnique(res, value[0]);\n          }\n        } else {\n          addUnique(res, value);\n        }\n      });\n    }); // NOTE: it is important to keep the order of items in the parsed output\n    // the same as it was in the influxdb-response.\n    // we use a `Set` to collect the unique-results, and `Set` iteration\n    // order is insertion-order, so this should be ok.\n\n    return Array.from(res).map(v => ({\n      text: v\n    }));\n  }\n\n  getTable(dfs, target, meta) {\n    let table = new TableModel();\n\n    if (dfs.length > 0) {\n      var _dfs$0$meta;\n\n      table.meta = Object.assign({}, meta, {\n        executedQueryString: (_dfs$0$meta = dfs[0].meta) === null || _dfs$0$meta === void 0 ? void 0 : _dfs$0$meta.executedQueryString\n      });\n      table.refId = target.refId;\n      table = getTableCols(dfs, table, target); // if group by tag(s) added\n\n      if (dfs[0].fields[1] && dfs[0].fields[1].labels) {\n        let dfsByLabels = groupBy(dfs, df => df.fields[1].labels ? Object.values(df.fields[1].labels) : null);\n        const labels = Object.keys(dfsByLabels);\n        dfsByLabels = Object.values(dfsByLabels);\n\n        for (let i = 0; i < dfsByLabels.length; i++) {\n          table = getTableRows(dfsByLabels[i], table, [...labels[i].split(',')]);\n        }\n      } else {\n        table = getTableRows(dfs, table, []);\n      }\n    }\n\n    return table;\n  }\n\n  async transformAnnotationResponse(options, data, target) {\n    const rsp = toDataQueryResponse(data, [target]);\n\n    if (rsp) {\n      const table = this.getTable(rsp.data, target, {});\n      const list = [];\n      let titleCol = null;\n      let timeCol = null;\n      let timeEndCol = null;\n      const tagsCol = [];\n      let textCol = null;\n      each(table.columns, (column, index) => {\n        if (column.text.toLowerCase() === 'time') {\n          timeCol = index;\n          return;\n        }\n\n        if (column.text === options.annotation.titleColumn) {\n          titleCol = index;\n          return;\n        }\n\n        if (colContainsTag(column.text, options.annotation.tagsColumn)) {\n          tagsCol.push(index);\n          return;\n        }\n\n        if (column.text.includes(options.annotation.textColumn)) {\n          textCol = index;\n          return;\n        }\n\n        if (column.text === options.annotation.timeEndColumn) {\n          timeEndCol = index;\n          return;\n        } // legacy case\n\n\n        if (!titleCol && textCol !== index) {\n          titleCol = index;\n        }\n      });\n      each(table.rows, value => {\n        const data = {\n          annotation: options.annotation,\n          time: +new Date(value[timeCol]),\n          title: value[titleCol],\n          timeEnd: value[timeEndCol],\n          // Remove empty values, then split in different tags for comma separated values\n          tags: flatten(tagsCol.filter(t => {\n            return value[t];\n          }).map(t => {\n            return value[t].split(',');\n          })),\n          text: value[textCol]\n        };\n        list.push(data);\n      });\n      return list;\n    }\n\n    return [];\n  }\n\n}\n\nfunction colContainsTag(colText, tagsColumn) {\n  const tags = (tagsColumn || '').replace(' ', '').split(',');\n\n  for (var tag of tags) {\n    if (colText.includes(tag)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getTableCols(dfs, table, target) {\n  const selectedParams = getSelectedParams(target);\n  dfs[0].fields.forEach(field => {\n    // Time col\n    if (field.name === 'time') {\n      table.columns.push({\n        text: 'Time',\n        type: FieldType.time\n      });\n    } // Group by (label) column(s)\n    else if (field.name === 'value') {\n      if (field.labels) {\n        Object.keys(field.labels).forEach(key => {\n          table.columns.push({\n            text: key\n          });\n        });\n      }\n    }\n  }); // Get cols for annotationQuery\n\n  if (dfs[0].refId === 'metricFindQuery') {\n    dfs.forEach(field => {\n      if (field.name) {\n        table.columns.push({\n          text: field.name\n        });\n      }\n    });\n  } // Select (metric) column(s)\n\n\n  for (let i = 0; i < selectedParams.length; i++) {\n    table.columns.push({\n      text: selectedParams[i]\n    });\n  }\n\n  return table;\n}\n\nfunction getTableRows(dfs, table, labels) {\n  const values = dfs[0].fields[0].values.toArray();\n\n  for (let i = 0; i < values.length; i++) {\n    const time = values[i];\n    const metrics = dfs.map(df => {\n      return df.fields[1] ? df.fields[1].values.toArray()[i] : null;\n    });\n\n    if (metrics.indexOf(null) < 0) {\n      table.rows.push([time, ...labels, ...metrics]);\n    }\n  }\n\n  return table;\n}\n\nexport function getSelectedParams(target) {\n  var _target$select;\n\n  let allParams = [];\n  (_target$select = target.select) === null || _target$select === void 0 ? void 0 : _target$select.forEach(select => {\n    const selector = select.filter(x => x.type !== 'field');\n\n    if (selector.length > 0) {\n      allParams.push(selector[0].type);\n    } else {\n      if (select[0] && select[0].params && select[0].params[0]) {\n        allParams.push(select[0].params[0].toString());\n      }\n    }\n  });\n  let uniqueParams = [];\n  allParams.forEach(param => {\n    uniqueParams.push(incrementName(param, param, uniqueParams, 0));\n  });\n  return uniqueParams;\n}\n\nfunction incrementName(name, nameIncremenet, params, index) {\n  if (params.indexOf(nameIncremenet) > -1) {\n    index++;\n    return incrementName(name, name + '_' + index, params, index);\n  }\n\n  return nameIncremenet;\n}\n\nfunction addUnique(s, value) {\n  s.add(value.toString());\n}","map":{"version":3,"names":["each","flatten","groupBy","isArray","FieldType","toDataQueryResponse","TableModel","ResponseParser","parse","query","results","length","influxResults","series","normalizedQuery","toLowerCase","isValueFirst","indexOf","res","Set","serie","values","value","addUnique","undefined","Array","from","map","v","text","getTable","dfs","target","meta","table","executedQueryString","refId","getTableCols","fields","labels","dfsByLabels","df","Object","keys","i","getTableRows","split","transformAnnotationResponse","options","data","rsp","list","titleCol","timeCol","timeEndCol","tagsCol","textCol","columns","column","index","annotation","titleColumn","colContainsTag","tagsColumn","push","includes","textColumn","timeEndColumn","rows","time","Date","title","timeEnd","tags","filter","t","colText","replace","tag","selectedParams","getSelectedParams","forEach","field","name","type","key","toArray","metrics","allParams","select","selector","x","params","toString","uniqueParams","param","incrementName","nameIncremenet","s","add"],"sources":["/home/soula/grafana/public/app/plugins/datasource/influxdb/response_parser.ts"],"sourcesContent":["import { each, flatten, groupBy, isArray } from 'lodash';\n\nimport { AnnotationEvent, DataFrame, DataQuery, FieldType, QueryResultMeta } from '@grafana/data';\nimport { toDataQueryResponse } from '@grafana/runtime';\nimport TableModel from 'app/core/table_model';\n\nimport { InfluxQuery } from './types';\n\nexport default class ResponseParser {\n  parse(query: string, results: { results: any }) {\n    if (!results?.results || results.results.length === 0) {\n      return [];\n    }\n\n    const influxResults = results.results[0];\n    if (!influxResults.series) {\n      return [];\n    }\n\n    const normalizedQuery = query.toLowerCase();\n    const isValueFirst =\n      normalizedQuery.indexOf('show field keys') >= 0 || normalizedQuery.indexOf('show retention policies') >= 0;\n\n    const res = new Set<string>();\n    each(influxResults.series, (serie) => {\n      each(serie.values, (value) => {\n        if (isArray(value)) {\n          // In general, there are 2 possible shapes for the returned value.\n          // The first one is a two-element array,\n          // where the first element is somewhat a metadata value:\n          // the tag name for SHOW TAG VALUES queries,\n          // the time field for SELECT queries, etc.\n          // The second shape is an one-element array,\n          // that is containing an immediate value.\n          // For example, SHOW FIELD KEYS queries return such shape.\n          // Note, pre-0.11 versions return\n          // the second shape for SHOW TAG VALUES queries\n          // (while the newer versions—first).\n\n          if (isValueFirst) {\n            addUnique(res, value[0]);\n          } else if (value[1] !== undefined) {\n            addUnique(res, value[1]);\n          } else {\n            addUnique(res, value[0]);\n          }\n        } else {\n          addUnique(res, value);\n        }\n      });\n    });\n\n    // NOTE: it is important to keep the order of items in the parsed output\n    // the same as it was in the influxdb-response.\n    // we use a `Set` to collect the unique-results, and `Set` iteration\n    // order is insertion-order, so this should be ok.\n    return Array.from(res).map((v) => ({ text: v }));\n  }\n\n  getTable(dfs: DataFrame[], target: InfluxQuery, meta: QueryResultMeta): TableModel {\n    let table = new TableModel();\n\n    if (dfs.length > 0) {\n      table.meta = {\n        ...meta,\n        executedQueryString: dfs[0].meta?.executedQueryString,\n      };\n\n      table.refId = target.refId;\n      table = getTableCols(dfs, table, target);\n\n      // if group by tag(s) added\n      if (dfs[0].fields[1] && dfs[0].fields[1].labels) {\n        let dfsByLabels: any = groupBy(dfs, (df: DataFrame) =>\n          df.fields[1].labels ? Object.values(df.fields[1].labels!) : null\n        );\n        const labels = Object.keys(dfsByLabels);\n        dfsByLabels = Object.values(dfsByLabels);\n\n        for (let i = 0; i < dfsByLabels.length; i++) {\n          table = getTableRows(dfsByLabels[i], table, [...labels[i].split(',')]);\n        }\n      } else {\n        table = getTableRows(dfs, table, []);\n      }\n    }\n\n    return table;\n  }\n\n  async transformAnnotationResponse(options: any, data: any, target: InfluxQuery): Promise<AnnotationEvent[]> {\n    const rsp = toDataQueryResponse(data, [target] as DataQuery[]);\n\n    if (rsp) {\n      const table = this.getTable(rsp.data, target, {});\n      const list: any[] = [];\n      let titleCol: any = null;\n      let timeCol: any = null;\n      let timeEndCol: any = null;\n      const tagsCol: any = [];\n      let textCol: any = null;\n\n      each(table.columns, (column, index) => {\n        if (column.text.toLowerCase() === 'time') {\n          timeCol = index;\n          return;\n        }\n        if (column.text === options.annotation.titleColumn) {\n          titleCol = index;\n          return;\n        }\n        if (colContainsTag(column.text, options.annotation.tagsColumn)) {\n          tagsCol.push(index);\n          return;\n        }\n        if (column.text.includes(options.annotation.textColumn)) {\n          textCol = index;\n          return;\n        }\n        if (column.text === options.annotation.timeEndColumn) {\n          timeEndCol = index;\n          return;\n        }\n        // legacy case\n        if (!titleCol && textCol !== index) {\n          titleCol = index;\n        }\n      });\n\n      each(table.rows, (value) => {\n        const data = {\n          annotation: options.annotation,\n          time: +new Date(value[timeCol]),\n          title: value[titleCol],\n          timeEnd: value[timeEndCol],\n          // Remove empty values, then split in different tags for comma separated values\n          tags: flatten(\n            tagsCol\n              .filter((t: any) => {\n                return value[t];\n              })\n              .map((t: any) => {\n                return value[t].split(',');\n              })\n          ),\n          text: value[textCol],\n        };\n\n        list.push(data);\n      });\n\n      return list;\n    }\n    return [];\n  }\n}\n\nfunction colContainsTag(colText: string, tagsColumn: string): boolean {\n  const tags = (tagsColumn || '').replace(' ', '').split(',');\n  for (var tag of tags) {\n    if (colText.includes(tag)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction getTableCols(dfs: DataFrame[], table: TableModel, target: InfluxQuery): TableModel {\n  const selectedParams = getSelectedParams(target);\n\n  dfs[0].fields.forEach((field) => {\n    // Time col\n    if (field.name === 'time') {\n      table.columns.push({ text: 'Time', type: FieldType.time });\n    }\n\n    // Group by (label) column(s)\n    else if (field.name === 'value') {\n      if (field.labels) {\n        Object.keys(field.labels).forEach((key) => {\n          table.columns.push({ text: key });\n        });\n      }\n    }\n  });\n\n  // Get cols for annotationQuery\n  if (dfs[0].refId === 'metricFindQuery') {\n    dfs.forEach((field) => {\n      if (field.name) {\n        table.columns.push({ text: field.name });\n      }\n    });\n  }\n\n  // Select (metric) column(s)\n  for (let i = 0; i < selectedParams.length; i++) {\n    table.columns.push({ text: selectedParams[i] });\n  }\n\n  return table;\n}\n\nfunction getTableRows(dfs: DataFrame[], table: TableModel, labels: string[]): TableModel {\n  const values = dfs[0].fields[0].values.toArray();\n\n  for (let i = 0; i < values.length; i++) {\n    const time = values[i];\n    const metrics = dfs.map((df: DataFrame) => {\n      return df.fields[1] ? df.fields[1].values.toArray()[i] : null;\n    });\n    if (metrics.indexOf(null) < 0) {\n      table.rows.push([time, ...labels, ...metrics]);\n    }\n  }\n  return table;\n}\n\nexport function getSelectedParams(target: InfluxQuery): string[] {\n  let allParams: string[] = [];\n  target.select?.forEach((select) => {\n    const selector = select.filter((x) => x.type !== 'field');\n    if (selector.length > 0) {\n      allParams.push(selector[0].type);\n    } else {\n      if (select[0] && select[0].params && select[0].params[0]) {\n        allParams.push(select[0].params[0].toString());\n      }\n    }\n  });\n\n  let uniqueParams: string[] = [];\n  allParams.forEach((param) => {\n    uniqueParams.push(incrementName(param, param, uniqueParams, 0));\n  });\n\n  return uniqueParams;\n}\n\nfunction incrementName(name: string, nameIncremenet: string, params: string[], index: number): string {\n  if (params.indexOf(nameIncremenet) > -1) {\n    index++;\n    return incrementName(name, name + '_' + index, params, index);\n  }\n  return nameIncremenet;\n}\n\nfunction addUnique(s: Set<string>, value: string | number) {\n  s.add(value.toString());\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}