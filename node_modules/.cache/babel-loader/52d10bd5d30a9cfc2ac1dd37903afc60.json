{"ast":null,"code":"import { isUndefined, omitBy } from 'lodash';\nimport { MatcherOperator } from 'app/plugins/datasource/alertmanager/types';\nimport { matcherToMatcherField, parseMatcher } from './alertmanager';\nimport { GRAFANA_RULES_SOURCE_NAME } from './datasource';\nimport { parseInterval, timeOptions } from './time';\nconst defaultValueAndType = ['', ''];\n\nconst matchersToArrayFieldMatchers = (matchers, isRegex) => Object.entries(matchers !== null && matchers !== void 0 ? matchers : {}).reduce((acc, [name, value]) => [...acc, {\n  name,\n  value,\n  operator: isRegex ? MatcherOperator.regex : MatcherOperator.equal\n}], []);\n\nconst intervalToValueAndType = (strValue, defaultValue) => {\n  if (!strValue) {\n    return defaultValue !== null && defaultValue !== void 0 ? defaultValue : defaultValueAndType;\n  }\n\n  const [value, valueType] = strValue ? parseInterval(strValue) : [undefined, undefined];\n  const timeOption = timeOptions.find(opt => opt.value === valueType);\n\n  if (!value || !timeOption) {\n    return defaultValueAndType;\n  }\n\n  return [String(value), timeOption.value];\n};\n\nconst selectableValueToString = selectableValue => selectableValue.value;\n\nconst selectableValuesToStrings = arr => (arr !== null && arr !== void 0 ? arr : []).map(selectableValueToString);\n\nexport const emptyArrayFieldMatcher = {\n  name: '',\n  value: '',\n  operator: MatcherOperator.equal\n};\nexport const emptyRoute = {\n  id: '',\n  overrideGrouping: false,\n  groupBy: [],\n  object_matchers: [],\n  routes: [],\n  continue: false,\n  receiver: '',\n  overrideTimings: false,\n  groupWaitValue: '',\n  groupWaitValueType: timeOptions[0].value,\n  groupIntervalValue: '',\n  groupIntervalValueType: timeOptions[0].value,\n  repeatIntervalValue: '',\n  repeatIntervalValueType: timeOptions[0].value,\n  muteTimeIntervals: []\n}; //returns route, and a record mapping id to existing route\n\nexport const amRouteToFormAmRoute = route => {\n  var _route$routes, _route$matchers$map, _route$matchers, _route$object_matcher, _route$object_matcher2, _route$continue, _route$receiver, _route$group_by, _route$mute_time_inte;\n\n  if (!route) {\n    return [emptyRoute, {}];\n  }\n\n  const id = String(Math.random());\n  const id2route = {\n    [id]: route\n  };\n\n  if (Object.keys(route).length === 0) {\n    const formAmRoute = Object.assign({}, emptyRoute, {\n      id\n    });\n    return [formAmRoute, id2route];\n  }\n\n  const formRoutes = [];\n  (_route$routes = route.routes) === null || _route$routes === void 0 ? void 0 : _route$routes.forEach(subRoute => {\n    const [subFormRoute, subId2Route] = amRouteToFormAmRoute(subRoute);\n    formRoutes.push(subFormRoute);\n    Object.assign(id2route, subId2Route);\n  }); // Frontend migration to use object_matchers instead of matchers\n\n  const matchers = route.matchers ? (_route$matchers$map = (_route$matchers = route.matchers) === null || _route$matchers === void 0 ? void 0 : _route$matchers.map(matcher => matcherToMatcherField(parseMatcher(matcher)))) !== null && _route$matchers$map !== void 0 ? _route$matchers$map : [] : (_route$object_matcher = (_route$object_matcher2 = route.object_matchers) === null || _route$object_matcher2 === void 0 ? void 0 : _route$object_matcher2.map(matcher => ({\n    name: matcher[0],\n    operator: matcher[1],\n    value: matcher[2]\n  }))) !== null && _route$object_matcher !== void 0 ? _route$object_matcher : [];\n  const [groupWaitValue, groupWaitValueType] = intervalToValueAndType(route.group_wait, ['', 's']);\n  const [groupIntervalValue, groupIntervalValueType] = intervalToValueAndType(route.group_interval, ['', 'm']);\n  const [repeatIntervalValue, repeatIntervalValueType] = intervalToValueAndType(route.repeat_interval, ['', 'h']);\n  return [{\n    id,\n    object_matchers: [...matchers, ...matchersToArrayFieldMatchers(route.match, false), ...matchersToArrayFieldMatchers(route.match_re, true)],\n    continue: (_route$continue = route.continue) !== null && _route$continue !== void 0 ? _route$continue : false,\n    receiver: (_route$receiver = route.receiver) !== null && _route$receiver !== void 0 ? _route$receiver : '',\n    overrideGrouping: Array.isArray(route.group_by) && route.group_by.length !== 0,\n    groupBy: (_route$group_by = route.group_by) !== null && _route$group_by !== void 0 ? _route$group_by : [],\n    overrideTimings: [groupWaitValue, groupIntervalValue, repeatIntervalValue].some(Boolean),\n    groupWaitValue,\n    groupWaitValueType,\n    groupIntervalValue,\n    groupIntervalValueType,\n    repeatIntervalValue,\n    repeatIntervalValueType,\n    routes: formRoutes,\n    muteTimeIntervals: (_route$mute_time_inte = route.mute_time_intervals) !== null && _route$mute_time_inte !== void 0 ? _route$mute_time_inte : []\n  }, id2route];\n};\nexport const formAmRouteToAmRoute = (alertManagerSourceName, formAmRoute, id2ExistingRoute) => {\n  const existing = id2ExistingRoute[formAmRoute.id];\n  const {\n    overrideGrouping,\n    groupBy,\n    overrideTimings,\n    groupWaitValue,\n    groupWaitValueType,\n    groupIntervalValue,\n    groupIntervalValueType,\n    repeatIntervalValue,\n    repeatIntervalValueType\n  } = formAmRoute;\n  const group_by = overrideGrouping && groupBy ? groupBy : [];\n  const overrideGroupWait = overrideTimings && groupWaitValue;\n  const group_wait = overrideGroupWait ? `${groupWaitValue}${groupWaitValueType}` : undefined;\n  const overrideGroupInterval = overrideTimings && groupIntervalValue;\n  const group_interval = overrideGroupInterval ? `${groupIntervalValue}${groupIntervalValueType}` : undefined;\n  const overrideRepeatInterval = overrideTimings && repeatIntervalValue;\n  const repeat_interval = overrideRepeatInterval ? `${repeatIntervalValue}${repeatIntervalValueType}` : undefined;\n  const amRoute = Object.assign({}, existing !== null && existing !== void 0 ? existing : {}, {\n    continue: formAmRoute.continue,\n    group_by: group_by,\n    object_matchers: formAmRoute.object_matchers.length ? formAmRoute.object_matchers.map(matcher => [matcher.name, matcher.operator, matcher.value]) : undefined,\n    match: undefined,\n    // DEPRECATED: Use matchers\n    match_re: undefined,\n    // DEPRECATED: Use matchers\n    group_wait,\n    group_interval,\n    repeat_interval,\n    routes: formAmRoute.routes.map(subRoute => formAmRouteToAmRoute(alertManagerSourceName, subRoute, id2ExistingRoute)),\n    mute_time_intervals: formAmRoute.muteTimeIntervals\n  });\n\n  if (alertManagerSourceName !== GRAFANA_RULES_SOURCE_NAME) {\n    amRoute.matchers = formAmRoute.object_matchers.map(({\n      name,\n      operator,\n      value\n    }) => `${name}${operator}${value}`);\n    amRoute.object_matchers = undefined;\n  } else {\n    amRoute.matchers = undefined;\n  }\n\n  if (formAmRoute.receiver) {\n    amRoute.receiver = formAmRoute.receiver;\n  }\n\n  return omitBy(amRoute, isUndefined);\n};\nexport const stringToSelectableValue = str => ({\n  label: str,\n  value: str\n});\nexport const stringsToSelectableValues = arr => (arr !== null && arr !== void 0 ? arr : []).map(stringToSelectableValue);\nexport const mapSelectValueToString = selectableValue => {\n  var _selectableValueToStr;\n\n  if (!selectableValue) {\n    return '';\n  }\n\n  return (_selectableValueToStr = selectableValueToString(selectableValue)) !== null && _selectableValueToStr !== void 0 ? _selectableValueToStr : '';\n};\nexport const mapMultiSelectValueToStrings = selectableValues => {\n  if (!selectableValues) {\n    return [];\n  }\n\n  return selectableValuesToStrings(selectableValues);\n};\nexport const optionalPositiveInteger = value => {\n  if (!value) {\n    return undefined;\n  }\n\n  return !/^\\d+$/.test(value) ? 'Must be a positive integer.' : undefined;\n};","map":{"version":3,"names":["isUndefined","omitBy","MatcherOperator","matcherToMatcherField","parseMatcher","GRAFANA_RULES_SOURCE_NAME","parseInterval","timeOptions","defaultValueAndType","matchersToArrayFieldMatchers","matchers","isRegex","Object","entries","reduce","acc","name","value","operator","regex","equal","intervalToValueAndType","strValue","defaultValue","valueType","undefined","timeOption","find","opt","String","selectableValueToString","selectableValue","selectableValuesToStrings","arr","map","emptyArrayFieldMatcher","emptyRoute","id","overrideGrouping","groupBy","object_matchers","routes","continue","receiver","overrideTimings","groupWaitValue","groupWaitValueType","groupIntervalValue","groupIntervalValueType","repeatIntervalValue","repeatIntervalValueType","muteTimeIntervals","amRouteToFormAmRoute","route","Math","random","id2route","keys","length","formAmRoute","formRoutes","forEach","subRoute","subFormRoute","subId2Route","push","assign","matcher","group_wait","group_interval","repeat_interval","match","match_re","Array","isArray","group_by","some","Boolean","mute_time_intervals","formAmRouteToAmRoute","alertManagerSourceName","id2ExistingRoute","existing","overrideGroupWait","overrideGroupInterval","overrideRepeatInterval","amRoute","stringToSelectableValue","str","label","stringsToSelectableValues","mapSelectValueToString","mapMultiSelectValueToStrings","selectableValues","optionalPositiveInteger","test"],"sources":["/home/soula/grafana/public/app/features/alerting/unified/utils/amroutes.ts"],"sourcesContent":["import { isUndefined, omitBy } from 'lodash';\nimport { Validate } from 'react-hook-form';\n\nimport { SelectableValue } from '@grafana/data';\nimport { MatcherOperator, Route } from 'app/plugins/datasource/alertmanager/types';\n\nimport { FormAmRoute } from '../types/amroutes';\nimport { MatcherFieldValue } from '../types/silence-form';\n\nimport { matcherToMatcherField, parseMatcher } from './alertmanager';\nimport { GRAFANA_RULES_SOURCE_NAME } from './datasource';\nimport { parseInterval, timeOptions } from './time';\n\nconst defaultValueAndType: [string, string] = ['', ''];\n\nconst matchersToArrayFieldMatchers = (\n  matchers: Record<string, string> | undefined,\n  isRegex: boolean\n): MatcherFieldValue[] =>\n  Object.entries(matchers ?? {}).reduce<MatcherFieldValue[]>(\n    (acc, [name, value]) => [\n      ...acc,\n      {\n        name,\n        value,\n        operator: isRegex ? MatcherOperator.regex : MatcherOperator.equal,\n      },\n    ],\n    [] as MatcherFieldValue[]\n  );\n\nconst intervalToValueAndType = (\n  strValue: string | undefined,\n  defaultValue?: typeof defaultValueAndType\n): [string, string] => {\n  if (!strValue) {\n    return defaultValue ?? defaultValueAndType;\n  }\n\n  const [value, valueType] = strValue ? parseInterval(strValue) : [undefined, undefined];\n\n  const timeOption = timeOptions.find((opt) => opt.value === valueType);\n\n  if (!value || !timeOption) {\n    return defaultValueAndType;\n  }\n\n  return [String(value), timeOption.value];\n};\n\nconst selectableValueToString = (selectableValue: SelectableValue<string>): string => selectableValue.value!;\n\nconst selectableValuesToStrings = (arr: Array<SelectableValue<string>> | undefined): string[] =>\n  (arr ?? []).map(selectableValueToString);\n\nexport const emptyArrayFieldMatcher: MatcherFieldValue = {\n  name: '',\n  value: '',\n  operator: MatcherOperator.equal,\n};\n\nexport const emptyRoute: FormAmRoute = {\n  id: '',\n  overrideGrouping: false,\n  groupBy: [],\n  object_matchers: [],\n  routes: [],\n  continue: false,\n  receiver: '',\n  overrideTimings: false,\n  groupWaitValue: '',\n  groupWaitValueType: timeOptions[0].value,\n  groupIntervalValue: '',\n  groupIntervalValueType: timeOptions[0].value,\n  repeatIntervalValue: '',\n  repeatIntervalValueType: timeOptions[0].value,\n  muteTimeIntervals: [],\n};\n\n//returns route, and a record mapping id to existing route\nexport const amRouteToFormAmRoute = (route: Route | undefined): [FormAmRoute, Record<string, Route>] => {\n  if (!route) {\n    return [emptyRoute, {}];\n  }\n\n  const id = String(Math.random());\n  const id2route = {\n    [id]: route,\n  };\n\n  if (Object.keys(route).length === 0) {\n    const formAmRoute = { ...emptyRoute, id };\n    return [formAmRoute, id2route];\n  }\n\n  const formRoutes: FormAmRoute[] = [];\n  route.routes?.forEach((subRoute) => {\n    const [subFormRoute, subId2Route] = amRouteToFormAmRoute(subRoute);\n    formRoutes.push(subFormRoute);\n    Object.assign(id2route, subId2Route);\n  });\n\n  // Frontend migration to use object_matchers instead of matchers\n  const matchers = route.matchers\n    ? route.matchers?.map((matcher) => matcherToMatcherField(parseMatcher(matcher))) ?? []\n    : route.object_matchers?.map(\n        (matcher) => ({ name: matcher[0], operator: matcher[1], value: matcher[2] } as MatcherFieldValue)\n      ) ?? [];\n\n  const [groupWaitValue, groupWaitValueType] = intervalToValueAndType(route.group_wait, ['', 's']);\n  const [groupIntervalValue, groupIntervalValueType] = intervalToValueAndType(route.group_interval, ['', 'm']);\n  const [repeatIntervalValue, repeatIntervalValueType] = intervalToValueAndType(route.repeat_interval, ['', 'h']);\n\n  return [\n    {\n      id,\n      object_matchers: [\n        ...matchers,\n        ...matchersToArrayFieldMatchers(route.match, false),\n        ...matchersToArrayFieldMatchers(route.match_re, true),\n      ],\n      continue: route.continue ?? false,\n      receiver: route.receiver ?? '',\n      overrideGrouping: Array.isArray(route.group_by) && route.group_by.length !== 0,\n      groupBy: route.group_by ?? [],\n      overrideTimings: [groupWaitValue, groupIntervalValue, repeatIntervalValue].some(Boolean),\n      groupWaitValue,\n      groupWaitValueType,\n      groupIntervalValue,\n      groupIntervalValueType,\n      repeatIntervalValue,\n      repeatIntervalValueType,\n      routes: formRoutes,\n      muteTimeIntervals: route.mute_time_intervals ?? [],\n    },\n    id2route,\n  ];\n};\n\nexport const formAmRouteToAmRoute = (\n  alertManagerSourceName: string | undefined,\n  formAmRoute: FormAmRoute,\n  id2ExistingRoute: Record<string, Route>\n): Route => {\n  const existing: Route | undefined = id2ExistingRoute[formAmRoute.id];\n\n  const {\n    overrideGrouping,\n    groupBy,\n    overrideTimings,\n    groupWaitValue,\n    groupWaitValueType,\n    groupIntervalValue,\n    groupIntervalValueType,\n    repeatIntervalValue,\n    repeatIntervalValueType,\n  } = formAmRoute;\n\n  const group_by = overrideGrouping && groupBy ? groupBy : [];\n\n  const overrideGroupWait = overrideTimings && groupWaitValue;\n  const group_wait = overrideGroupWait ? `${groupWaitValue}${groupWaitValueType}` : undefined;\n\n  const overrideGroupInterval = overrideTimings && groupIntervalValue;\n  const group_interval = overrideGroupInterval ? `${groupIntervalValue}${groupIntervalValueType}` : undefined;\n\n  const overrideRepeatInterval = overrideTimings && repeatIntervalValue;\n  const repeat_interval = overrideRepeatInterval ? `${repeatIntervalValue}${repeatIntervalValueType}` : undefined;\n\n  const amRoute: Route = {\n    ...(existing ?? {}),\n    continue: formAmRoute.continue,\n    group_by: group_by,\n    object_matchers: formAmRoute.object_matchers.length\n      ? formAmRoute.object_matchers.map((matcher) => [matcher.name, matcher.operator, matcher.value])\n      : undefined,\n    match: undefined, // DEPRECATED: Use matchers\n    match_re: undefined, // DEPRECATED: Use matchers\n    group_wait,\n    group_interval,\n    repeat_interval,\n    routes: formAmRoute.routes.map((subRoute) =>\n      formAmRouteToAmRoute(alertManagerSourceName, subRoute, id2ExistingRoute)\n    ),\n    mute_time_intervals: formAmRoute.muteTimeIntervals,\n  };\n\n  if (alertManagerSourceName !== GRAFANA_RULES_SOURCE_NAME) {\n    amRoute.matchers = formAmRoute.object_matchers.map(({ name, operator, value }) => `${name}${operator}${value}`);\n    amRoute.object_matchers = undefined;\n  } else {\n    amRoute.matchers = undefined;\n  }\n\n  if (formAmRoute.receiver) {\n    amRoute.receiver = formAmRoute.receiver;\n  }\n\n  return omitBy(amRoute, isUndefined);\n};\n\nexport const stringToSelectableValue = (str: string): SelectableValue<string> => ({\n  label: str,\n  value: str,\n});\n\nexport const stringsToSelectableValues = (arr: string[] | undefined): Array<SelectableValue<string>> =>\n  (arr ?? []).map(stringToSelectableValue);\n\nexport const mapSelectValueToString = (selectableValue: SelectableValue<string>): string => {\n  if (!selectableValue) {\n    return '';\n  }\n\n  return selectableValueToString(selectableValue) ?? '';\n};\n\nexport const mapMultiSelectValueToStrings = (\n  selectableValues: Array<SelectableValue<string>> | undefined\n): string[] => {\n  if (!selectableValues) {\n    return [];\n  }\n\n  return selectableValuesToStrings(selectableValues);\n};\n\nexport const optionalPositiveInteger: Validate<string> = (value) => {\n  if (!value) {\n    return undefined;\n  }\n\n  return !/^\\d+$/.test(value) ? 'Must be a positive integer.' : undefined;\n};\n"],"mappings":"AAAA,SAASA,WAAT,EAAsBC,MAAtB,QAAoC,QAApC;AAIA,SAASC,eAAT,QAAuC,2CAAvC;AAKA,SAASC,qBAAT,EAAgCC,YAAhC,QAAoD,gBAApD;AACA,SAASC,yBAAT,QAA0C,cAA1C;AACA,SAASC,aAAT,EAAwBC,WAAxB,QAA2C,QAA3C;AAEA,MAAMC,mBAAqC,GAAG,CAAC,EAAD,EAAK,EAAL,CAA9C;;AAEA,MAAMC,4BAA4B,GAAG,CACnCC,QADmC,EAEnCC,OAFmC,KAInCC,MAAM,CAACC,OAAP,CAAeH,QAAf,aAAeA,QAAf,cAAeA,QAAf,GAA2B,EAA3B,EAA+BI,MAA/B,CACE,CAACC,GAAD,EAAM,CAACC,IAAD,EAAOC,KAAP,CAAN,KAAwB,CACtB,GAAGF,GADmB,EAEtB;EACEC,IADF;EAEEC,KAFF;EAGEC,QAAQ,EAAEP,OAAO,GAAGT,eAAe,CAACiB,KAAnB,GAA2BjB,eAAe,CAACkB;AAH9D,CAFsB,CAD1B,EASE,EATF,CAJF;;AAgBA,MAAMC,sBAAsB,GAAG,CAC7BC,QAD6B,EAE7BC,YAF6B,KAGR;EACrB,IAAI,CAACD,QAAL,EAAe;IACb,OAAOC,YAAP,aAAOA,YAAP,cAAOA,YAAP,GAAuBf,mBAAvB;EACD;;EAED,MAAM,CAACS,KAAD,EAAQO,SAAR,IAAqBF,QAAQ,GAAGhB,aAAa,CAACgB,QAAD,CAAhB,GAA6B,CAACG,SAAD,EAAYA,SAAZ,CAAhE;EAEA,MAAMC,UAAU,GAAGnB,WAAW,CAACoB,IAAZ,CAAkBC,GAAD,IAASA,GAAG,CAACX,KAAJ,KAAcO,SAAxC,CAAnB;;EAEA,IAAI,CAACP,KAAD,IAAU,CAACS,UAAf,EAA2B;IACzB,OAAOlB,mBAAP;EACD;;EAED,OAAO,CAACqB,MAAM,CAACZ,KAAD,CAAP,EAAgBS,UAAU,CAACT,KAA3B,CAAP;AACD,CAjBD;;AAmBA,MAAMa,uBAAuB,GAAIC,eAAD,IAAsDA,eAAe,CAACd,KAAtG;;AAEA,MAAMe,yBAAyB,GAAIC,GAAD,IAChC,CAACA,GAAD,aAACA,GAAD,cAACA,GAAD,GAAQ,EAAR,EAAYC,GAAZ,CAAgBJ,uBAAhB,CADF;;AAGA,OAAO,MAAMK,sBAAyC,GAAG;EACvDnB,IAAI,EAAE,EADiD;EAEvDC,KAAK,EAAE,EAFgD;EAGvDC,QAAQ,EAAEhB,eAAe,CAACkB;AAH6B,CAAlD;AAMP,OAAO,MAAMgB,UAAuB,GAAG;EACrCC,EAAE,EAAE,EADiC;EAErCC,gBAAgB,EAAE,KAFmB;EAGrCC,OAAO,EAAE,EAH4B;EAIrCC,eAAe,EAAE,EAJoB;EAKrCC,MAAM,EAAE,EAL6B;EAMrCC,QAAQ,EAAE,KAN2B;EAOrCC,QAAQ,EAAE,EAP2B;EAQrCC,eAAe,EAAE,KARoB;EASrCC,cAAc,EAAE,EATqB;EAUrCC,kBAAkB,EAAEvC,WAAW,CAAC,CAAD,CAAX,CAAeU,KAVE;EAWrC8B,kBAAkB,EAAE,EAXiB;EAYrCC,sBAAsB,EAAEzC,WAAW,CAAC,CAAD,CAAX,CAAeU,KAZF;EAarCgC,mBAAmB,EAAE,EAbgB;EAcrCC,uBAAuB,EAAE3C,WAAW,CAAC,CAAD,CAAX,CAAeU,KAdH;EAerCkC,iBAAiB,EAAE;AAfkB,CAAhC,C,CAkBP;;AACA,OAAO,MAAMC,oBAAoB,GAAIC,KAAD,IAAoE;EAAA;;EACtG,IAAI,CAACA,KAAL,EAAY;IACV,OAAO,CAACjB,UAAD,EAAa,EAAb,CAAP;EACD;;EAED,MAAMC,EAAE,GAAGR,MAAM,CAACyB,IAAI,CAACC,MAAL,EAAD,CAAjB;EACA,MAAMC,QAAQ,GAAG;IACf,CAACnB,EAAD,GAAMgB;EADS,CAAjB;;EAIA,IAAIzC,MAAM,CAAC6C,IAAP,CAAYJ,KAAZ,EAAmBK,MAAnB,KAA8B,CAAlC,EAAqC;IACnC,MAAMC,WAAW,qBAAQvB,UAAR;MAAoBC;IAApB,EAAjB;IACA,OAAO,CAACsB,WAAD,EAAcH,QAAd,CAAP;EACD;;EAED,MAAMI,UAAyB,GAAG,EAAlC;EACA,iBAAAP,KAAK,CAACZ,MAAN,gEAAcoB,OAAd,CAAuBC,QAAD,IAAc;IAClC,MAAM,CAACC,YAAD,EAAeC,WAAf,IAA8BZ,oBAAoB,CAACU,QAAD,CAAxD;IACAF,UAAU,CAACK,IAAX,CAAgBF,YAAhB;IACAnD,MAAM,CAACsD,MAAP,CAAcV,QAAd,EAAwBQ,WAAxB;EACD,CAJD,EAhBsG,CAsBtG;;EACA,MAAMtD,QAAQ,GAAG2C,KAAK,CAAC3C,QAAN,6CACb2C,KAAK,CAAC3C,QADO,oDACb,gBAAgBwB,GAAhB,CAAqBiC,OAAD,IAAahE,qBAAqB,CAACC,YAAY,CAAC+D,OAAD,CAAb,CAAtD,CADa,qEACqE,EADrE,sDAEbd,KAAK,CAACb,eAFO,2DAEb,uBAAuBN,GAAvB,CACGiC,OAAD,KAAc;IAAEnD,IAAI,EAAEmD,OAAO,CAAC,CAAD,CAAf;IAAoBjD,QAAQ,EAAEiD,OAAO,CAAC,CAAD,CAArC;IAA0ClD,KAAK,EAAEkD,OAAO,CAAC,CAAD;EAAxD,CAAd,CADF,CAFa,yEAIR,EAJT;EAMA,MAAM,CAACtB,cAAD,EAAiBC,kBAAjB,IAAuCzB,sBAAsB,CAACgC,KAAK,CAACe,UAAP,EAAmB,CAAC,EAAD,EAAK,GAAL,CAAnB,CAAnE;EACA,MAAM,CAACrB,kBAAD,EAAqBC,sBAArB,IAA+C3B,sBAAsB,CAACgC,KAAK,CAACgB,cAAP,EAAuB,CAAC,EAAD,EAAK,GAAL,CAAvB,CAA3E;EACA,MAAM,CAACpB,mBAAD,EAAsBC,uBAAtB,IAAiD7B,sBAAsB,CAACgC,KAAK,CAACiB,eAAP,EAAwB,CAAC,EAAD,EAAK,GAAL,CAAxB,CAA7E;EAEA,OAAO,CACL;IACEjC,EADF;IAEEG,eAAe,EAAE,CACf,GAAG9B,QADY,EAEf,GAAGD,4BAA4B,CAAC4C,KAAK,CAACkB,KAAP,EAAc,KAAd,CAFhB,EAGf,GAAG9D,4BAA4B,CAAC4C,KAAK,CAACmB,QAAP,EAAiB,IAAjB,CAHhB,CAFnB;IAOE9B,QAAQ,qBAAEW,KAAK,CAACX,QAAR,6DAAoB,KAP9B;IAQEC,QAAQ,qBAAEU,KAAK,CAACV,QAAR,6DAAoB,EAR9B;IASEL,gBAAgB,EAAEmC,KAAK,CAACC,OAAN,CAAcrB,KAAK,CAACsB,QAApB,KAAiCtB,KAAK,CAACsB,QAAN,CAAejB,MAAf,KAA0B,CAT/E;IAUEnB,OAAO,qBAAEc,KAAK,CAACsB,QAAR,6DAAoB,EAV7B;IAWE/B,eAAe,EAAE,CAACC,cAAD,EAAiBE,kBAAjB,EAAqCE,mBAArC,EAA0D2B,IAA1D,CAA+DC,OAA/D,CAXnB;IAYEhC,cAZF;IAaEC,kBAbF;IAcEC,kBAdF;IAeEC,sBAfF;IAgBEC,mBAhBF;IAiBEC,uBAjBF;IAkBET,MAAM,EAAEmB,UAlBV;IAmBET,iBAAiB,2BAAEE,KAAK,CAACyB,mBAAR,yEAA+B;EAnBlD,CADK,EAsBLtB,QAtBK,CAAP;AAwBD,CAzDM;AA2DP,OAAO,MAAMuB,oBAAoB,GAAG,CAClCC,sBADkC,EAElCrB,WAFkC,EAGlCsB,gBAHkC,KAIxB;EACV,MAAMC,QAA2B,GAAGD,gBAAgB,CAACtB,WAAW,CAACtB,EAAb,CAApD;EAEA,MAAM;IACJC,gBADI;IAEJC,OAFI;IAGJK,eAHI;IAIJC,cAJI;IAKJC,kBALI;IAMJC,kBANI;IAOJC,sBAPI;IAQJC,mBARI;IASJC;EATI,IAUFS,WAVJ;EAYA,MAAMgB,QAAQ,GAAGrC,gBAAgB,IAAIC,OAApB,GAA8BA,OAA9B,GAAwC,EAAzD;EAEA,MAAM4C,iBAAiB,GAAGvC,eAAe,IAAIC,cAA7C;EACA,MAAMuB,UAAU,GAAGe,iBAAiB,GAAI,GAAEtC,cAAe,GAAEC,kBAAmB,EAA1C,GAA8CrB,SAAlF;EAEA,MAAM2D,qBAAqB,GAAGxC,eAAe,IAAIG,kBAAjD;EACA,MAAMsB,cAAc,GAAGe,qBAAqB,GAAI,GAAErC,kBAAmB,GAAEC,sBAAuB,EAAlD,GAAsDvB,SAAlG;EAEA,MAAM4D,sBAAsB,GAAGzC,eAAe,IAAIK,mBAAlD;EACA,MAAMqB,eAAe,GAAGe,sBAAsB,GAAI,GAAEpC,mBAAoB,GAAEC,uBAAwB,EAApD,GAAwDzB,SAAtG;EAEA,MAAM6D,OAAc,qBACdJ,QADc,aACdA,QADc,cACdA,QADc,GACF,EADE;IAElBxC,QAAQ,EAAEiB,WAAW,CAACjB,QAFJ;IAGlBiC,QAAQ,EAAEA,QAHQ;IAIlBnC,eAAe,EAAEmB,WAAW,CAACnB,eAAZ,CAA4BkB,MAA5B,GACbC,WAAW,CAACnB,eAAZ,CAA4BN,GAA5B,CAAiCiC,OAAD,IAAa,CAACA,OAAO,CAACnD,IAAT,EAAemD,OAAO,CAACjD,QAAvB,EAAiCiD,OAAO,CAAClD,KAAzC,CAA7C,CADa,GAEbQ,SANc;IAOlB8C,KAAK,EAAE9C,SAPW;IAOA;IAClB+C,QAAQ,EAAE/C,SARQ;IAQG;IACrB2C,UATkB;IAUlBC,cAVkB;IAWlBC,eAXkB;IAYlB7B,MAAM,EAAEkB,WAAW,CAAClB,MAAZ,CAAmBP,GAAnB,CAAwB4B,QAAD,IAC7BiB,oBAAoB,CAACC,sBAAD,EAAyBlB,QAAzB,EAAmCmB,gBAAnC,CADd,CAZU;IAelBH,mBAAmB,EAAEnB,WAAW,CAACR;EAff,EAApB;;EAkBA,IAAI6B,sBAAsB,KAAK3E,yBAA/B,EAA0D;IACxDiF,OAAO,CAAC5E,QAAR,GAAmBiD,WAAW,CAACnB,eAAZ,CAA4BN,GAA5B,CAAgC,CAAC;MAAElB,IAAF;MAAQE,QAAR;MAAkBD;IAAlB,CAAD,KAAgC,GAAED,IAAK,GAAEE,QAAS,GAAED,KAAM,EAA1F,CAAnB;IACAqE,OAAO,CAAC9C,eAAR,GAA0Bf,SAA1B;EACD,CAHD,MAGO;IACL6D,OAAO,CAAC5E,QAAR,GAAmBe,SAAnB;EACD;;EAED,IAAIkC,WAAW,CAAChB,QAAhB,EAA0B;IACxB2C,OAAO,CAAC3C,QAAR,GAAmBgB,WAAW,CAAChB,QAA/B;EACD;;EAED,OAAO1C,MAAM,CAACqF,OAAD,EAAUtF,WAAV,CAAb;AACD,CA5DM;AA8DP,OAAO,MAAMuF,uBAAuB,GAAIC,GAAD,KAA2C;EAChFC,KAAK,EAAED,GADyE;EAEhFvE,KAAK,EAAEuE;AAFyE,CAA3C,CAAhC;AAKP,OAAO,MAAME,yBAAyB,GAAIzD,GAAD,IACvC,CAACA,GAAD,aAACA,GAAD,cAACA,GAAD,GAAQ,EAAR,EAAYC,GAAZ,CAAgBqD,uBAAhB,CADK;AAGP,OAAO,MAAMI,sBAAsB,GAAI5D,eAAD,IAAsD;EAAA;;EAC1F,IAAI,CAACA,eAAL,EAAsB;IACpB,OAAO,EAAP;EACD;;EAED,gCAAOD,uBAAuB,CAACC,eAAD,CAA9B,yEAAmD,EAAnD;AACD,CANM;AAQP,OAAO,MAAM6D,4BAA4B,GACvCC,gBAD0C,IAE7B;EACb,IAAI,CAACA,gBAAL,EAAuB;IACrB,OAAO,EAAP;EACD;;EAED,OAAO7D,yBAAyB,CAAC6D,gBAAD,CAAhC;AACD,CARM;AAUP,OAAO,MAAMC,uBAAyC,GAAI7E,KAAD,IAAW;EAClE,IAAI,CAACA,KAAL,EAAY;IACV,OAAOQ,SAAP;EACD;;EAED,OAAO,CAAC,QAAQsE,IAAR,CAAa9E,KAAb,CAAD,GAAuB,6BAAvB,GAAuDQ,SAA9D;AACD,CANM"},"metadata":{},"sourceType":"module"}