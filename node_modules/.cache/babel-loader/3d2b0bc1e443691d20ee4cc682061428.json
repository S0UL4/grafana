{"ast":null,"code":"import { textUtil } from '../text';\nimport { urlUtil } from './url';\nlet grafanaConfig = {\n  appSubUrl: ''\n};\nlet getTimeRangeUrlParams;\nlet getVariablesUrlParams;\n\nconst maybeParseUrl = input => {\n  try {\n    return new URL(input);\n  } catch {\n    return undefined;\n  }\n};\n/**\n *\n * @param url\n * @internal\n */\n\n\nconst stripBaseFromUrl = urlOrPath => {\n  var _grafanaConfig$appSub;\n\n  // Will only return a URL object if the input is actually a valid URL\n  const parsedUrl = maybeParseUrl(urlOrPath);\n\n  if (parsedUrl) {\n    // If the input is a URL, and for a different origin that we're on, just bail\n    // and return it. There's no need to strip anything from it\n    if (parsedUrl.origin !== window.location.origin) {\n      return urlOrPath;\n    }\n  }\n\n  const appSubUrl = (_grafanaConfig$appSub = grafanaConfig.appSubUrl) !== null && _grafanaConfig$appSub !== void 0 ? _grafanaConfig$appSub : '';\n  const stripExtraChars = appSubUrl.endsWith('/') ? 1 : 0;\n  const isAbsoluteUrl = urlOrPath.startsWith('http');\n  let segmentToStrip = appSubUrl;\n\n  if (!urlOrPath.startsWith('/') || isAbsoluteUrl) {\n    segmentToStrip = `${window.location.origin}${appSubUrl}`;\n  }\n\n  return urlOrPath.length > 0 && urlOrPath.indexOf(segmentToStrip) === 0 ? urlOrPath.slice(segmentToStrip.length - stripExtraChars) : urlOrPath;\n};\n/**\n *\n * @param url\n * @internal\n */\n\n\nconst assureBaseUrl = url => {\n  if (url.startsWith('/')) {\n    return `${grafanaConfig.appSubUrl}${stripBaseFromUrl(url)}`;\n  }\n\n  return url;\n};\n/**\n *\n * @param location\n * @param searchParamsToUpdate\n * @returns\n */\n\n\nconst getUrlForPartial = (location, searchParamsToUpdate) => {\n  const searchParams = urlUtil.parseKeyValue(location.search.startsWith('?') ? location.search.substring(1) : location.search);\n\n  for (const key of Object.keys(searchParamsToUpdate)) {\n    // removing params with null | undefined\n    if (searchParamsToUpdate[key] === null || searchParamsToUpdate[key] === undefined) {\n      delete searchParams[key];\n    } else {\n      searchParams[key] = searchParamsToUpdate[key];\n    }\n  }\n\n  return urlUtil.renderUrl(location.pathname, searchParams);\n};\n/**\n * @deprecated use `getUrlForPartial` instead\n * Update URL or search param string `init` with new params `partial`.\n */\n\n\nconst updateSearchParams = (init, partial) => {\n  const urlSearchParams = new URLSearchParams(partial); // Check if full URL\n\n  try {\n    const curURL = new URL(init);\n    urlSearchParams.forEach((val, key) => curURL.searchParams.set(key, val));\n    return curURL.href;\n  } catch {\n    // assume search params\n    const newSearchParams = new URLSearchParams(init);\n    urlSearchParams.forEach((v, k) => {\n      newSearchParams.set(k, v);\n    });\n    return '?' + newSearchParams.toString();\n  }\n};\n\nexport const locationUtil = {\n  /**\n   *\n   * @param getConfig\n   * @param getAllVariableValuesForUrl\n   * @param getTimeRangeForUrl\n   * @internal\n   */\n  initialize: dependencies => {\n    grafanaConfig = dependencies.config;\n    getTimeRangeUrlParams = dependencies.getTimeRangeForUrl;\n    getVariablesUrlParams = dependencies.getVariablesUrlParams;\n  },\n  stripBaseFromUrl,\n  assureBaseUrl,\n  updateSearchParams,\n  getTimeRangeUrlParams: () => {\n    if (!getTimeRangeUrlParams) {\n      return null;\n    }\n\n    return urlUtil.toUrlParams(getTimeRangeUrlParams());\n  },\n  getVariablesUrlParams: scopedVars => {\n    if (!getVariablesUrlParams) {\n      return null;\n    }\n\n    const params = getVariablesUrlParams(scopedVars);\n    return urlUtil.toUrlParams(params);\n  },\n  getUrlForPartial,\n  processUrl: url => {\n    return grafanaConfig.disableSanitizeHtml ? url : textUtil.sanitizeUrl(url);\n  }\n};","map":{"version":3,"names":["textUtil","urlUtil","grafanaConfig","appSubUrl","getTimeRangeUrlParams","getVariablesUrlParams","maybeParseUrl","input","URL","undefined","stripBaseFromUrl","urlOrPath","parsedUrl","origin","window","location","stripExtraChars","endsWith","isAbsoluteUrl","startsWith","segmentToStrip","length","indexOf","slice","assureBaseUrl","url","getUrlForPartial","searchParamsToUpdate","searchParams","parseKeyValue","search","substring","key","Object","keys","renderUrl","pathname","updateSearchParams","init","partial","urlSearchParams","URLSearchParams","curURL","forEach","val","set","href","newSearchParams","v","k","toString","locationUtil","initialize","dependencies","config","getTimeRangeForUrl","toUrlParams","scopedVars","params","processUrl","disableSanitizeHtml","sanitizeUrl"],"sources":["/home/soula/grafana/packages/grafana-data/src/utils/location.ts"],"sourcesContent":["import { Location } from 'history';\n\nimport { textUtil } from '../text';\nimport { GrafanaConfig, RawTimeRange, ScopedVars } from '../types';\n\nimport { UrlQueryMap, urlUtil } from './url';\n\nlet grafanaConfig: GrafanaConfig = { appSubUrl: '' } as any;\nlet getTimeRangeUrlParams: () => RawTimeRange;\nlet getVariablesUrlParams: (scopedVars?: ScopedVars) => UrlQueryMap;\n\nconst maybeParseUrl = (input: string): URL | undefined => {\n  try {\n    return new URL(input);\n  } catch {\n    return undefined;\n  }\n};\n\n/**\n *\n * @param url\n * @internal\n */\nconst stripBaseFromUrl = (urlOrPath: string): string => {\n  // Will only return a URL object if the input is actually a valid URL\n  const parsedUrl = maybeParseUrl(urlOrPath);\n  if (parsedUrl) {\n    // If the input is a URL, and for a different origin that we're on, just bail\n    // and return it. There's no need to strip anything from it\n    if (parsedUrl.origin !== window.location.origin) {\n      return urlOrPath;\n    }\n  }\n\n  const appSubUrl = grafanaConfig.appSubUrl ?? '';\n  const stripExtraChars = appSubUrl.endsWith('/') ? 1 : 0;\n  const isAbsoluteUrl = urlOrPath.startsWith('http');\n\n  let segmentToStrip = appSubUrl;\n\n  if (!urlOrPath.startsWith('/') || isAbsoluteUrl) {\n    segmentToStrip = `${window.location.origin}${appSubUrl}`;\n  }\n\n  return urlOrPath.length > 0 && urlOrPath.indexOf(segmentToStrip) === 0\n    ? urlOrPath.slice(segmentToStrip.length - stripExtraChars)\n    : urlOrPath;\n};\n\n/**\n *\n * @param url\n * @internal\n */\nconst assureBaseUrl = (url: string): string => {\n  if (url.startsWith('/')) {\n    return `${grafanaConfig.appSubUrl}${stripBaseFromUrl(url)}`;\n  }\n  return url;\n};\n\n/**\n *\n * @param location\n * @param searchParamsToUpdate\n * @returns\n */\nconst getUrlForPartial = (location: Location<any>, searchParamsToUpdate: Record<string, any>) => {\n  const searchParams = urlUtil.parseKeyValue(\n    location.search.startsWith('?') ? location.search.substring(1) : location.search\n  );\n  for (const key of Object.keys(searchParamsToUpdate)) {\n    // removing params with null | undefined\n    if (searchParamsToUpdate[key] === null || searchParamsToUpdate[key] === undefined) {\n      delete searchParams[key];\n    } else {\n      searchParams[key] = searchParamsToUpdate[key];\n    }\n  }\n  return urlUtil.renderUrl(location.pathname, searchParams);\n};\n\n/**\n * @deprecated use `getUrlForPartial` instead\n * Update URL or search param string `init` with new params `partial`.\n */\nconst updateSearchParams = (init: string, partial: string) => {\n  const urlSearchParams = new URLSearchParams(partial);\n\n  // Check if full URL\n  try {\n    const curURL = new URL(init);\n    urlSearchParams.forEach((val, key) => curURL.searchParams.set(key, val));\n    return curURL.href;\n  } catch {\n    // assume search params\n    const newSearchParams = new URLSearchParams(init);\n    urlSearchParams.forEach((v, k) => {\n      newSearchParams.set(k, v);\n    });\n    return '?' + newSearchParams.toString();\n  }\n};\n\ninterface LocationUtilDependencies {\n  config: GrafanaConfig;\n  getTimeRangeForUrl: () => RawTimeRange;\n  getVariablesUrlParams: (scopedVars?: ScopedVars) => UrlQueryMap;\n}\n\nexport const locationUtil = {\n  /**\n   *\n   * @param getConfig\n   * @param getAllVariableValuesForUrl\n   * @param getTimeRangeForUrl\n   * @internal\n   */\n  initialize: (dependencies: LocationUtilDependencies) => {\n    grafanaConfig = dependencies.config;\n    getTimeRangeUrlParams = dependencies.getTimeRangeForUrl;\n    getVariablesUrlParams = dependencies.getVariablesUrlParams;\n  },\n  stripBaseFromUrl,\n  assureBaseUrl,\n  updateSearchParams,\n  getTimeRangeUrlParams: () => {\n    if (!getTimeRangeUrlParams) {\n      return null;\n    }\n    return urlUtil.toUrlParams(getTimeRangeUrlParams());\n  },\n  getVariablesUrlParams: (scopedVars?: ScopedVars) => {\n    if (!getVariablesUrlParams) {\n      return null;\n    }\n    const params = getVariablesUrlParams(scopedVars);\n    return urlUtil.toUrlParams(params);\n  },\n  getUrlForPartial,\n  processUrl: (url: string) => {\n    return grafanaConfig.disableSanitizeHtml ? url : textUtil.sanitizeUrl(url);\n  },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}