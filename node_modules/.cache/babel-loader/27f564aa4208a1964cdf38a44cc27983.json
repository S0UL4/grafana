{"ast":null,"code":"import { createSlice } from '@reduxjs/toolkit';\nimport { cloneDeep, defaults as lodashDefaults } from 'lodash';\nimport { LoadingState } from '@grafana/data';\nimport { variableAdapters } from '../adapters';\nimport { changeVariableNameSucceeded } from '../editor/reducer';\nimport { ensureStringValues } from '../utils';\nimport { getInstanceState, getNextVariableIndex } from './selectors';\nimport { initialVariablesState } from './types';\nconst sharedReducerSlice = createSlice({\n  name: 'templating/shared',\n  initialState: initialVariablesState,\n  reducers: {\n    addVariable: (state, action) => {\n      var _action$payload$id;\n\n      const id = (_action$payload$id = action.payload.id) !== null && _action$payload$id !== void 0 ? _action$payload$id : action.payload.data.model.name; // for testing purposes we can call this with an id\n\n      const adapter = variableAdapters.get(action.payload.type);\n      const initialState = cloneDeep(adapter.initialState);\n      const model = adapter.beforeAdding ? adapter.beforeAdding(action.payload.data.model) : cloneDeep(action.payload.data.model);\n      const variable = Object.assign({}, lodashDefaults({}, model, initialState), {\n        id: id,\n        index: action.payload.data.index,\n        global: action.payload.data.global\n      });\n      state[id] = variable;\n    },\n    variableStateNotStarted: (state, action) => {\n      const instanceState = getInstanceState(state, action.payload.id);\n      instanceState.state = LoadingState.NotStarted;\n      instanceState.error = null;\n    },\n    variableStateFetching: (state, action) => {\n      const instanceState = getInstanceState(state, action.payload.id);\n      instanceState.state = LoadingState.Loading;\n      instanceState.error = null;\n    },\n    variableStateCompleted: (state, action) => {\n      const instanceState = getInstanceState(state, action.payload.id);\n\n      if (!instanceState) {\n        // we might have cancelled a batch so then this state has been removed\n        return;\n      }\n\n      instanceState.state = LoadingState.Done;\n      instanceState.error = null;\n    },\n    variableStateFailed: (state, action) => {\n      const instanceState = getInstanceState(state, action.payload.id);\n\n      if (!instanceState) {\n        // we might have cancelled a batch so then this state has been removed\n        return;\n      }\n\n      instanceState.state = LoadingState.Error;\n      instanceState.error = action.payload.data.error;\n    },\n    removeVariable: (state, action) => {\n      delete state[action.payload.id];\n\n      if (!action.payload.data.reIndex) {\n        return;\n      }\n\n      const variableStates = Object.values(state);\n\n      for (let index = 0; index < variableStates.length; index++) {\n        variableStates[index].index = index;\n      }\n    },\n    duplicateVariable: (state, action) => {\n      var _action$payload$data$, _action$payload$data;\n\n      const original = cloneDeep(state[action.payload.id]);\n      const name = `copy_of_${original.name}`;\n      const newId = (_action$payload$data$ = (_action$payload$data = action.payload.data) === null || _action$payload$data === void 0 ? void 0 : _action$payload$data.newId) !== null && _action$payload$data$ !== void 0 ? _action$payload$data$ : name;\n      const index = getNextVariableIndex(Object.values(state));\n      state[newId] = Object.assign({}, cloneDeep(variableAdapters.get(action.payload.type).initialState), original, {\n        id: newId,\n        name,\n        index\n      });\n    },\n    changeVariableOrder: (state, action) => {\n      const {\n        toIndex,\n        fromIndex\n      } = action.payload.data;\n      const variableStates = Object.values(state);\n\n      for (let index = 0; index < variableStates.length; index++) {\n        const variable = variableStates[index];\n\n        if (variable.index === fromIndex) {\n          variable.index = toIndex;\n        } else if (variable.index > fromIndex && variable.index <= toIndex) {\n          variable.index--;\n        } else if (variable.index < fromIndex && variable.index >= toIndex) {\n          variable.index++;\n        }\n      }\n    },\n    changeVariableType: (state, action) => {\n      const {\n        id\n      } = action.payload;\n      const {\n        label,\n        name,\n        index,\n        description,\n        rootStateKey\n      } = state[id];\n      state[id] = Object.assign({}, cloneDeep(variableAdapters.get(action.payload.data.newType).initialState), {\n        id,\n        rootStateKey: rootStateKey,\n        label,\n        name,\n        index,\n        description\n      });\n    },\n    setCurrentVariableValue: (state, action) => {\n      if (!action.payload.data.option) {\n        return;\n      }\n\n      const instanceState = getInstanceState(state, action.payload.id);\n      const {\n        option\n      } = action.payload.data;\n      const current = Object.assign({}, option, {\n        text: ensureStringValues(option === null || option === void 0 ? void 0 : option.text),\n        value: ensureStringValues(option === null || option === void 0 ? void 0 : option.value)\n      });\n      instanceState.current = current;\n      instanceState.options = instanceState.options.map(option => {\n        option.value = ensureStringValues(option.value);\n        option.text = ensureStringValues(option.text);\n        let selected = false;\n\n        if (Array.isArray(current.value)) {\n          for (let index = 0; index < current.value.length; index++) {\n            const value = current.value[index];\n\n            if (option.value === value) {\n              selected = true;\n              break;\n            }\n          }\n        } else if (option.value === current.value) {\n          selected = true;\n        }\n\n        option.selected = selected;\n        return option;\n      });\n    },\n    changeVariableProp: (state, action) => {\n      const instanceState = getInstanceState(state, action.payload.id);\n      instanceState[action.payload.data.propName] = action.payload.data.propValue;\n    }\n  },\n  extraReducers: builder => builder.addCase(changeVariableNameSucceeded, (state, action) => {\n    const instanceState = getInstanceState(state, action.payload.id);\n    instanceState.name = action.payload.data.newName;\n  })\n});\nexport const sharedReducer = sharedReducerSlice.reducer;\nexport const {\n  removeVariable,\n  addVariable,\n  changeVariableProp,\n  changeVariableOrder,\n  duplicateVariable,\n  setCurrentVariableValue,\n  changeVariableType,\n  variableStateNotStarted,\n  variableStateFetching,\n  variableStateCompleted,\n  variableStateFailed\n} = sharedReducerSlice.actions;","map":{"version":3,"names":["createSlice","cloneDeep","defaults","lodashDefaults","LoadingState","variableAdapters","changeVariableNameSucceeded","ensureStringValues","getInstanceState","getNextVariableIndex","initialVariablesState","sharedReducerSlice","name","initialState","reducers","addVariable","state","action","id","payload","data","model","adapter","get","type","beforeAdding","variable","index","global","variableStateNotStarted","instanceState","NotStarted","error","variableStateFetching","Loading","variableStateCompleted","Done","variableStateFailed","Error","removeVariable","reIndex","variableStates","Object","values","length","duplicateVariable","original","newId","changeVariableOrder","toIndex","fromIndex","changeVariableType","label","description","rootStateKey","newType","setCurrentVariableValue","option","current","text","value","options","map","selected","Array","isArray","changeVariableProp","propName","propValue","extraReducers","builder","addCase","newName","sharedReducer","reducer","actions"],"sources":["/home/soula/grafana/public/app/features/variables/state/sharedReducer.ts"],"sourcesContent":["import { createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport { cloneDeep, defaults as lodashDefaults } from 'lodash';\n\nimport { LoadingState, VariableType } from '@grafana/data';\n\nimport { variableAdapters } from '../adapters';\nimport { changeVariableNameSucceeded } from '../editor/reducer';\nimport { VariableModel, VariableOption, VariableWithOptions } from '../types';\nimport { ensureStringValues } from '../utils';\n\nimport { getInstanceState, getNextVariableIndex } from './selectors';\nimport { AddVariable, initialVariablesState, VariablePayload, VariablesState } from './types';\n\nconst sharedReducerSlice = createSlice({\n  name: 'templating/shared',\n  initialState: initialVariablesState,\n  reducers: {\n    addVariable: (state: VariablesState, action: PayloadAction<VariablePayload<AddVariable>>) => {\n      const id = action.payload.id ?? action.payload.data.model.name; // for testing purposes we can call this with an id\n      const adapter = variableAdapters.get(action.payload.type);\n      const initialState = cloneDeep(adapter.initialState);\n      const model = adapter.beforeAdding\n        ? adapter.beforeAdding(action.payload.data.model)\n        : cloneDeep(action.payload.data.model);\n\n      const variable = {\n        ...lodashDefaults({}, model, initialState),\n        id: id,\n        index: action.payload.data.index,\n        global: action.payload.data.global,\n      };\n\n      state[id] = variable;\n    },\n    variableStateNotStarted: (state: VariablesState, action: PayloadAction<VariablePayload>) => {\n      const instanceState = getInstanceState(state, action.payload.id);\n      instanceState.state = LoadingState.NotStarted;\n      instanceState.error = null;\n    },\n    variableStateFetching: (state: VariablesState, action: PayloadAction<VariablePayload>) => {\n      const instanceState = getInstanceState(state, action.payload.id);\n      instanceState.state = LoadingState.Loading;\n      instanceState.error = null;\n    },\n    variableStateCompleted: (state: VariablesState, action: PayloadAction<VariablePayload>) => {\n      const instanceState = getInstanceState(state, action.payload.id);\n      if (!instanceState) {\n        // we might have cancelled a batch so then this state has been removed\n        return;\n      }\n      instanceState.state = LoadingState.Done;\n      instanceState.error = null;\n    },\n    variableStateFailed: (state: VariablesState, action: PayloadAction<VariablePayload<{ error: any }>>) => {\n      const instanceState = getInstanceState(state, action.payload.id);\n      if (!instanceState) {\n        // we might have cancelled a batch so then this state has been removed\n        return;\n      }\n      instanceState.state = LoadingState.Error;\n      instanceState.error = action.payload.data.error;\n    },\n    removeVariable: (state: VariablesState, action: PayloadAction<VariablePayload<{ reIndex: boolean }>>) => {\n      delete state[action.payload.id];\n      if (!action.payload.data.reIndex) {\n        return;\n      }\n\n      const variableStates = Object.values(state);\n      for (let index = 0; index < variableStates.length; index++) {\n        variableStates[index].index = index;\n      }\n    },\n    duplicateVariable: (state: VariablesState, action: PayloadAction<VariablePayload<{ newId: string }>>) => {\n      const original = cloneDeep<VariableModel>(state[action.payload.id]);\n      const name = `copy_of_${original.name}`;\n      const newId = action.payload.data?.newId ?? name;\n      const index = getNextVariableIndex(Object.values(state));\n      state[newId] = {\n        ...cloneDeep(variableAdapters.get(action.payload.type).initialState),\n        ...original,\n        id: newId,\n        name,\n        index,\n      };\n    },\n    changeVariableOrder: (\n      state: VariablesState,\n      action: PayloadAction<VariablePayload<{ fromIndex: number; toIndex: number }>>\n    ) => {\n      const { toIndex, fromIndex } = action.payload.data;\n      const variableStates = Object.values(state);\n      for (let index = 0; index < variableStates.length; index++) {\n        const variable = variableStates[index];\n        if (variable.index === fromIndex) {\n          variable.index = toIndex;\n        } else if (variable.index > fromIndex && variable.index <= toIndex) {\n          variable.index--;\n        } else if (variable.index < fromIndex && variable.index >= toIndex) {\n          variable.index++;\n        }\n      }\n    },\n    changeVariableType: (state: VariablesState, action: PayloadAction<VariablePayload<{ newType: VariableType }>>) => {\n      const { id } = action.payload;\n      const { label, name, index, description, rootStateKey } = state[id];\n\n      state[id] = {\n        ...cloneDeep(variableAdapters.get(action.payload.data.newType).initialState),\n        id,\n        rootStateKey: rootStateKey,\n        label,\n        name,\n        index,\n        description,\n      };\n    },\n    setCurrentVariableValue: (\n      state: VariablesState,\n      action: PayloadAction<VariablePayload<{ option: VariableOption | undefined }>>\n    ) => {\n      if (!action.payload.data.option) {\n        return;\n      }\n\n      const instanceState = getInstanceState<VariableWithOptions>(state, action.payload.id);\n      const { option } = action.payload.data;\n      const current = { ...option, text: ensureStringValues(option?.text), value: ensureStringValues(option?.value) };\n\n      instanceState.current = current;\n      instanceState.options = instanceState.options.map((option) => {\n        option.value = ensureStringValues(option.value);\n        option.text = ensureStringValues(option.text);\n        let selected = false;\n        if (Array.isArray(current.value)) {\n          for (let index = 0; index < current.value.length; index++) {\n            const value = current.value[index];\n            if (option.value === value) {\n              selected = true;\n              break;\n            }\n          }\n        } else if (option.value === current.value) {\n          selected = true;\n        }\n        option.selected = selected;\n        return option;\n      });\n    },\n    changeVariableProp: (\n      state: VariablesState,\n      action: PayloadAction<VariablePayload<{ propName: string; propValue: any }>>\n    ) => {\n      const instanceState = getInstanceState(state, action.payload.id);\n      (instanceState as Record<string, any>)[action.payload.data.propName] = action.payload.data.propValue;\n    },\n  },\n  extraReducers: (builder) =>\n    builder.addCase(changeVariableNameSucceeded, (state, action) => {\n      const instanceState = getInstanceState(state, action.payload.id);\n      instanceState.name = action.payload.data.newName;\n    }),\n});\n\nexport const sharedReducer = sharedReducerSlice.reducer;\n\nexport const {\n  removeVariable,\n  addVariable,\n  changeVariableProp,\n  changeVariableOrder,\n  duplicateVariable,\n  setCurrentVariableValue,\n  changeVariableType,\n  variableStateNotStarted,\n  variableStateFetching,\n  variableStateCompleted,\n  variableStateFailed,\n} = sharedReducerSlice.actions;\n"],"mappings":"AAAA,SAASA,WAAT,QAA2C,kBAA3C;AACA,SAASC,SAAT,EAAoBC,QAAQ,IAAIC,cAAhC,QAAsD,QAAtD;AAEA,SAASC,YAAT,QAA2C,eAA3C;AAEA,SAASC,gBAAT,QAAiC,aAAjC;AACA,SAASC,2BAAT,QAA4C,mBAA5C;AAEA,SAASC,kBAAT,QAAmC,UAAnC;AAEA,SAASC,gBAAT,EAA2BC,oBAA3B,QAAuD,aAAvD;AACA,SAAsBC,qBAAtB,QAAoF,SAApF;AAEA,MAAMC,kBAAkB,GAAGX,WAAW,CAAC;EACrCY,IAAI,EAAE,mBAD+B;EAErCC,YAAY,EAAEH,qBAFuB;EAGrCI,QAAQ,EAAE;IACRC,WAAW,EAAE,CAACC,KAAD,EAAwBC,MAAxB,KAAgF;MAAA;;MAC3F,MAAMC,EAAE,yBAAGD,MAAM,CAACE,OAAP,CAAeD,EAAlB,mEAAwBD,MAAM,CAACE,OAAP,CAAeC,IAAf,CAAoBC,KAApB,CAA0BT,IAA1D,CAD2F,CAC3B;;MAChE,MAAMU,OAAO,GAAGjB,gBAAgB,CAACkB,GAAjB,CAAqBN,MAAM,CAACE,OAAP,CAAeK,IAApC,CAAhB;MACA,MAAMX,YAAY,GAAGZ,SAAS,CAACqB,OAAO,CAACT,YAAT,CAA9B;MACA,MAAMQ,KAAK,GAAGC,OAAO,CAACG,YAAR,GACVH,OAAO,CAACG,YAAR,CAAqBR,MAAM,CAACE,OAAP,CAAeC,IAAf,CAAoBC,KAAzC,CADU,GAEVpB,SAAS,CAACgB,MAAM,CAACE,OAAP,CAAeC,IAAf,CAAoBC,KAArB,CAFb;MAIA,MAAMK,QAAQ,qBACTvB,cAAc,CAAC,EAAD,EAAKkB,KAAL,EAAYR,YAAZ,CADL;QAEZK,EAAE,EAAEA,EAFQ;QAGZS,KAAK,EAAEV,MAAM,CAACE,OAAP,CAAeC,IAAf,CAAoBO,KAHf;QAIZC,MAAM,EAAEX,MAAM,CAACE,OAAP,CAAeC,IAAf,CAAoBQ;MAJhB,EAAd;MAOAZ,KAAK,CAACE,EAAD,CAAL,GAAYQ,QAAZ;IACD,CAjBO;IAkBRG,uBAAuB,EAAE,CAACb,KAAD,EAAwBC,MAAxB,KAAmE;MAC1F,MAAMa,aAAa,GAAGtB,gBAAgB,CAACQ,KAAD,EAAQC,MAAM,CAACE,OAAP,CAAeD,EAAvB,CAAtC;MACAY,aAAa,CAACd,KAAd,GAAsBZ,YAAY,CAAC2B,UAAnC;MACAD,aAAa,CAACE,KAAd,GAAsB,IAAtB;IACD,CAtBO;IAuBRC,qBAAqB,EAAE,CAACjB,KAAD,EAAwBC,MAAxB,KAAmE;MACxF,MAAMa,aAAa,GAAGtB,gBAAgB,CAACQ,KAAD,EAAQC,MAAM,CAACE,OAAP,CAAeD,EAAvB,CAAtC;MACAY,aAAa,CAACd,KAAd,GAAsBZ,YAAY,CAAC8B,OAAnC;MACAJ,aAAa,CAACE,KAAd,GAAsB,IAAtB;IACD,CA3BO;IA4BRG,sBAAsB,EAAE,CAACnB,KAAD,EAAwBC,MAAxB,KAAmE;MACzF,MAAMa,aAAa,GAAGtB,gBAAgB,CAACQ,KAAD,EAAQC,MAAM,CAACE,OAAP,CAAeD,EAAvB,CAAtC;;MACA,IAAI,CAACY,aAAL,EAAoB;QAClB;QACA;MACD;;MACDA,aAAa,CAACd,KAAd,GAAsBZ,YAAY,CAACgC,IAAnC;MACAN,aAAa,CAACE,KAAd,GAAsB,IAAtB;IACD,CApCO;IAqCRK,mBAAmB,EAAE,CAACrB,KAAD,EAAwBC,MAAxB,KAAmF;MACtG,MAAMa,aAAa,GAAGtB,gBAAgB,CAACQ,KAAD,EAAQC,MAAM,CAACE,OAAP,CAAeD,EAAvB,CAAtC;;MACA,IAAI,CAACY,aAAL,EAAoB;QAClB;QACA;MACD;;MACDA,aAAa,CAACd,KAAd,GAAsBZ,YAAY,CAACkC,KAAnC;MACAR,aAAa,CAACE,KAAd,GAAsBf,MAAM,CAACE,OAAP,CAAeC,IAAf,CAAoBY,KAA1C;IACD,CA7CO;IA8CRO,cAAc,EAAE,CAACvB,KAAD,EAAwBC,MAAxB,KAAyF;MACvG,OAAOD,KAAK,CAACC,MAAM,CAACE,OAAP,CAAeD,EAAhB,CAAZ;;MACA,IAAI,CAACD,MAAM,CAACE,OAAP,CAAeC,IAAf,CAAoBoB,OAAzB,EAAkC;QAChC;MACD;;MAED,MAAMC,cAAc,GAAGC,MAAM,CAACC,MAAP,CAAc3B,KAAd,CAAvB;;MACA,KAAK,IAAIW,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAGc,cAAc,CAACG,MAA3C,EAAmDjB,KAAK,EAAxD,EAA4D;QAC1Dc,cAAc,CAACd,KAAD,CAAd,CAAsBA,KAAtB,GAA8BA,KAA9B;MACD;IACF,CAxDO;IAyDRkB,iBAAiB,EAAE,CAAC7B,KAAD,EAAwBC,MAAxB,KAAsF;MAAA;;MACvG,MAAM6B,QAAQ,GAAG7C,SAAS,CAAgBe,KAAK,CAACC,MAAM,CAACE,OAAP,CAAeD,EAAhB,CAArB,CAA1B;MACA,MAAMN,IAAI,GAAI,WAAUkC,QAAQ,CAAClC,IAAK,EAAtC;MACA,MAAMmC,KAAK,oDAAG9B,MAAM,CAACE,OAAP,CAAeC,IAAlB,yDAAG,qBAAqB2B,KAAxB,yEAAiCnC,IAA5C;MACA,MAAMe,KAAK,GAAGlB,oBAAoB,CAACiC,MAAM,CAACC,MAAP,CAAc3B,KAAd,CAAD,CAAlC;MACAA,KAAK,CAAC+B,KAAD,CAAL,qBACK9C,SAAS,CAACI,gBAAgB,CAACkB,GAAjB,CAAqBN,MAAM,CAACE,OAAP,CAAeK,IAApC,EAA0CX,YAA3C,CADd,EAEKiC,QAFL;QAGE5B,EAAE,EAAE6B,KAHN;QAIEnC,IAJF;QAKEe;MALF;IAOD,CArEO;IAsERqB,mBAAmB,EAAE,CACnBhC,KADmB,EAEnBC,MAFmB,KAGhB;MACH,MAAM;QAAEgC,OAAF;QAAWC;MAAX,IAAyBjC,MAAM,CAACE,OAAP,CAAeC,IAA9C;MACA,MAAMqB,cAAc,GAAGC,MAAM,CAACC,MAAP,CAAc3B,KAAd,CAAvB;;MACA,KAAK,IAAIW,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAGc,cAAc,CAACG,MAA3C,EAAmDjB,KAAK,EAAxD,EAA4D;QAC1D,MAAMD,QAAQ,GAAGe,cAAc,CAACd,KAAD,CAA/B;;QACA,IAAID,QAAQ,CAACC,KAAT,KAAmBuB,SAAvB,EAAkC;UAChCxB,QAAQ,CAACC,KAAT,GAAiBsB,OAAjB;QACD,CAFD,MAEO,IAAIvB,QAAQ,CAACC,KAAT,GAAiBuB,SAAjB,IAA8BxB,QAAQ,CAACC,KAAT,IAAkBsB,OAApD,EAA6D;UAClEvB,QAAQ,CAACC,KAAT;QACD,CAFM,MAEA,IAAID,QAAQ,CAACC,KAAT,GAAiBuB,SAAjB,IAA8BxB,QAAQ,CAACC,KAAT,IAAkBsB,OAApD,EAA6D;UAClEvB,QAAQ,CAACC,KAAT;QACD;MACF;IACF,CAtFO;IAuFRwB,kBAAkB,EAAE,CAACnC,KAAD,EAAwBC,MAAxB,KAA8F;MAChH,MAAM;QAAEC;MAAF,IAASD,MAAM,CAACE,OAAtB;MACA,MAAM;QAAEiC,KAAF;QAASxC,IAAT;QAAee,KAAf;QAAsB0B,WAAtB;QAAmCC;MAAnC,IAAoDtC,KAAK,CAACE,EAAD,CAA/D;MAEAF,KAAK,CAACE,EAAD,CAAL,qBACKjB,SAAS,CAACI,gBAAgB,CAACkB,GAAjB,CAAqBN,MAAM,CAACE,OAAP,CAAeC,IAAf,CAAoBmC,OAAzC,EAAkD1C,YAAnD,CADd;QAEEK,EAFF;QAGEoC,YAAY,EAAEA,YAHhB;QAIEF,KAJF;QAKExC,IALF;QAMEe,KANF;QAOE0B;MAPF;IASD,CApGO;IAqGRG,uBAAuB,EAAE,CACvBxC,KADuB,EAEvBC,MAFuB,KAGpB;MACH,IAAI,CAACA,MAAM,CAACE,OAAP,CAAeC,IAAf,CAAoBqC,MAAzB,EAAiC;QAC/B;MACD;;MAED,MAAM3B,aAAa,GAAGtB,gBAAgB,CAAsBQ,KAAtB,EAA6BC,MAAM,CAACE,OAAP,CAAeD,EAA5C,CAAtC;MACA,MAAM;QAAEuC;MAAF,IAAaxC,MAAM,CAACE,OAAP,CAAeC,IAAlC;MACA,MAAMsC,OAAO,qBAAQD,MAAR;QAAgBE,IAAI,EAAEpD,kBAAkB,CAACkD,MAAD,aAACA,MAAD,uBAACA,MAAM,CAAEE,IAAT,CAAxC;QAAwDC,KAAK,EAAErD,kBAAkB,CAACkD,MAAD,aAACA,MAAD,uBAACA,MAAM,CAAEG,KAAT;MAAjF,EAAb;MAEA9B,aAAa,CAAC4B,OAAd,GAAwBA,OAAxB;MACA5B,aAAa,CAAC+B,OAAd,GAAwB/B,aAAa,CAAC+B,OAAd,CAAsBC,GAAtB,CAA2BL,MAAD,IAAY;QAC5DA,MAAM,CAACG,KAAP,GAAerD,kBAAkB,CAACkD,MAAM,CAACG,KAAR,CAAjC;QACAH,MAAM,CAACE,IAAP,GAAcpD,kBAAkB,CAACkD,MAAM,CAACE,IAAR,CAAhC;QACA,IAAII,QAAQ,GAAG,KAAf;;QACA,IAAIC,KAAK,CAACC,OAAN,CAAcP,OAAO,CAACE,KAAtB,CAAJ,EAAkC;UAChC,KAAK,IAAIjC,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAG+B,OAAO,CAACE,KAAR,CAAchB,MAA1C,EAAkDjB,KAAK,EAAvD,EAA2D;YACzD,MAAMiC,KAAK,GAAGF,OAAO,CAACE,KAAR,CAAcjC,KAAd,CAAd;;YACA,IAAI8B,MAAM,CAACG,KAAP,KAAiBA,KAArB,EAA4B;cAC1BG,QAAQ,GAAG,IAAX;cACA;YACD;UACF;QACF,CARD,MAQO,IAAIN,MAAM,CAACG,KAAP,KAAiBF,OAAO,CAACE,KAA7B,EAAoC;UACzCG,QAAQ,GAAG,IAAX;QACD;;QACDN,MAAM,CAACM,QAAP,GAAkBA,QAAlB;QACA,OAAON,MAAP;MACD,CAjBuB,CAAxB;IAkBD,CApIO;IAqIRS,kBAAkB,EAAE,CAClBlD,KADkB,EAElBC,MAFkB,KAGf;MACH,MAAMa,aAAa,GAAGtB,gBAAgB,CAACQ,KAAD,EAAQC,MAAM,CAACE,OAAP,CAAeD,EAAvB,CAAtC;MACCY,aAAD,CAAuCb,MAAM,CAACE,OAAP,CAAeC,IAAf,CAAoB+C,QAA3D,IAAuElD,MAAM,CAACE,OAAP,CAAeC,IAAf,CAAoBgD,SAA3F;IACD;EA3IO,CAH2B;EAgJrCC,aAAa,EAAGC,OAAD,IACbA,OAAO,CAACC,OAAR,CAAgBjE,2BAAhB,EAA6C,CAACU,KAAD,EAAQC,MAAR,KAAmB;IAC9D,MAAMa,aAAa,GAAGtB,gBAAgB,CAACQ,KAAD,EAAQC,MAAM,CAACE,OAAP,CAAeD,EAAvB,CAAtC;IACAY,aAAa,CAAClB,IAAd,GAAqBK,MAAM,CAACE,OAAP,CAAeC,IAAf,CAAoBoD,OAAzC;EACD,CAHD;AAjJmC,CAAD,CAAtC;AAuJA,OAAO,MAAMC,aAAa,GAAG9D,kBAAkB,CAAC+D,OAAzC;AAEP,OAAO,MAAM;EACXnC,cADW;EAEXxB,WAFW;EAGXmD,kBAHW;EAIXlB,mBAJW;EAKXH,iBALW;EAMXW,uBANW;EAOXL,kBAPW;EAQXtB,uBARW;EASXI,qBATW;EAUXE,sBAVW;EAWXE;AAXW,IAYT1B,kBAAkB,CAACgE,OAZhB"},"metadata":{},"sourceType":"module"}