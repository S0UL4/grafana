{"ast":null,"code":"//\n// This is using ng-react with this PR applied https://github.com/ngReact/ngReact/pull/199\n//\n// # ngReact\n// ### Use React Components inside of your Angular applications\n//\n// Composed of\n// - reactComponent (generic directive for delegating off to React Components)\n// - reactDirective (factory for creating specific directives that correspond to reactComponent directives)\nimport angular from 'angular';\nimport { kebabCase } from 'lodash';\nimport React from 'react';\nimport ReactDOM from 'react-dom'; // get a react component from name (components can be an angular injectable e.g. value, factory or\n// available on window\n\nfunction getReactComponent(name, $injector) {\n  // if name is a function assume it is component and return it\n  if (angular.isFunction(name)) {\n    return name;\n  } // a React component name must be specified\n\n\n  if (!name) {\n    throw new Error('ReactComponent name attribute must be specified');\n  } // ensure the specified React component is accessible, and fail fast if it's not\n\n\n  let reactComponent;\n\n  try {\n    reactComponent = $injector.get(name);\n  } catch (e) {}\n\n  if (!reactComponent) {\n    try {\n      reactComponent = name.split('.').reduce((current, namePart) => {\n        // @ts-ignore\n        return current[namePart];\n      }, window);\n    } catch (e) {}\n  }\n\n  if (!reactComponent) {\n    throw Error('Cannot find react component ' + name);\n  }\n\n  return reactComponent;\n} // wraps a function with scope.$apply, if already applied just return\n\n\nfunction applied(fn, scope) {\n  if (fn.wrappedInApply) {\n    return fn;\n  } // this had the equivalent of `eslint-disable-next-line prefer-arrow/prefer-arrow-functions`\n\n\n  const wrapped = function () {\n    const args = arguments;\n    const phase = scope.$root.$$phase;\n\n    if (phase === '$apply' || phase === '$digest') {\n      return fn.apply(null, args);\n    } else {\n      return scope.$apply(() => {\n        return fn.apply(null, args);\n      });\n    }\n  };\n\n  wrapped.wrappedInApply = true;\n  return wrapped;\n}\n/**\n * wraps functions on obj in scope.$apply\n *\n * keeps backwards compatibility, as if propsConfig is not passed, it will\n * work as before, wrapping all functions and won't wrap only when specified.\n *\n * @version 0.4.1\n * @param obj react component props\n * @param scope current scope\n * @param propsConfig configuration object for all properties\n * @returns {Object} props with the functions wrapped in scope.$apply\n */\n\n\nfunction applyFunctions(obj, scope, propsConfig) {\n  return Object.keys(obj || {}).reduce((prev, key) => {\n    const value = obj[key];\n    const config = (propsConfig || {})[key] || {};\n    /**\n     * wrap functions in a function that ensures they are scope.$applied\n     * ensures that when function is called from a React component\n     * the Angular digest cycle is run\n     */\n    // @ts-ignore\n\n    prev[key] = angular.isFunction(value) && config.wrapApply !== false ? applied(value, scope) : value;\n    return prev;\n  }, {});\n}\n/**\n *\n * @param watchDepth (value of HTML watch-depth attribute)\n * @param scope (angular scope)\n *\n * Uses the watchDepth attribute to determine how to watch props on scope.\n * If watchDepth attribute is NOT reference or collection, watchDepth defaults to deep watching by value\n */\n\n\nfunction watchProps(watchDepth, scope, watchExpressions, listener) {\n  const supportsWatchCollection = angular.isFunction(scope.$watchCollection);\n  const supportsWatchGroup = angular.isFunction(scope.$watchGroup);\n  const watchGroupExpressions = [];\n\n  for (const expr of watchExpressions) {\n    const actualExpr = getPropExpression(expr);\n    const exprWatchDepth = getPropWatchDepth(watchDepth, expr); // ignore empty expressions & expressions with functions\n\n    if (!actualExpr || actualExpr.match(/\\(.*\\)/) || exprWatchDepth === 'one-time') {\n      continue;\n    }\n\n    if (exprWatchDepth === 'collection' && supportsWatchCollection) {\n      scope.$watchCollection(actualExpr, listener);\n    } else if (exprWatchDepth === 'reference' && supportsWatchGroup) {\n      watchGroupExpressions.push(actualExpr);\n    } else {\n      scope.$watch(actualExpr, listener, exprWatchDepth !== 'reference');\n    }\n  }\n\n  if (watchDepth === 'one-time') {\n    listener();\n  }\n\n  if (watchGroupExpressions.length) {\n    scope.$watchGroup(watchGroupExpressions, listener);\n  }\n} // render React component, with scope[attrs.props] being passed in as the component props\n\n\nfunction renderComponent(component, props, scope, elem) {\n  scope.$evalAsync(() => {\n    ReactDOM.render( /*#__PURE__*/React.createElement(component, props), elem[0]);\n  });\n} // get prop name from prop (string or array)\n\n\nfunction getPropName(prop) {\n  return Array.isArray(prop) ? prop[0] : prop;\n} // get prop name from prop (string or array)\n\n\nfunction getPropConfig(prop) {\n  return Array.isArray(prop) ? prop[1] : {};\n} // get prop expression from prop (string or array)\n\n\nfunction getPropExpression(prop) {\n  return Array.isArray(prop) ? prop[0] : prop;\n}\n/**\n * Finds the normalized attribute knowing that React props accept any type of capitalization and it also handles\n * kabab case attributes which can be used in case the attribute would also be a standard html attribute and would be\n * evaluated by the browser as such.\n * @param attrs All attributes of the component.\n * @param propName Name of the prop that react component expects.\n */\n\n\nfunction findAttribute(attrs, propName) {\n  const index = Object.keys(attrs).find(attr => {\n    return attr.toLowerCase() === propName.toLowerCase() || kebabCase(attr) === kebabCase(propName);\n  }); // @ts-ignore\n\n  return attrs[index];\n} // get watch depth of prop (string or array)\n\n\nfunction getPropWatchDepth(defaultWatch, prop) {\n  const customWatchDepth = Array.isArray(prop) && angular.isObject(prop[1]) && prop[1].watchDepth;\n  return customWatchDepth || defaultWatch;\n} // # reactComponent\n// Directive that allows React components to be used in Angular templates.\n//\n// Usage:\n//     <react-component name=\"Hello\" props=\"name\"/>\n//\n// This requires that there exists an injectable or globally available 'Hello' React component.\n// The 'props' attribute is optional and is passed to the component.\n//\n// The following would would create and register the component:\n//\n//     var module = angular.module('ace.react.components');\n//     module.value('Hello', React.createClass({\n//         render: function() {\n//             return <div>Hello {this.props.name}</div>;\n//         }\n//     }));\n//\n\n\nconst reactComponent = $injector => {\n  return {\n    restrict: 'E',\n    replace: true,\n    link: function (scope, elem, attrs) {\n      const reactComponent = getReactComponent(attrs.name, $injector);\n\n      const renderMyComponent = () => {\n        const scopeProps = scope.$eval(attrs.props);\n        const props = applyFunctions(scopeProps, scope);\n        renderComponent(reactComponent, props, scope, elem);\n      }; // If there are props, re-render when they change\n\n\n      attrs.props ? watchProps(attrs.watchDepth, scope, [attrs.props], renderMyComponent) : renderMyComponent(); // cleanup when scope is destroyed\n\n      scope.$on('$destroy', () => {\n        if (!attrs.onScopeDestroy) {\n          ReactDOM.unmountComponentAtNode(elem[0]);\n        } else {\n          scope.$eval(attrs.onScopeDestroy, {\n            unmountComponent: ReactDOM.unmountComponentAtNode.bind(this, elem[0])\n          });\n        }\n      });\n    }\n  };\n}; // # reactDirective\n// Factory function to create directives for React components.\n//\n// With a component like this:\n//\n//     var module = angular.module('ace.react.components');\n//     module.value('Hello', React.createClass({\n//         render: function() {\n//             return <div>Hello {this.props.name}</div>;\n//         }\n//     }));\n//\n// A directive can be created and registered with:\n//\n//     module.directive('hello', function(reactDirective) {\n//         return reactDirective('Hello', ['name']);\n//     });\n//\n// Where the first argument is the injectable or globally accessible name of the React component\n// and the second argument is an array of property names to be watched and passed to the React component\n// as props.\n//\n// This directive can then be used like this:\n//\n//     <hello name=\"name\"/>\n//\n\n\nconst reactDirective = $injector => {\n  return (reactComponentName, props, conf, injectableProps) => {\n    const directive = {\n      restrict: 'E',\n      replace: true,\n      link: function (scope, elem, attrs) {\n        const reactComponent = getReactComponent(reactComponentName, $injector); // if props is not defined, fall back to use the React component's propTypes if present\n\n        props = props || Object.keys(reactComponent.propTypes || {}); // for each of the properties, get their scope value and set it to scope.props\n\n        const renderMyComponent = () => {\n          let scopeProps = {};\n          const config = {};\n          props.forEach(prop => {\n            const propName = getPropName(prop);\n            scopeProps[propName] = scope.$eval(findAttribute(attrs, propName));\n            config[propName] = getPropConfig(prop);\n          });\n          scopeProps = applyFunctions(scopeProps, scope, config);\n          scopeProps = angular.extend({}, scopeProps, injectableProps);\n          renderComponent(reactComponent, scopeProps, scope, elem);\n        }; // watch each property name and trigger an update whenever something changes,\n        // to update scope.props with new values\n\n\n        const propExpressions = props.map(prop => {\n          return Array.isArray(prop) ? [findAttribute(attrs, prop[0]), getPropConfig(prop)] : findAttribute(attrs, prop);\n        }); // If we don't have any props, then our watch statement won't fire.\n\n        props.length ? watchProps(attrs.watchDepth, scope, propExpressions, renderMyComponent) : renderMyComponent(); // cleanup when scope is destroyed\n\n        scope.$on('$destroy', () => {\n          if (!attrs.onScopeDestroy) {\n            ReactDOM.unmountComponentAtNode(elem[0]);\n          } else {\n            scope.$eval(attrs.onScopeDestroy, {\n              unmountComponent: ReactDOM.unmountComponentAtNode.bind(this, elem[0])\n            });\n          }\n        });\n      }\n    };\n    return angular.extend(directive, conf);\n  };\n};\n\nconst ngModule = angular.module('react', []);\nngModule.directive('reactComponent', ['$injector', reactComponent]);\nngModule.factory('reactDirective', ['$injector', reactDirective]);","map":{"version":3,"names":["angular","kebabCase","React","ReactDOM","getReactComponent","name","$injector","isFunction","Error","reactComponent","get","e","split","reduce","current","namePart","window","applied","fn","scope","wrappedInApply","wrapped","args","arguments","phase","$root","$$phase","apply","$apply","applyFunctions","obj","propsConfig","Object","keys","prev","key","value","config","wrapApply","watchProps","watchDepth","watchExpressions","listener","supportsWatchCollection","$watchCollection","supportsWatchGroup","$watchGroup","watchGroupExpressions","expr","actualExpr","getPropExpression","exprWatchDepth","getPropWatchDepth","match","push","$watch","length","renderComponent","component","props","elem","$evalAsync","render","createElement","getPropName","prop","Array","isArray","getPropConfig","findAttribute","attrs","propName","index","find","attr","toLowerCase","defaultWatch","customWatchDepth","isObject","restrict","replace","link","renderMyComponent","scopeProps","$eval","$on","onScopeDestroy","unmountComponentAtNode","unmountComponent","bind","reactDirective","reactComponentName","conf","injectableProps","directive","propTypes","forEach","extend","propExpressions","map","ngModule","module","factory"],"sources":["/home/soula/grafana/public/app/angular/services/ng_react.ts"],"sourcesContent":["//\n// This is using ng-react with this PR applied https://github.com/ngReact/ngReact/pull/199\n//\n\n// # ngReact\n// ### Use React Components inside of your Angular applications\n//\n// Composed of\n// - reactComponent (generic directive for delegating off to React Components)\n// - reactDirective (factory for creating specific directives that correspond to reactComponent directives)\n\nimport angular, { auto } from 'angular';\nimport { kebabCase } from 'lodash';\nimport React, { ComponentType } from 'react';\nimport ReactDOM from 'react-dom';\n\n// get a react component from name (components can be an angular injectable e.g. value, factory or\n// available on window\nfunction getReactComponent(name: string | Function, $injector: auto.IInjectorService): ComponentType {\n  // if name is a function assume it is component and return it\n  if (angular.isFunction(name)) {\n    return name as unknown as ComponentType;\n  }\n\n  // a React component name must be specified\n  if (!name) {\n    throw new Error('ReactComponent name attribute must be specified');\n  }\n\n  // ensure the specified React component is accessible, and fail fast if it's not\n  let reactComponent;\n  try {\n    reactComponent = $injector.get(name);\n  } catch (e) {}\n\n  if (!reactComponent) {\n    try {\n      reactComponent = name.split('.').reduce((current, namePart) => {\n        // @ts-ignore\n        return current[namePart];\n      }, window);\n    } catch (e) {}\n  }\n\n  if (!reactComponent) {\n    throw Error('Cannot find react component ' + name);\n  }\n\n  return reactComponent as unknown as ComponentType;\n}\n\n// wraps a function with scope.$apply, if already applied just return\nfunction applied(fn: any, scope: any) {\n  if (fn.wrappedInApply) {\n    return fn;\n  }\n  // this had the equivalent of `eslint-disable-next-line prefer-arrow/prefer-arrow-functions`\n  const wrapped: any = function () {\n    const args = arguments;\n    const phase = scope.$root.$$phase;\n    if (phase === '$apply' || phase === '$digest') {\n      return fn.apply(null, args);\n    } else {\n      return scope.$apply(() => {\n        return fn.apply(null, args);\n      });\n    }\n  };\n  wrapped.wrappedInApply = true;\n  return wrapped;\n}\n\n/**\n * wraps functions on obj in scope.$apply\n *\n * keeps backwards compatibility, as if propsConfig is not passed, it will\n * work as before, wrapping all functions and won't wrap only when specified.\n *\n * @version 0.4.1\n * @param obj react component props\n * @param scope current scope\n * @param propsConfig configuration object for all properties\n * @returns {Object} props with the functions wrapped in scope.$apply\n */\nfunction applyFunctions(obj: any, scope: any, propsConfig?: any): object {\n  return Object.keys(obj || {}).reduce((prev, key) => {\n    const value = obj[key];\n    const config = (propsConfig || {})[key] || {};\n    /**\n     * wrap functions in a function that ensures they are scope.$applied\n     * ensures that when function is called from a React component\n     * the Angular digest cycle is run\n     */\n    // @ts-ignore\n    prev[key] = angular.isFunction(value) && config.wrapApply !== false ? applied(value, scope) : value;\n\n    return prev;\n  }, {});\n}\n\n/**\n *\n * @param watchDepth (value of HTML watch-depth attribute)\n * @param scope (angular scope)\n *\n * Uses the watchDepth attribute to determine how to watch props on scope.\n * If watchDepth attribute is NOT reference or collection, watchDepth defaults to deep watching by value\n */\nfunction watchProps(watchDepth: string, scope: any, watchExpressions: any[], listener: any) {\n  const supportsWatchCollection = angular.isFunction(scope.$watchCollection);\n  const supportsWatchGroup = angular.isFunction(scope.$watchGroup);\n\n  const watchGroupExpressions = [];\n\n  for (const expr of watchExpressions) {\n    const actualExpr = getPropExpression(expr);\n    const exprWatchDepth = getPropWatchDepth(watchDepth, expr);\n\n    // ignore empty expressions & expressions with functions\n    if (!actualExpr || actualExpr.match(/\\(.*\\)/) || exprWatchDepth === 'one-time') {\n      continue;\n    }\n\n    if (exprWatchDepth === 'collection' && supportsWatchCollection) {\n      scope.$watchCollection(actualExpr, listener);\n    } else if (exprWatchDepth === 'reference' && supportsWatchGroup) {\n      watchGroupExpressions.push(actualExpr);\n    } else {\n      scope.$watch(actualExpr, listener, exprWatchDepth !== 'reference');\n    }\n  }\n\n  if (watchDepth === 'one-time') {\n    listener();\n  }\n\n  if (watchGroupExpressions.length) {\n    scope.$watchGroup(watchGroupExpressions, listener);\n  }\n}\n\n// render React component, with scope[attrs.props] being passed in as the component props\nfunction renderComponent(component: any, props: object, scope: any, elem: Element[]) {\n  scope.$evalAsync(() => {\n    ReactDOM.render(React.createElement(component, props), elem[0]);\n  });\n}\n\n// get prop name from prop (string or array)\nfunction getPropName(prop: any) {\n  return Array.isArray(prop) ? prop[0] : prop;\n}\n\n// get prop name from prop (string or array)\nfunction getPropConfig(prop: any) {\n  return Array.isArray(prop) ? prop[1] : {};\n}\n\n// get prop expression from prop (string or array)\nfunction getPropExpression(prop: any) {\n  return Array.isArray(prop) ? prop[0] : prop;\n}\n\n/**\n * Finds the normalized attribute knowing that React props accept any type of capitalization and it also handles\n * kabab case attributes which can be used in case the attribute would also be a standard html attribute and would be\n * evaluated by the browser as such.\n * @param attrs All attributes of the component.\n * @param propName Name of the prop that react component expects.\n */\nfunction findAttribute(attrs: object, propName: string): string {\n  const index = Object.keys(attrs).find((attr: any) => {\n    return attr.toLowerCase() === propName.toLowerCase() || kebabCase(attr) === kebabCase(propName);\n  });\n  // @ts-ignore\n  return attrs[index];\n}\n\n// get watch depth of prop (string or array)\nfunction getPropWatchDepth(defaultWatch: string, prop: string | any[]) {\n  const customWatchDepth = Array.isArray(prop) && angular.isObject(prop[1]) && prop[1].watchDepth;\n  return customWatchDepth || defaultWatch;\n}\n\n// # reactComponent\n// Directive that allows React components to be used in Angular templates.\n//\n// Usage:\n//     <react-component name=\"Hello\" props=\"name\"/>\n//\n// This requires that there exists an injectable or globally available 'Hello' React component.\n// The 'props' attribute is optional and is passed to the component.\n//\n// The following would would create and register the component:\n//\n//     var module = angular.module('ace.react.components');\n//     module.value('Hello', React.createClass({\n//         render: function() {\n//             return <div>Hello {this.props.name}</div>;\n//         }\n//     }));\n//\nconst reactComponent = ($injector: any): any => {\n  return {\n    restrict: 'E',\n    replace: true,\n    link: function (scope: any, elem: Element[], attrs: any) {\n      const reactComponent = getReactComponent(attrs.name, $injector);\n\n      const renderMyComponent = () => {\n        const scopeProps = scope.$eval(attrs.props);\n        const props = applyFunctions(scopeProps, scope);\n\n        renderComponent(reactComponent, props, scope, elem);\n      };\n\n      // If there are props, re-render when they change\n      attrs.props ? watchProps(attrs.watchDepth, scope, [attrs.props], renderMyComponent) : renderMyComponent();\n\n      // cleanup when scope is destroyed\n      scope.$on('$destroy', () => {\n        if (!attrs.onScopeDestroy) {\n          ReactDOM.unmountComponentAtNode(elem[0]);\n        } else {\n          scope.$eval(attrs.onScopeDestroy, {\n            unmountComponent: ReactDOM.unmountComponentAtNode.bind(this, elem[0]),\n          });\n        }\n      });\n    },\n  };\n};\n\n// # reactDirective\n// Factory function to create directives for React components.\n//\n// With a component like this:\n//\n//     var module = angular.module('ace.react.components');\n//     module.value('Hello', React.createClass({\n//         render: function() {\n//             return <div>Hello {this.props.name}</div>;\n//         }\n//     }));\n//\n// A directive can be created and registered with:\n//\n//     module.directive('hello', function(reactDirective) {\n//         return reactDirective('Hello', ['name']);\n//     });\n//\n// Where the first argument is the injectable or globally accessible name of the React component\n// and the second argument is an array of property names to be watched and passed to the React component\n// as props.\n//\n// This directive can then be used like this:\n//\n//     <hello name=\"name\"/>\n//\nconst reactDirective = ($injector: auto.IInjectorService) => {\n  return (reactComponentName: string, props: string[], conf: any, injectableProps: any) => {\n    const directive = {\n      restrict: 'E',\n      replace: true,\n      link: function (scope: any, elem: Element[], attrs: any) {\n        const reactComponent = getReactComponent(reactComponentName, $injector);\n\n        // if props is not defined, fall back to use the React component's propTypes if present\n        props = props || Object.keys(reactComponent.propTypes || {});\n\n        // for each of the properties, get their scope value and set it to scope.props\n        const renderMyComponent = () => {\n          let scopeProps: any = {};\n          const config: any = {};\n\n          props.forEach((prop) => {\n            const propName = getPropName(prop);\n            scopeProps[propName] = scope.$eval(findAttribute(attrs, propName));\n            config[propName] = getPropConfig(prop);\n          });\n\n          scopeProps = applyFunctions(scopeProps, scope, config);\n          scopeProps = angular.extend({}, scopeProps, injectableProps);\n          renderComponent(reactComponent, scopeProps, scope, elem);\n        };\n\n        // watch each property name and trigger an update whenever something changes,\n        // to update scope.props with new values\n        const propExpressions = props.map((prop) => {\n          return Array.isArray(prop)\n            ? [findAttribute(attrs, prop[0]), getPropConfig(prop)]\n            : findAttribute(attrs, prop);\n        });\n\n        // If we don't have any props, then our watch statement won't fire.\n        props.length ? watchProps(attrs.watchDepth, scope, propExpressions, renderMyComponent) : renderMyComponent();\n\n        // cleanup when scope is destroyed\n        scope.$on('$destroy', () => {\n          if (!attrs.onScopeDestroy) {\n            ReactDOM.unmountComponentAtNode(elem[0]);\n          } else {\n            scope.$eval(attrs.onScopeDestroy, {\n              unmountComponent: ReactDOM.unmountComponentAtNode.bind(this, elem[0]),\n            });\n          }\n        });\n      },\n    };\n    return angular.extend(directive, conf);\n  };\n};\n\nconst ngModule = angular.module('react', []);\nngModule.directive('reactComponent', ['$injector', reactComponent]);\nngModule.factory('reactDirective', ['$injector', reactDirective]);\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}