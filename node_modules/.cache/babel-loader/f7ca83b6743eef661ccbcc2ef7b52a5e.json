{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport classNames from 'classnames';\nimport React, { PureComponent } from 'react';\nimport { Subscription } from 'rxjs';\nimport { AnnotationChangeEvent, CoreApp, DashboardCursorSync, getDefaultTimeRange, LoadingState, toDataFrameDTO, toUtc } from '@grafana/data';\nimport { selectors } from '@grafana/e2e-selectors';\nimport { config, locationService, RefreshEvent } from '@grafana/runtime';\nimport { ErrorBoundary, PanelContextProvider } from '@grafana/ui';\nimport { PANEL_BORDER } from 'app/core/constants';\nimport { profiler } from 'app/core/profiler';\nimport { applyPanelTimeOverrides } from 'app/features/dashboard/utils/panel';\nimport { changeSeriesColorConfigFactory } from 'app/plugins/panel/timeseries/overrides/colorSeriesConfigFactory';\nimport { RenderEvent } from 'app/types/events';\nimport { contextSrv } from '../../../core/services/context_srv';\nimport { isSoloRoute } from '../../../routes/utils';\nimport { deleteAnnotation, saveAnnotation, updateAnnotation } from '../../annotations/api';\nimport { getDashboardQueryRunner } from '../../query/state/DashboardQueryRunner/DashboardQueryRunner';\nimport { getTimeSrv } from '../services/TimeSrv';\nimport { loadSnapshotData } from '../utils/loadSnapshotData';\nimport { PanelHeader } from './PanelHeader/PanelHeader';\nimport { seriesVisibilityConfigFactory } from './SeriesVisibilityConfigFactory';\nimport { liveTimer } from './liveTimer';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\nconst DEFAULT_PLUGIN_ERROR = 'Error in plugin';\nexport class PanelChrome extends PureComponent {\n  constructor(props) {\n    super(props); // Can this eventBus be on PanelModel?  when we have more complex event filtering, that may be a better option\n\n    _defineProperty(this, \"timeSrv\", getTimeSrv());\n\n    _defineProperty(this, \"subs\", new Subscription());\n\n    _defineProperty(this, \"eventFilter\", {\n      onlyLocal: true\n    });\n\n    _defineProperty(this, \"canEditDashboard\", () => Boolean(this.props.dashboard.meta.canEdit || this.props.dashboard.meta.canMakeEditable));\n\n    _defineProperty(this, \"canAddAnnotation\", () => {\n      let canAdd = true;\n\n      if (contextSrv.accessControlEnabled()) {\n        var _this$props$dashboard;\n\n        canAdd = !!((_this$props$dashboard = this.props.dashboard.meta.annotationsPermissions) !== null && _this$props$dashboard !== void 0 && _this$props$dashboard.dashboard.canAdd);\n      }\n\n      return canAdd && this.canEditDashboard();\n    });\n\n    _defineProperty(this, \"canEditAnnotation\", dashboardId => {\n      let canEdit = true;\n\n      if (contextSrv.accessControlEnabled()) {\n        if (dashboardId !== 0) {\n          var _this$props$dashboard2;\n\n          canEdit = !!((_this$props$dashboard2 = this.props.dashboard.meta.annotationsPermissions) !== null && _this$props$dashboard2 !== void 0 && _this$props$dashboard2.dashboard.canEdit);\n        } else {\n          var _this$props$dashboard3;\n\n          canEdit = !!((_this$props$dashboard3 = this.props.dashboard.meta.annotationsPermissions) !== null && _this$props$dashboard3 !== void 0 && _this$props$dashboard3.organization.canEdit);\n        }\n      }\n\n      return canEdit && this.canEditDashboard();\n    });\n\n    _defineProperty(this, \"canDeleteAnnotation\", dashboardId => {\n      let canDelete = true;\n\n      if (contextSrv.accessControlEnabled()) {\n        if (dashboardId !== 0) {\n          var _this$props$dashboard4;\n\n          canDelete = !!((_this$props$dashboard4 = this.props.dashboard.meta.annotationsPermissions) !== null && _this$props$dashboard4 !== void 0 && _this$props$dashboard4.dashboard.canDelete);\n        } else {\n          var _this$props$dashboard5;\n\n          canDelete = !!((_this$props$dashboard5 = this.props.dashboard.meta.annotationsPermissions) !== null && _this$props$dashboard5 !== void 0 && _this$props$dashboard5.organization.canDelete);\n        }\n      }\n\n      return canDelete && this.canEditDashboard();\n    });\n\n    _defineProperty(this, \"getSync\", () => this.props.isEditing ? DashboardCursorSync.Off : this.props.dashboard.graphTooltip);\n\n    _defineProperty(this, \"onInstanceStateChange\", value => {\n      this.props.onInstanceStateChange(value);\n      this.setState({\n        context: Object.assign({}, this.state.context, {\n          instanceState: value\n        })\n      });\n    });\n\n    _defineProperty(this, \"onSeriesColorChange\", (label, color) => {\n      this.onFieldConfigChange(changeSeriesColorConfigFactory(label, color, this.props.panel.fieldConfig));\n    });\n\n    _defineProperty(this, \"onSeriesVisibilityChange\", (label, mode) => {\n      this.onFieldConfigChange(seriesVisibilityConfigFactory(label, mode, this.props.panel.fieldConfig, this.state.data.series));\n    });\n\n    _defineProperty(this, \"onToggleLegendSort\", sortKey => {\n      const legendOptions = this.props.panel.options.legend; // We don't want to do anything when legend options are not available\n\n      if (!legendOptions) {\n        return;\n      }\n\n      let sortDesc = legendOptions.sortDesc;\n      let sortBy = legendOptions.sortBy;\n\n      if (sortKey !== sortBy) {\n        sortDesc = undefined;\n      } // if already sort ascending, disable sorting\n\n\n      if (sortDesc === false) {\n        sortBy = undefined;\n        sortDesc = undefined;\n      } else {\n        sortDesc = !sortDesc;\n        sortBy = sortKey;\n      }\n\n      this.onOptionsChange(Object.assign({}, this.props.panel.options, {\n        legend: Object.assign({}, legendOptions, {\n          sortBy,\n          sortDesc\n        })\n      }));\n    });\n\n    _defineProperty(this, \"onRefresh\", () => {\n      const {\n        dashboard,\n        panel,\n        isInView,\n        width\n      } = this.props;\n\n      if (!isInView) {\n        this.setState({\n          refreshWhenInView: true\n        });\n        return;\n      }\n\n      const timeData = applyPanelTimeOverrides(panel, this.timeSrv.timeRange()); // Issue Query\n\n      if (this.wantsQueryExecution) {\n        if (width < 0) {\n          return;\n        }\n\n        if (this.state.refreshWhenInView) {\n          this.setState({\n            refreshWhenInView: false\n          });\n        }\n\n        panel.runAllPanelQueries(dashboard.id, dashboard.getTimezone(), timeData, width, dashboard.meta.publicDashboardAccessToken);\n      } else {\n        // The panel should render on refresh as well if it doesn't have a query, like clock panel\n        this.setState({\n          data: Object.assign({}, this.state.data, {\n            timeRange: this.timeSrv.timeRange()\n          }),\n          renderCounter: this.state.renderCounter + 1,\n          liveTime: undefined\n        });\n      }\n    });\n\n    _defineProperty(this, \"onRender\", () => {\n      const stateUpdate = {\n        renderCounter: this.state.renderCounter + 1\n      };\n      this.setState(stateUpdate);\n    });\n\n    _defineProperty(this, \"onOptionsChange\", options => {\n      this.props.panel.updateOptions(options);\n    });\n\n    _defineProperty(this, \"onFieldConfigChange\", config => {\n      this.props.panel.updateFieldConfig(config);\n    });\n\n    _defineProperty(this, \"onPanelError\", error => {\n      const errorMessage = error.message || DEFAULT_PLUGIN_ERROR;\n\n      if (this.state.errorMessage !== errorMessage) {\n        this.setState({\n          errorMessage\n        });\n      }\n    });\n\n    _defineProperty(this, \"onPanelErrorRecover\", () => {\n      this.setState({\n        errorMessage: undefined\n      });\n    });\n\n    _defineProperty(this, \"onAnnotationCreate\", async event => {\n      const isRegion = event.from !== event.to;\n      const anno = {\n        dashboardId: this.props.dashboard.id,\n        panelId: this.props.panel.id,\n        isRegion,\n        time: event.from,\n        timeEnd: isRegion ? event.to : 0,\n        tags: event.tags,\n        text: event.description\n      };\n      await saveAnnotation(anno);\n      getDashboardQueryRunner().run({\n        dashboard: this.props.dashboard,\n        range: this.timeSrv.timeRange()\n      });\n      this.state.context.eventBus.publish(new AnnotationChangeEvent(anno));\n    });\n\n    _defineProperty(this, \"onAnnotationDelete\", async id => {\n      await deleteAnnotation({\n        id\n      });\n      getDashboardQueryRunner().run({\n        dashboard: this.props.dashboard,\n        range: this.timeSrv.timeRange()\n      });\n      this.state.context.eventBus.publish(new AnnotationChangeEvent({\n        id\n      }));\n    });\n\n    _defineProperty(this, \"onAnnotationUpdate\", async event => {\n      const isRegion = event.from !== event.to;\n      const anno = {\n        id: event.id,\n        dashboardId: this.props.dashboard.id,\n        panelId: this.props.panel.id,\n        isRegion,\n        time: event.from,\n        timeEnd: isRegion ? event.to : 0,\n        tags: event.tags,\n        text: event.description\n      };\n      await updateAnnotation(anno);\n      getDashboardQueryRunner().run({\n        dashboard: this.props.dashboard,\n        range: this.timeSrv.timeRange()\n      });\n      this.state.context.eventBus.publish(new AnnotationChangeEvent(anno));\n    });\n\n    _defineProperty(this, \"onChangeTimeRange\", timeRange => {\n      this.timeSrv.setTime({\n        from: toUtc(timeRange.from),\n        to: toUtc(timeRange.to)\n      });\n    });\n\n    const eventBus = props.dashboard.events.newScopedBus(`panel:${props.panel.id}`, this.eventFilter);\n    this.state = {\n      isFirstLoad: true,\n      renderCounter: 0,\n      refreshWhenInView: false,\n      context: {\n        eventBus,\n        app: this.getPanelContextApp(),\n        sync: this.getSync,\n        onSeriesColorChange: this.onSeriesColorChange,\n        onToggleSeriesVisibility: this.onSeriesVisibilityChange,\n        onAnnotationCreate: this.onAnnotationCreate,\n        onAnnotationUpdate: this.onAnnotationUpdate,\n        onAnnotationDelete: this.onAnnotationDelete,\n        canAddAnnotations: this.canAddAnnotation,\n        onInstanceStateChange: this.onInstanceStateChange,\n        onToggleLegendSort: this.onToggleLegendSort,\n        canEditAnnotations: this.canEditAnnotation,\n        canDeleteAnnotations: this.canDeleteAnnotation\n      },\n      data: this.getInitialPanelDataState()\n    };\n  }\n\n  getPanelContextApp() {\n    if (this.props.isEditing) {\n      return CoreApp.PanelEditor;\n    }\n\n    if (this.props.isViewing) {\n      return CoreApp.PanelViewer;\n    }\n\n    return CoreApp.Dashboard;\n  }\n\n  getInitialPanelDataState() {\n    return {\n      state: LoadingState.NotStarted,\n      series: [],\n      timeRange: getDefaultTimeRange()\n    };\n  }\n\n  componentDidMount() {\n    const {\n      panel,\n      dashboard\n    } = this.props; // Subscribe to panel events\n\n    this.subs.add(panel.events.subscribe(RefreshEvent, this.onRefresh));\n    this.subs.add(panel.events.subscribe(RenderEvent, this.onRender));\n    dashboard.panelInitialized(this.props.panel); // Move snapshot data into the query response\n\n    if (this.hasPanelSnapshot) {\n      this.setState({\n        data: loadSnapshotData(panel, dashboard),\n        isFirstLoad: false\n      });\n      return;\n    }\n\n    if (!this.wantsQueryExecution) {\n      this.setState({\n        isFirstLoad: false\n      });\n    }\n\n    this.subs.add(panel.getQueryRunner().getData({\n      withTransforms: true,\n      withFieldConfig: true\n    }).subscribe({\n      next: data => this.onDataUpdate(data)\n    })); // Listen for live timer events\n\n    liveTimer.listen(this);\n  }\n\n  componentWillUnmount() {\n    this.subs.unsubscribe();\n    liveTimer.remove(this);\n  }\n\n  liveTimeChanged(liveTime) {\n    const {\n      data\n    } = this.state;\n\n    if (data.timeRange) {\n      const delta = liveTime.to.valueOf() - data.timeRange.to.valueOf();\n\n      if (delta < 100) {\n        // 10hz\n        console.log('Skip tick render', this.props.panel.title, delta);\n        return;\n      }\n    }\n\n    this.setState({\n      liveTime\n    });\n  }\n\n  componentDidUpdate(prevProps) {\n    const {\n      isInView,\n      width\n    } = this.props;\n    const {\n      context\n    } = this.state;\n    const app = this.getPanelContextApp();\n\n    if (context.app !== app) {\n      this.setState({\n        context: Object.assign({}, context, {\n          app\n        })\n      });\n    } // View state has changed\n\n\n    if (isInView !== prevProps.isInView) {\n      if (isInView) {\n        // Check if we need a delayed refresh\n        if (this.state.refreshWhenInView) {\n          this.onRefresh();\n        }\n      }\n    } // The timer depends on panel width\n\n\n    if (width !== prevProps.width) {\n      liveTimer.updateInterval(this);\n    }\n  } // Updates the response with information from the stream\n  // The next is outside a react synthetic event so setState is not batched\n  // So in this context we can only do a single call to setState\n\n\n  onDataUpdate(data) {\n    const {\n      dashboard,\n      panel,\n      plugin\n    } = this.props; // Ignore this data update if we are now a non data panel\n\n    if (plugin.meta.skipDataQuery) {\n      this.setState({\n        data: this.getInitialPanelDataState()\n      });\n      return;\n    }\n\n    let {\n      isFirstLoad\n    } = this.state;\n    let errorMessage;\n\n    switch (data.state) {\n      case LoadingState.Loading:\n        // Skip updating state data if it is already in loading state\n        // This is to avoid rendering partial loading responses\n        if (this.state.data.state === LoadingState.Loading) {\n          return;\n        }\n\n        break;\n\n      case LoadingState.Error:\n        const {\n          error\n        } = data;\n\n        if (error) {\n          if (errorMessage !== error.message) {\n            errorMessage = error.message;\n          }\n        }\n\n        break;\n\n      case LoadingState.Done:\n        // If we are doing a snapshot save data in panel model\n        if (dashboard.snapshot) {\n          panel.snapshotData = data.series.map(frame => toDataFrameDTO(frame));\n        }\n\n        if (isFirstLoad) {\n          isFirstLoad = false;\n        }\n\n        break;\n    }\n\n    this.setState({\n      isFirstLoad,\n      errorMessage,\n      data,\n      liveTime: undefined\n    });\n  }\n\n  get hasPanelSnapshot() {\n    const {\n      panel\n    } = this.props;\n    return panel.snapshotData && panel.snapshotData.length;\n  }\n\n  get wantsQueryExecution() {\n    return !(this.props.plugin.meta.skipDataQuery || this.hasPanelSnapshot);\n  }\n\n  shouldSignalRenderingCompleted(loadingState, pluginMeta) {\n    return loadingState === LoadingState.Done || pluginMeta.skipDataQuery;\n  }\n\n  skipFirstRender(loadingState) {\n    const {\n      isFirstLoad\n    } = this.state;\n    return this.wantsQueryExecution && isFirstLoad && (loadingState === LoadingState.Loading || loadingState === LoadingState.NotStarted);\n  }\n\n  renderPanel(width, height) {\n    var _ref, _this$state$liveTime;\n\n    const {\n      panel,\n      plugin,\n      dashboard\n    } = this.props;\n    const {\n      renderCounter,\n      data\n    } = this.state;\n    const {\n      theme\n    } = config;\n    const {\n      state: loadingState\n    } = data; // do not render component until we have first data\n\n    if (this.skipFirstRender(loadingState)) {\n      return null;\n    } // This is only done to increase a counter that is used by backend\n    // image rendering to know when to capture image\n\n\n    if (this.shouldSignalRenderingCompleted(loadingState, plugin.meta)) {\n      profiler.renderingCompleted();\n    }\n\n    const PanelComponent = plugin.panel;\n    const timeRange = (_ref = (_this$state$liveTime = this.state.liveTime) !== null && _this$state$liveTime !== void 0 ? _this$state$liveTime : data.timeRange) !== null && _ref !== void 0 ? _ref : this.timeSrv.timeRange();\n    const headerHeight = this.hasOverlayHeader() ? 0 : theme.panelHeaderHeight;\n    const chromePadding = plugin.noPadding ? 0 : theme.panelPadding;\n    const panelWidth = width - chromePadding * 2 - PANEL_BORDER;\n    const innerPanelHeight = height - headerHeight - chromePadding * 2 - PANEL_BORDER;\n    const panelContentClassNames = classNames({\n      'panel-content': true,\n      'panel-content--no-padding': plugin.noPadding\n    });\n    const panelOptions = panel.getOptions(); // Update the event filter (dashboard settings may have changed)\n    // Yes this is called ever render for a function that is triggered on every mouse move\n\n    this.eventFilter.onlyLocal = dashboard.graphTooltip === 0;\n    return /*#__PURE__*/_jsx(_Fragment, {\n      children: /*#__PURE__*/_jsx(\"div\", {\n        className: panelContentClassNames,\n        children: /*#__PURE__*/_jsx(PanelContextProvider, {\n          value: this.state.context,\n          children: /*#__PURE__*/_jsx(PanelComponent, {\n            id: panel.id,\n            data: data,\n            title: panel.title,\n            timeRange: timeRange,\n            timeZone: this.props.dashboard.getTimezone(),\n            options: panelOptions,\n            fieldConfig: panel.fieldConfig,\n            transparent: panel.transparent,\n            width: panelWidth,\n            height: innerPanelHeight,\n            renderCounter: renderCounter,\n            replaceVariables: panel.replaceVariables,\n            onOptionsChange: this.onOptionsChange,\n            onFieldConfigChange: this.onFieldConfigChange,\n            onChangeTimeRange: this.onChangeTimeRange,\n            eventBus: dashboard.events\n          })\n        })\n      })\n    });\n  }\n\n  hasOverlayHeader() {\n    const {\n      panel\n    } = this.props;\n    const {\n      data\n    } = this.state; // always show normal header if we have time override\n\n    if (data.request && data.request.timeInfo) {\n      return false;\n    }\n\n    return !panel.hasTitle();\n  }\n\n  render() {\n    var _data$alertState;\n\n    const {\n      dashboard,\n      panel,\n      isViewing,\n      isEditing,\n      width,\n      height,\n      plugin\n    } = this.props;\n    const {\n      errorMessage,\n      data\n    } = this.state;\n    const {\n      transparent\n    } = panel;\n    const alertState = (_data$alertState = data.alertState) === null || _data$alertState === void 0 ? void 0 : _data$alertState.state;\n    const containerClassNames = classNames({\n      'panel-container': true,\n      'panel-container--absolute': isSoloRoute(locationService.getLocation().pathname),\n      'panel-container--transparent': transparent,\n      'panel-container--no-title': this.hasOverlayHeader(),\n      [`panel-alert-state--${alertState}`]: alertState !== undefined\n    });\n    return /*#__PURE__*/_jsxs(\"section\", {\n      className: containerClassNames,\n      \"aria-label\": selectors.components.Panels.Panel.containerByTitle(panel.title),\n      children: [/*#__PURE__*/_jsx(PanelHeader, {\n        panel: panel,\n        dashboard: dashboard,\n        title: panel.title,\n        description: panel.description,\n        links: panel.links,\n        error: errorMessage,\n        isEditing: isEditing,\n        isViewing: isViewing,\n        alertState: alertState,\n        data: data\n      }), /*#__PURE__*/_jsx(ErrorBoundary, {\n        dependencies: [data, plugin, panel.getOptions()],\n        onError: this.onPanelError,\n        onRecover: this.onPanelErrorRecover,\n        children: ({\n          error\n        }) => {\n          if (error) {\n            return null;\n          }\n\n          return this.renderPanel(width, height);\n        }\n      })]\n    });\n  }\n\n}","map":{"version":3,"names":["classNames","React","PureComponent","Subscription","AnnotationChangeEvent","CoreApp","DashboardCursorSync","getDefaultTimeRange","LoadingState","toDataFrameDTO","toUtc","selectors","config","locationService","RefreshEvent","ErrorBoundary","PanelContextProvider","PANEL_BORDER","profiler","applyPanelTimeOverrides","changeSeriesColorConfigFactory","RenderEvent","contextSrv","isSoloRoute","deleteAnnotation","saveAnnotation","updateAnnotation","getDashboardQueryRunner","getTimeSrv","loadSnapshotData","PanelHeader","seriesVisibilityConfigFactory","liveTimer","DEFAULT_PLUGIN_ERROR","PanelChrome","constructor","props","onlyLocal","Boolean","dashboard","meta","canEdit","canMakeEditable","canAdd","accessControlEnabled","annotationsPermissions","canEditDashboard","dashboardId","organization","canDelete","isEditing","Off","graphTooltip","value","onInstanceStateChange","setState","context","state","instanceState","label","color","onFieldConfigChange","panel","fieldConfig","mode","data","series","sortKey","legendOptions","options","legend","sortDesc","sortBy","undefined","onOptionsChange","isInView","width","refreshWhenInView","timeData","timeSrv","timeRange","wantsQueryExecution","runAllPanelQueries","id","getTimezone","publicDashboardAccessToken","renderCounter","liveTime","stateUpdate","updateOptions","updateFieldConfig","error","errorMessage","message","event","isRegion","from","to","anno","panelId","time","timeEnd","tags","text","description","run","range","eventBus","publish","setTime","events","newScopedBus","eventFilter","isFirstLoad","app","getPanelContextApp","sync","getSync","onSeriesColorChange","onToggleSeriesVisibility","onSeriesVisibilityChange","onAnnotationCreate","onAnnotationUpdate","onAnnotationDelete","canAddAnnotations","canAddAnnotation","onToggleLegendSort","canEditAnnotations","canEditAnnotation","canDeleteAnnotations","canDeleteAnnotation","getInitialPanelDataState","PanelEditor","isViewing","PanelViewer","Dashboard","NotStarted","componentDidMount","subs","add","subscribe","onRefresh","onRender","panelInitialized","hasPanelSnapshot","getQueryRunner","getData","withTransforms","withFieldConfig","next","onDataUpdate","listen","componentWillUnmount","unsubscribe","remove","liveTimeChanged","delta","valueOf","console","log","title","componentDidUpdate","prevProps","updateInterval","plugin","skipDataQuery","Loading","Error","Done","snapshot","snapshotData","map","frame","length","shouldSignalRenderingCompleted","loadingState","pluginMeta","skipFirstRender","renderPanel","height","theme","renderingCompleted","PanelComponent","headerHeight","hasOverlayHeader","panelHeaderHeight","chromePadding","noPadding","panelPadding","panelWidth","innerPanelHeight","panelContentClassNames","panelOptions","getOptions","transparent","replaceVariables","onChangeTimeRange","request","timeInfo","hasTitle","render","alertState","containerClassNames","getLocation","pathname","components","Panels","Panel","containerByTitle","links","onPanelError","onPanelErrorRecover"],"sources":["/home/soula/grafana/public/app/features/dashboard/dashgrid/PanelChrome.tsx"],"sourcesContent":["import classNames from 'classnames';\nimport React, { PureComponent } from 'react';\nimport { Subscription } from 'rxjs';\n\nimport {\n  AbsoluteTimeRange,\n  AnnotationChangeEvent,\n  AnnotationEventUIModel,\n  CoreApp,\n  DashboardCursorSync,\n  EventFilterOptions,\n  FieldConfigSource,\n  getDefaultTimeRange,\n  LoadingState,\n  PanelData,\n  PanelPlugin,\n  PanelPluginMeta,\n  TimeRange,\n  toDataFrameDTO,\n  toUtc,\n} from '@grafana/data';\nimport { selectors } from '@grafana/e2e-selectors';\nimport { config, locationService, RefreshEvent } from '@grafana/runtime';\nimport { VizLegendOptions } from '@grafana/schema';\nimport { ErrorBoundary, PanelContext, PanelContextProvider, SeriesVisibilityChangeMode } from '@grafana/ui';\nimport { PANEL_BORDER } from 'app/core/constants';\nimport { profiler } from 'app/core/profiler';\nimport { applyPanelTimeOverrides } from 'app/features/dashboard/utils/panel';\nimport { changeSeriesColorConfigFactory } from 'app/plugins/panel/timeseries/overrides/colorSeriesConfigFactory';\nimport { RenderEvent } from 'app/types/events';\n\nimport { contextSrv } from '../../../core/services/context_srv';\nimport { isSoloRoute } from '../../../routes/utils';\nimport { deleteAnnotation, saveAnnotation, updateAnnotation } from '../../annotations/api';\nimport { getDashboardQueryRunner } from '../../query/state/DashboardQueryRunner/DashboardQueryRunner';\nimport { getTimeSrv, TimeSrv } from '../services/TimeSrv';\nimport { DashboardModel, PanelModel } from '../state';\nimport { loadSnapshotData } from '../utils/loadSnapshotData';\n\nimport { PanelHeader } from './PanelHeader/PanelHeader';\nimport { seriesVisibilityConfigFactory } from './SeriesVisibilityConfigFactory';\nimport { liveTimer } from './liveTimer';\n\nconst DEFAULT_PLUGIN_ERROR = 'Error in plugin';\n\nexport interface Props {\n  panel: PanelModel;\n  dashboard: DashboardModel;\n  plugin: PanelPlugin;\n  isViewing: boolean;\n  isEditing: boolean;\n  isInView: boolean;\n  width: number;\n  height: number;\n  onInstanceStateChange: (value: any) => void;\n}\n\nexport interface State {\n  isFirstLoad: boolean;\n  renderCounter: number;\n  errorMessage?: string;\n  refreshWhenInView: boolean;\n  context: PanelContext;\n  data: PanelData;\n  liveTime?: TimeRange;\n}\n\nexport class PanelChrome extends PureComponent<Props, State> {\n  private readonly timeSrv: TimeSrv = getTimeSrv();\n  private subs = new Subscription();\n  private eventFilter: EventFilterOptions = { onlyLocal: true };\n\n  constructor(props: Props) {\n    super(props);\n\n    // Can this eventBus be on PanelModel?  when we have more complex event filtering, that may be a better option\n    const eventBus = props.dashboard.events.newScopedBus(`panel:${props.panel.id}`, this.eventFilter);\n\n    this.state = {\n      isFirstLoad: true,\n      renderCounter: 0,\n      refreshWhenInView: false,\n      context: {\n        eventBus,\n        app: this.getPanelContextApp(),\n        sync: this.getSync,\n        onSeriesColorChange: this.onSeriesColorChange,\n        onToggleSeriesVisibility: this.onSeriesVisibilityChange,\n        onAnnotationCreate: this.onAnnotationCreate,\n        onAnnotationUpdate: this.onAnnotationUpdate,\n        onAnnotationDelete: this.onAnnotationDelete,\n        canAddAnnotations: this.canAddAnnotation,\n        onInstanceStateChange: this.onInstanceStateChange,\n        onToggleLegendSort: this.onToggleLegendSort,\n        canEditAnnotations: this.canEditAnnotation,\n        canDeleteAnnotations: this.canDeleteAnnotation,\n      },\n      data: this.getInitialPanelDataState(),\n    };\n  }\n\n  canEditDashboard = () => Boolean(this.props.dashboard.meta.canEdit || this.props.dashboard.meta.canMakeEditable);\n\n  canAddAnnotation = () => {\n    let canAdd = true;\n\n    if (contextSrv.accessControlEnabled()) {\n      canAdd = !!this.props.dashboard.meta.annotationsPermissions?.dashboard.canAdd;\n    }\n    return canAdd && this.canEditDashboard();\n  };\n\n  canEditAnnotation = (dashboardId: number) => {\n    let canEdit = true;\n\n    if (contextSrv.accessControlEnabled()) {\n      if (dashboardId !== 0) {\n        canEdit = !!this.props.dashboard.meta.annotationsPermissions?.dashboard.canEdit;\n      } else {\n        canEdit = !!this.props.dashboard.meta.annotationsPermissions?.organization.canEdit;\n      }\n    }\n    return canEdit && this.canEditDashboard();\n  };\n\n  canDeleteAnnotation = (dashboardId: number) => {\n    let canDelete = true;\n\n    if (contextSrv.accessControlEnabled()) {\n      if (dashboardId !== 0) {\n        canDelete = !!this.props.dashboard.meta.annotationsPermissions?.dashboard.canDelete;\n      } else {\n        canDelete = !!this.props.dashboard.meta.annotationsPermissions?.organization.canDelete;\n      }\n    }\n    return canDelete && this.canEditDashboard();\n  };\n\n  // Due to a mutable panel model we get the sync settings via function that proactively reads from the model\n  getSync = () => (this.props.isEditing ? DashboardCursorSync.Off : this.props.dashboard.graphTooltip);\n\n  onInstanceStateChange = (value: any) => {\n    this.props.onInstanceStateChange(value);\n\n    this.setState({\n      context: {\n        ...this.state.context,\n        instanceState: value,\n      },\n    });\n  };\n\n  getPanelContextApp() {\n    if (this.props.isEditing) {\n      return CoreApp.PanelEditor;\n    }\n    if (this.props.isViewing) {\n      return CoreApp.PanelViewer;\n    }\n\n    return CoreApp.Dashboard;\n  }\n\n  onSeriesColorChange = (label: string, color: string) => {\n    this.onFieldConfigChange(changeSeriesColorConfigFactory(label, color, this.props.panel.fieldConfig));\n  };\n\n  onSeriesVisibilityChange = (label: string, mode: SeriesVisibilityChangeMode) => {\n    this.onFieldConfigChange(\n      seriesVisibilityConfigFactory(label, mode, this.props.panel.fieldConfig, this.state.data.series)\n    );\n  };\n\n  onToggleLegendSort = (sortKey: string) => {\n    const legendOptions: VizLegendOptions = this.props.panel.options.legend;\n\n    // We don't want to do anything when legend options are not available\n    if (!legendOptions) {\n      return;\n    }\n\n    let sortDesc = legendOptions.sortDesc;\n    let sortBy = legendOptions.sortBy;\n    if (sortKey !== sortBy) {\n      sortDesc = undefined;\n    }\n\n    // if already sort ascending, disable sorting\n    if (sortDesc === false) {\n      sortBy = undefined;\n      sortDesc = undefined;\n    } else {\n      sortDesc = !sortDesc;\n      sortBy = sortKey;\n    }\n\n    this.onOptionsChange({\n      ...this.props.panel.options,\n      legend: { ...legendOptions, sortBy, sortDesc },\n    });\n  };\n\n  getInitialPanelDataState(): PanelData {\n    return {\n      state: LoadingState.NotStarted,\n      series: [],\n      timeRange: getDefaultTimeRange(),\n    };\n  }\n\n  componentDidMount() {\n    const { panel, dashboard } = this.props;\n\n    // Subscribe to panel events\n    this.subs.add(panel.events.subscribe(RefreshEvent, this.onRefresh));\n    this.subs.add(panel.events.subscribe(RenderEvent, this.onRender));\n\n    dashboard.panelInitialized(this.props.panel);\n\n    // Move snapshot data into the query response\n    if (this.hasPanelSnapshot) {\n      this.setState({\n        data: loadSnapshotData(panel, dashboard),\n        isFirstLoad: false,\n      });\n      return;\n    }\n\n    if (!this.wantsQueryExecution) {\n      this.setState({ isFirstLoad: false });\n    }\n\n    this.subs.add(\n      panel\n        .getQueryRunner()\n        .getData({ withTransforms: true, withFieldConfig: true })\n        .subscribe({\n          next: (data) => this.onDataUpdate(data),\n        })\n    );\n\n    // Listen for live timer events\n    liveTimer.listen(this);\n  }\n\n  componentWillUnmount() {\n    this.subs.unsubscribe();\n    liveTimer.remove(this);\n  }\n\n  liveTimeChanged(liveTime: TimeRange) {\n    const { data } = this.state;\n    if (data.timeRange) {\n      const delta = liveTime.to.valueOf() - data.timeRange.to.valueOf();\n      if (delta < 100) {\n        // 10hz\n        console.log('Skip tick render', this.props.panel.title, delta);\n        return;\n      }\n    }\n    this.setState({ liveTime });\n  }\n\n  componentDidUpdate(prevProps: Props) {\n    const { isInView, width } = this.props;\n    const { context } = this.state;\n\n    const app = this.getPanelContextApp();\n\n    if (context.app !== app) {\n      this.setState({\n        context: {\n          ...context,\n          app,\n        },\n      });\n    }\n\n    // View state has changed\n    if (isInView !== prevProps.isInView) {\n      if (isInView) {\n        // Check if we need a delayed refresh\n        if (this.state.refreshWhenInView) {\n          this.onRefresh();\n        }\n      }\n    }\n\n    // The timer depends on panel width\n    if (width !== prevProps.width) {\n      liveTimer.updateInterval(this);\n    }\n  }\n\n  // Updates the response with information from the stream\n  // The next is outside a react synthetic event so setState is not batched\n  // So in this context we can only do a single call to setState\n  onDataUpdate(data: PanelData) {\n    const { dashboard, panel, plugin } = this.props;\n\n    // Ignore this data update if we are now a non data panel\n    if (plugin.meta.skipDataQuery) {\n      this.setState({ data: this.getInitialPanelDataState() });\n      return;\n    }\n\n    let { isFirstLoad } = this.state;\n    let errorMessage: string | undefined;\n\n    switch (data.state) {\n      case LoadingState.Loading:\n        // Skip updating state data if it is already in loading state\n        // This is to avoid rendering partial loading responses\n        if (this.state.data.state === LoadingState.Loading) {\n          return;\n        }\n        break;\n      case LoadingState.Error:\n        const { error } = data;\n        if (error) {\n          if (errorMessage !== error.message) {\n            errorMessage = error.message;\n          }\n        }\n        break;\n      case LoadingState.Done:\n        // If we are doing a snapshot save data in panel model\n        if (dashboard.snapshot) {\n          panel.snapshotData = data.series.map((frame) => toDataFrameDTO(frame));\n        }\n        if (isFirstLoad) {\n          isFirstLoad = false;\n        }\n        break;\n    }\n\n    this.setState({ isFirstLoad, errorMessage, data, liveTime: undefined });\n  }\n\n  onRefresh = () => {\n    const { dashboard, panel, isInView, width } = this.props;\n\n    if (!isInView) {\n      this.setState({ refreshWhenInView: true });\n      return;\n    }\n\n    const timeData = applyPanelTimeOverrides(panel, this.timeSrv.timeRange());\n\n    // Issue Query\n    if (this.wantsQueryExecution) {\n      if (width < 0) {\n        return;\n      }\n\n      if (this.state.refreshWhenInView) {\n        this.setState({ refreshWhenInView: false });\n      }\n      panel.runAllPanelQueries(\n        dashboard.id,\n        dashboard.getTimezone(),\n        timeData,\n        width,\n        dashboard.meta.publicDashboardAccessToken\n      );\n    } else {\n      // The panel should render on refresh as well if it doesn't have a query, like clock panel\n      this.setState({\n        data: { ...this.state.data, timeRange: this.timeSrv.timeRange() },\n        renderCounter: this.state.renderCounter + 1,\n        liveTime: undefined,\n      });\n    }\n  };\n\n  onRender = () => {\n    const stateUpdate = { renderCounter: this.state.renderCounter + 1 };\n    this.setState(stateUpdate);\n  };\n\n  onOptionsChange = (options: any) => {\n    this.props.panel.updateOptions(options);\n  };\n\n  onFieldConfigChange = (config: FieldConfigSource) => {\n    this.props.panel.updateFieldConfig(config);\n  };\n\n  onPanelError = (error: Error) => {\n    const errorMessage = error.message || DEFAULT_PLUGIN_ERROR;\n    if (this.state.errorMessage !== errorMessage) {\n      this.setState({ errorMessage });\n    }\n  };\n\n  onPanelErrorRecover = () => {\n    this.setState({ errorMessage: undefined });\n  };\n\n  onAnnotationCreate = async (event: AnnotationEventUIModel) => {\n    const isRegion = event.from !== event.to;\n    const anno = {\n      dashboardId: this.props.dashboard.id,\n      panelId: this.props.panel.id,\n      isRegion,\n      time: event.from,\n      timeEnd: isRegion ? event.to : 0,\n      tags: event.tags,\n      text: event.description,\n    };\n    await saveAnnotation(anno);\n    getDashboardQueryRunner().run({ dashboard: this.props.dashboard, range: this.timeSrv.timeRange() });\n    this.state.context.eventBus.publish(new AnnotationChangeEvent(anno));\n  };\n\n  onAnnotationDelete = async (id: string) => {\n    await deleteAnnotation({ id });\n    getDashboardQueryRunner().run({ dashboard: this.props.dashboard, range: this.timeSrv.timeRange() });\n    this.state.context.eventBus.publish(new AnnotationChangeEvent({ id }));\n  };\n\n  onAnnotationUpdate = async (event: AnnotationEventUIModel) => {\n    const isRegion = event.from !== event.to;\n    const anno = {\n      id: event.id,\n      dashboardId: this.props.dashboard.id,\n      panelId: this.props.panel.id,\n      isRegion,\n      time: event.from,\n      timeEnd: isRegion ? event.to : 0,\n      tags: event.tags,\n      text: event.description,\n    };\n    await updateAnnotation(anno);\n\n    getDashboardQueryRunner().run({ dashboard: this.props.dashboard, range: this.timeSrv.timeRange() });\n    this.state.context.eventBus.publish(new AnnotationChangeEvent(anno));\n  };\n\n  get hasPanelSnapshot() {\n    const { panel } = this.props;\n    return panel.snapshotData && panel.snapshotData.length;\n  }\n\n  get wantsQueryExecution() {\n    return !(this.props.plugin.meta.skipDataQuery || this.hasPanelSnapshot);\n  }\n\n  onChangeTimeRange = (timeRange: AbsoluteTimeRange) => {\n    this.timeSrv.setTime({\n      from: toUtc(timeRange.from),\n      to: toUtc(timeRange.to),\n    });\n  };\n\n  shouldSignalRenderingCompleted(loadingState: LoadingState, pluginMeta: PanelPluginMeta) {\n    return loadingState === LoadingState.Done || pluginMeta.skipDataQuery;\n  }\n\n  skipFirstRender(loadingState: LoadingState) {\n    const { isFirstLoad } = this.state;\n    return (\n      this.wantsQueryExecution &&\n      isFirstLoad &&\n      (loadingState === LoadingState.Loading || loadingState === LoadingState.NotStarted)\n    );\n  }\n\n  renderPanel(width: number, height: number) {\n    const { panel, plugin, dashboard } = this.props;\n    const { renderCounter, data } = this.state;\n    const { theme } = config;\n    const { state: loadingState } = data;\n\n    // do not render component until we have first data\n    if (this.skipFirstRender(loadingState)) {\n      return null;\n    }\n\n    // This is only done to increase a counter that is used by backend\n    // image rendering to know when to capture image\n    if (this.shouldSignalRenderingCompleted(loadingState, plugin.meta)) {\n      profiler.renderingCompleted();\n    }\n\n    const PanelComponent = plugin.panel!;\n    const timeRange = this.state.liveTime ?? data.timeRange ?? this.timeSrv.timeRange();\n    const headerHeight = this.hasOverlayHeader() ? 0 : theme.panelHeaderHeight;\n    const chromePadding = plugin.noPadding ? 0 : theme.panelPadding;\n    const panelWidth = width - chromePadding * 2 - PANEL_BORDER;\n    const innerPanelHeight = height - headerHeight - chromePadding * 2 - PANEL_BORDER;\n    const panelContentClassNames = classNames({\n      'panel-content': true,\n      'panel-content--no-padding': plugin.noPadding,\n    });\n    const panelOptions = panel.getOptions();\n\n    // Update the event filter (dashboard settings may have changed)\n    // Yes this is called ever render for a function that is triggered on every mouse move\n    this.eventFilter.onlyLocal = dashboard.graphTooltip === 0;\n\n    return (\n      <>\n        <div className={panelContentClassNames}>\n          <PanelContextProvider value={this.state.context}>\n            <PanelComponent\n              id={panel.id}\n              data={data}\n              title={panel.title}\n              timeRange={timeRange}\n              timeZone={this.props.dashboard.getTimezone()}\n              options={panelOptions}\n              fieldConfig={panel.fieldConfig}\n              transparent={panel.transparent}\n              width={panelWidth}\n              height={innerPanelHeight}\n              renderCounter={renderCounter}\n              replaceVariables={panel.replaceVariables}\n              onOptionsChange={this.onOptionsChange}\n              onFieldConfigChange={this.onFieldConfigChange}\n              onChangeTimeRange={this.onChangeTimeRange}\n              eventBus={dashboard.events}\n            />\n          </PanelContextProvider>\n        </div>\n      </>\n    );\n  }\n\n  hasOverlayHeader() {\n    const { panel } = this.props;\n    const { data } = this.state;\n\n    // always show normal header if we have time override\n    if (data.request && data.request.timeInfo) {\n      return false;\n    }\n\n    return !panel.hasTitle();\n  }\n\n  render() {\n    const { dashboard, panel, isViewing, isEditing, width, height, plugin } = this.props;\n    const { errorMessage, data } = this.state;\n    const { transparent } = panel;\n\n    const alertState = data.alertState?.state;\n\n    const containerClassNames = classNames({\n      'panel-container': true,\n      'panel-container--absolute': isSoloRoute(locationService.getLocation().pathname),\n      'panel-container--transparent': transparent,\n      'panel-container--no-title': this.hasOverlayHeader(),\n      [`panel-alert-state--${alertState}`]: alertState !== undefined,\n    });\n\n    return (\n      <section\n        className={containerClassNames}\n        aria-label={selectors.components.Panels.Panel.containerByTitle(panel.title)}\n      >\n        <PanelHeader\n          panel={panel}\n          dashboard={dashboard}\n          title={panel.title}\n          description={panel.description}\n          links={panel.links}\n          error={errorMessage}\n          isEditing={isEditing}\n          isViewing={isViewing}\n          alertState={alertState}\n          data={data}\n        />\n        <ErrorBoundary\n          dependencies={[data, plugin, panel.getOptions()]}\n          onError={this.onPanelError}\n          onRecover={this.onPanelErrorRecover}\n        >\n          {({ error }) => {\n            if (error) {\n              return null;\n            }\n            return this.renderPanel(width, height);\n          }}\n        </ErrorBoundary>\n      </section>\n    );\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}