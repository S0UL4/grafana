{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * Keeps track of the height and y-position for anything sequenctial where\n * y-positions follow one-after-another and can be derived from the height of\n * the prior entries. The height is known from an accessor function parameter\n * to the methods that require new knowledge the heights.\n *\n * @export\n * @class Positions\n */\nexport default class Positions {\n  /**\n   * Indicates how far past the explicitly required height or y-values should\n   * checked.\n   */\n\n  /**\n   * `lastI` keeps track of which values have already been visited. In many\n   * scenarios, values do not need to be revisited. But, revisiting is required\n   * when heights have changed, so `lastI` can be forced.\n   */\n  constructor(bufferLen) {\n    _defineProperty(this, \"bufferLen\", void 0);\n\n    _defineProperty(this, \"dataLen\", void 0);\n\n    _defineProperty(this, \"heights\", void 0);\n\n    _defineProperty(this, \"lastI\", void 0);\n\n    _defineProperty(this, \"ys\", void 0);\n\n    this.ys = [];\n    this.heights = [];\n    this.bufferLen = bufferLen;\n    this.dataLen = -1;\n    this.lastI = -1;\n  }\n  /**\n   * Used to make sure the length of y-values and heights is consistent with\n   * the context; in particular `lastI` needs to remain valid.\n   */\n\n\n  profileData(dataLength) {\n    if (dataLength !== this.dataLen) {\n      this.dataLen = dataLength;\n      this.ys.length = dataLength;\n      this.heights.length = dataLength;\n\n      if (this.lastI >= dataLength) {\n        this.lastI = dataLength - 1;\n      }\n    }\n  }\n  /**\n   * Calculate and save the heights and y-values, based on `heightGetter`, from\n   * `lastI` until the`max` index; the starting point (`lastI`) can be forced\n   * via the `forcedLastI` parameter.\n   * @param {number=} forcedLastI\n   */\n\n\n  calcHeights(max, heightGetter, forcedLastI) {\n    if (forcedLastI != null) {\n      this.lastI = forcedLastI;\n    }\n\n    let _max = max + this.bufferLen;\n\n    if (_max <= this.lastI) {\n      return;\n    }\n\n    if (_max >= this.heights.length) {\n      _max = this.heights.length - 1;\n    }\n\n    let i = this.lastI;\n\n    if (this.lastI === -1) {\n      i = 0;\n      this.ys[0] = 0;\n    }\n\n    while (i <= _max) {\n      // eslint-disable-next-line no-multi-assign\n      const h = this.heights[i] = heightGetter(i);\n      this.ys[i + 1] = this.ys[i] + h;\n      i++;\n    }\n\n    this.lastI = _max;\n  }\n  /**\n   * Verify the height and y-values from `lastI` up to `yValue`.\n   */\n\n\n  calcYs(yValue, heightGetter) {\n    while ((this.ys[this.lastI] == null || yValue > this.ys[this.lastI]) && this.lastI < this.dataLen - 1) {\n      this.calcHeights(this.lastI, heightGetter);\n    }\n  }\n  /**\n   * Get the latest height for index `_i`. If it's in new terretory\n   * (_i > lastI), find the heights (and y-values) leading up to it. If it's in\n   * known territory (_i <= lastI) and the height is different than what is\n   * known, recalculate subsequent y values, but don't confirm the heights of\n   * those items, just update based on the difference.\n   */\n\n\n  confirmHeight(_i, heightGetter) {\n    let i = _i;\n\n    if (i > this.lastI) {\n      this.calcHeights(i, heightGetter);\n      return;\n    }\n\n    const h = heightGetter(i);\n\n    if (h === this.heights[i]) {\n      return;\n    }\n\n    const chg = h - this.heights[i];\n    this.heights[i] = h; // shift the y positions by `chg` for all known y positions\n\n    while (++i <= this.lastI) {\n      this.ys[i] += chg;\n    }\n\n    if (this.ys[this.lastI + 1] != null) {\n      this.ys[this.lastI + 1] += chg;\n    }\n  }\n  /**\n   * Given a target y-value (`yValue`), find the closest index (in the `.ys`\n   * array) that is prior to the y-value; e.g. map from y-value to index in\n   * `.ys`.\n   */\n\n\n  findFloorIndex(yValue, heightGetter) {\n    this.calcYs(yValue, heightGetter);\n    let imin = 0;\n    let imax = this.lastI;\n\n    if (this.ys.length < 2 || yValue < this.ys[1]) {\n      return 0;\n    }\n\n    if (yValue > this.ys[imax]) {\n      return imax;\n    }\n\n    let i;\n\n    while (imin < imax) {\n      // eslint-disable-next-line no-bitwise\n      i = imin + 0.5 * (imax - imin) | 0;\n\n      if (yValue > this.ys[i]) {\n        if (yValue <= this.ys[i + 1]) {\n          return i;\n        }\n\n        imin = i;\n      } else if (yValue < this.ys[i]) {\n        if (yValue >= this.ys[i - 1]) {\n          return i - 1;\n        }\n\n        imax = i;\n      } else {\n        return i;\n      }\n    }\n\n    throw new Error(`unable to find floor index for y=${yValue}`);\n  }\n  /**\n   * Get the `y` and `height` for a given row.\n   *\n   * @returns {{ height: number, y: number }}\n   */\n\n\n  getRowPosition(index, heightGetter) {\n    this.confirmHeight(index, heightGetter);\n    return {\n      height: this.heights[index],\n      y: this.ys[index]\n    };\n  }\n  /**\n   * Get the estimated height of the whole shebang by extrapolating based on\n   * the average known height.\n   */\n\n\n  getEstimatedHeight() {\n    const known = this.ys[this.lastI] + this.heights[this.lastI];\n\n    if (this.lastI >= this.dataLen - 1) {\n      // eslint-disable-next-line no-bitwise\n      return known | 0;\n    } // eslint-disable-next-line no-bitwise\n\n\n    return known / (this.lastI + 1) * this.heights.length | 0;\n  }\n\n}","map":{"version":3,"names":["Positions","constructor","bufferLen","ys","heights","dataLen","lastI","profileData","dataLength","length","calcHeights","max","heightGetter","forcedLastI","_max","i","h","calcYs","yValue","confirmHeight","_i","chg","findFloorIndex","imin","imax","Error","getRowPosition","index","height","y","getEstimatedHeight","known"],"sources":["/home/soula/grafana/packages/jaeger-ui-components/src/TraceTimelineViewer/ListView/Positions.tsx"],"sourcesContent":["// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\ntype THeightGetter = (index: number) => number;\n\n/**\n * Keeps track of the height and y-position for anything sequenctial where\n * y-positions follow one-after-another and can be derived from the height of\n * the prior entries. The height is known from an accessor function parameter\n * to the methods that require new knowledge the heights.\n *\n * @export\n * @class Positions\n */\nexport default class Positions {\n  /**\n   * Indicates how far past the explicitly required height or y-values should\n   * checked.\n   */\n  bufferLen: number;\n  dataLen: number;\n  heights: number[];\n  /**\n   * `lastI` keeps track of which values have already been visited. In many\n   * scenarios, values do not need to be revisited. But, revisiting is required\n   * when heights have changed, so `lastI` can be forced.\n   */\n  lastI: number;\n  ys: number[];\n\n  constructor(bufferLen: number) {\n    this.ys = [];\n    this.heights = [];\n    this.bufferLen = bufferLen;\n    this.dataLen = -1;\n    this.lastI = -1;\n  }\n\n  /**\n   * Used to make sure the length of y-values and heights is consistent with\n   * the context; in particular `lastI` needs to remain valid.\n   */\n  profileData(dataLength: number) {\n    if (dataLength !== this.dataLen) {\n      this.dataLen = dataLength;\n      this.ys.length = dataLength;\n      this.heights.length = dataLength;\n      if (this.lastI >= dataLength) {\n        this.lastI = dataLength - 1;\n      }\n    }\n  }\n\n  /**\n   * Calculate and save the heights and y-values, based on `heightGetter`, from\n   * `lastI` until the`max` index; the starting point (`lastI`) can be forced\n   * via the `forcedLastI` parameter.\n   * @param {number=} forcedLastI\n   */\n  calcHeights(max: number, heightGetter: THeightGetter, forcedLastI?: number) {\n    if (forcedLastI != null) {\n      this.lastI = forcedLastI;\n    }\n    let _max = max + this.bufferLen;\n    if (_max <= this.lastI) {\n      return;\n    }\n    if (_max >= this.heights.length) {\n      _max = this.heights.length - 1;\n    }\n    let i = this.lastI;\n    if (this.lastI === -1) {\n      i = 0;\n      this.ys[0] = 0;\n    }\n    while (i <= _max) {\n      // eslint-disable-next-line no-multi-assign\n      const h = (this.heights[i] = heightGetter(i));\n      this.ys[i + 1] = this.ys[i] + h;\n      i++;\n    }\n    this.lastI = _max;\n  }\n\n  /**\n   * Verify the height and y-values from `lastI` up to `yValue`.\n   */\n  calcYs(yValue: number, heightGetter: THeightGetter) {\n    while ((this.ys[this.lastI] == null || yValue > this.ys[this.lastI]) && this.lastI < this.dataLen - 1) {\n      this.calcHeights(this.lastI, heightGetter);\n    }\n  }\n\n  /**\n   * Get the latest height for index `_i`. If it's in new terretory\n   * (_i > lastI), find the heights (and y-values) leading up to it. If it's in\n   * known territory (_i <= lastI) and the height is different than what is\n   * known, recalculate subsequent y values, but don't confirm the heights of\n   * those items, just update based on the difference.\n   */\n  confirmHeight(_i: number, heightGetter: THeightGetter) {\n    let i = _i;\n    if (i > this.lastI) {\n      this.calcHeights(i, heightGetter);\n      return;\n    }\n    const h = heightGetter(i);\n    if (h === this.heights[i]) {\n      return;\n    }\n    const chg = h - this.heights[i];\n    this.heights[i] = h;\n    // shift the y positions by `chg` for all known y positions\n    while (++i <= this.lastI) {\n      this.ys[i] += chg;\n    }\n    if (this.ys[this.lastI + 1] != null) {\n      this.ys[this.lastI + 1] += chg;\n    }\n  }\n\n  /**\n   * Given a target y-value (`yValue`), find the closest index (in the `.ys`\n   * array) that is prior to the y-value; e.g. map from y-value to index in\n   * `.ys`.\n   */\n  findFloorIndex(yValue: number, heightGetter: THeightGetter): number {\n    this.calcYs(yValue, heightGetter);\n\n    let imin = 0;\n    let imax = this.lastI;\n\n    if (this.ys.length < 2 || yValue < this.ys[1]) {\n      return 0;\n    }\n    if (yValue > this.ys[imax]) {\n      return imax;\n    }\n    let i;\n    while (imin < imax) {\n      // eslint-disable-next-line no-bitwise\n      i = (imin + 0.5 * (imax - imin)) | 0;\n      if (yValue > this.ys[i]) {\n        if (yValue <= this.ys[i + 1]) {\n          return i;\n        }\n        imin = i;\n      } else if (yValue < this.ys[i]) {\n        if (yValue >= this.ys[i - 1]) {\n          return i - 1;\n        }\n        imax = i;\n      } else {\n        return i;\n      }\n    }\n    throw new Error(`unable to find floor index for y=${yValue}`);\n  }\n\n  /**\n   * Get the `y` and `height` for a given row.\n   *\n   * @returns {{ height: number, y: number }}\n   */\n  getRowPosition(index: number, heightGetter: THeightGetter) {\n    this.confirmHeight(index, heightGetter);\n    return {\n      height: this.heights[index],\n      y: this.ys[index],\n    };\n  }\n\n  /**\n   * Get the estimated height of the whole shebang by extrapolating based on\n   * the average known height.\n   */\n  getEstimatedHeight(): number {\n    const known = this.ys[this.lastI] + this.heights[this.lastI];\n    if (this.lastI >= this.dataLen - 1) {\n      // eslint-disable-next-line no-bitwise\n      return known | 0;\n    }\n    // eslint-disable-next-line no-bitwise\n    return ((known / (this.lastI + 1)) * this.heights.length) | 0;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}