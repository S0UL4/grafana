{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { isEqual } from 'lodash';\nimport { PureComponent } from 'react';\nimport { interval, Subject, of, NEVER } from 'rxjs';\nimport { tap, switchMap } from 'rxjs/operators';\nimport { stringToMs } from '@grafana/data';\nimport { RefreshPicker } from '../RefreshPicker/RefreshPicker';\nexport function getIntervalFromString(strInterval) {\n  return {\n    label: strInterval,\n    value: stringToMs(strInterval)\n  };\n}\nexport class SetInterval extends PureComponent {\n  constructor(props) {\n    super(props);\n\n    _defineProperty(this, \"propsSubject\", void 0);\n\n    _defineProperty(this, \"subscription\", void 0);\n\n    this.propsSubject = new Subject();\n    this.subscription = null;\n  }\n\n  componentDidMount() {\n    // Creating a subscription to propsSubject. This subject pushes values every time\n    // SetInterval's props change\n    this.subscription = this.propsSubject.pipe( // switchMap creates a new observables based on the input stream,\n    // which becomes part of the propsSubject stream\n    switchMap(props => {\n      // If the query is live, empty value is emitted. `of` creates single value,\n      // which is merged to propsSubject stream\n      if (RefreshPicker.isLive(props.interval)) {\n        return of({});\n      } // When query is loading, a new stream is merged. But it's a stream that emits no values(NEVER),\n      // hence next call of this function will happen when query changes, and new props are passed into this component\n      // When query is NOT loading, a new value is emitted, this time it's an interval value,\n      // which makes tap function below execute on that interval basis.\n\n\n      return props.loading ? NEVER : interval(stringToMs(props.interval));\n    }), // tap will execute function passed via func prop\n    // * on value from `of` stream merged if query is live\n    // * on specified interval (triggered by values emitted by interval)\n    tap(() => this.props.func())).subscribe(); // When component has mounted, propsSubject emits it's first value\n\n    this.propsSubject.next(this.props);\n  }\n\n  componentDidUpdate(prevProps) {\n    if (RefreshPicker.isLive(prevProps.interval) && RefreshPicker.isLive(this.props.interval) || isEqual(prevProps, this.props)) {\n      return;\n    } // if props changed, a new value is emitted from propsSubject\n\n\n    this.propsSubject.next(this.props);\n  }\n\n  componentWillUnmount() {\n    if (this.subscription) {\n      this.subscription.unsubscribe();\n    }\n\n    this.propsSubject.unsubscribe();\n  }\n\n  render() {\n    return null;\n  }\n\n}","map":{"version":3,"names":["isEqual","PureComponent","interval","Subject","of","NEVER","tap","switchMap","stringToMs","RefreshPicker","getIntervalFromString","strInterval","label","value","SetInterval","constructor","props","propsSubject","subscription","componentDidMount","pipe","isLive","loading","func","subscribe","next","componentDidUpdate","prevProps","componentWillUnmount","unsubscribe","render"],"sources":["/home/soula/grafana/packages/grafana-ui/src/components/SetInterval/SetInterval.tsx"],"sourcesContent":["import { isEqual } from 'lodash';\nimport { PureComponent } from 'react';\nimport { interval, Subscription, Subject, of, NEVER } from 'rxjs';\nimport { tap, switchMap } from 'rxjs/operators';\n\nimport { stringToMs, SelectableValue } from '@grafana/data';\n\nimport { RefreshPicker } from '../RefreshPicker/RefreshPicker';\n\nexport function getIntervalFromString(strInterval: string): SelectableValue<number> {\n  return {\n    label: strInterval,\n    value: stringToMs(strInterval),\n  };\n}\n\ninterface Props {\n  func: () => any; // TODO\n  loading: boolean;\n  interval: string;\n}\n\nexport class SetInterval extends PureComponent<Props> {\n  private propsSubject: Subject<Props>;\n  private subscription: Subscription | null;\n\n  constructor(props: Props) {\n    super(props);\n    this.propsSubject = new Subject<Props>();\n    this.subscription = null;\n  }\n\n  componentDidMount() {\n    // Creating a subscription to propsSubject. This subject pushes values every time\n    // SetInterval's props change\n    this.subscription = this.propsSubject\n      .pipe(\n        // switchMap creates a new observables based on the input stream,\n        // which becomes part of the propsSubject stream\n        switchMap((props) => {\n          // If the query is live, empty value is emitted. `of` creates single value,\n          // which is merged to propsSubject stream\n          if (RefreshPicker.isLive(props.interval)) {\n            return of({});\n          }\n\n          // When query is loading, a new stream is merged. But it's a stream that emits no values(NEVER),\n          // hence next call of this function will happen when query changes, and new props are passed into this component\n          // When query is NOT loading, a new value is emitted, this time it's an interval value,\n          // which makes tap function below execute on that interval basis.\n          return props.loading ? NEVER : interval(stringToMs(props.interval));\n        }),\n        // tap will execute function passed via func prop\n        // * on value from `of` stream merged if query is live\n        // * on specified interval (triggered by values emitted by interval)\n        tap(() => this.props.func())\n      )\n      .subscribe();\n\n    // When component has mounted, propsSubject emits it's first value\n    this.propsSubject.next(this.props);\n  }\n\n  componentDidUpdate(prevProps: Props) {\n    if (\n      (RefreshPicker.isLive(prevProps.interval) && RefreshPicker.isLive(this.props.interval)) ||\n      isEqual(prevProps, this.props)\n    ) {\n      return;\n    }\n    // if props changed, a new value is emitted from propsSubject\n    this.propsSubject.next(this.props);\n  }\n\n  componentWillUnmount() {\n    if (this.subscription) {\n      this.subscription.unsubscribe();\n    }\n\n    this.propsSubject.unsubscribe();\n  }\n\n  render(): null {\n    return null;\n  }\n}\n"],"mappings":";;AAAA,SAASA,OAAT,QAAwB,QAAxB;AACA,SAASC,aAAT,QAA8B,OAA9B;AACA,SAASC,QAAT,EAAiCC,OAAjC,EAA0CC,EAA1C,EAA8CC,KAA9C,QAA2D,MAA3D;AACA,SAASC,GAAT,EAAcC,SAAd,QAA+B,gBAA/B;AAEA,SAASC,UAAT,QAA4C,eAA5C;AAEA,SAASC,aAAT,QAA8B,gCAA9B;AAEA,OAAO,SAASC,qBAAT,CAA+BC,WAA/B,EAA6E;EAClF,OAAO;IACLC,KAAK,EAAED,WADF;IAELE,KAAK,EAAEL,UAAU,CAACG,WAAD;EAFZ,CAAP;AAID;AAQD,OAAO,MAAMG,WAAN,SAA0Bb,aAA1B,CAA+C;EAIpDc,WAAW,CAACC,KAAD,EAAe;IACxB,MAAMA,KAAN;;IADwB;;IAAA;;IAExB,KAAKC,YAAL,GAAoB,IAAId,OAAJ,EAApB;IACA,KAAKe,YAAL,GAAoB,IAApB;EACD;;EAEDC,iBAAiB,GAAG;IAClB;IACA;IACA,KAAKD,YAAL,GAAoB,KAAKD,YAAL,CACjBG,IADiB,EAEhB;IACA;IACAb,SAAS,CAAES,KAAD,IAAW;MACnB;MACA;MACA,IAAIP,aAAa,CAACY,MAAd,CAAqBL,KAAK,CAACd,QAA3B,CAAJ,EAA0C;QACxC,OAAOE,EAAE,CAAC,EAAD,CAAT;MACD,CALkB,CAOnB;MACA;MACA;MACA;;;MACA,OAAOY,KAAK,CAACM,OAAN,GAAgBjB,KAAhB,GAAwBH,QAAQ,CAACM,UAAU,CAACQ,KAAK,CAACd,QAAP,CAAX,CAAvC;IACD,CAZQ,CAJO,EAiBhB;IACA;IACA;IACAI,GAAG,CAAC,MAAM,KAAKU,KAAL,CAAWO,IAAX,EAAP,CApBa,EAsBjBC,SAtBiB,EAApB,CAHkB,CA2BlB;;IACA,KAAKP,YAAL,CAAkBQ,IAAlB,CAAuB,KAAKT,KAA5B;EACD;;EAEDU,kBAAkB,CAACC,SAAD,EAAmB;IACnC,IACGlB,aAAa,CAACY,MAAd,CAAqBM,SAAS,CAACzB,QAA/B,KAA4CO,aAAa,CAACY,MAAd,CAAqB,KAAKL,KAAL,CAAWd,QAAhC,CAA7C,IACAF,OAAO,CAAC2B,SAAD,EAAY,KAAKX,KAAjB,CAFT,EAGE;MACA;IACD,CANkC,CAOnC;;;IACA,KAAKC,YAAL,CAAkBQ,IAAlB,CAAuB,KAAKT,KAA5B;EACD;;EAEDY,oBAAoB,GAAG;IACrB,IAAI,KAAKV,YAAT,EAAuB;MACrB,KAAKA,YAAL,CAAkBW,WAAlB;IACD;;IAED,KAAKZ,YAAL,CAAkBY,WAAlB;EACD;;EAEDC,MAAM,GAAS;IACb,OAAO,IAAP;EACD;;AA9DmD"},"metadata":{},"sourceType":"module"}