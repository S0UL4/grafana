{"ast":null,"code":"import { deleteRulerRulesGroup, fetchRulerRulesGroup, fetchRulerRules, setRulerRuleGroup } from '../api/ruler';\nimport * as ruleId from '../utils/rule-id';\nimport { GRAFANA_RULES_SOURCE_NAME } from './datasource';\nimport { formValuesToRulerGrafanaRuleDTO, formValuesToRulerRuleDTO } from './rule-form';\nimport { isCloudRuleIdentifier, isGrafanaRuleIdentifier, isGrafanaRulerRule, isPrometheusRuleIdentifier } from './rules';\nexport function getRulerClient(rulerConfig) {\n  const findEditableRule = async ruleIdentifier => {\n    if (isGrafanaRuleIdentifier(ruleIdentifier)) {\n      const namespaces = await fetchRulerRules(rulerConfig); // find namespace and group that contains the uid for the rule\n\n      for (const [namespace, groups] of Object.entries(namespaces)) {\n        for (const group of groups) {\n          const rule = group.rules.find(rule => {\n            var _rule$grafana_alert;\n\n            return isGrafanaRulerRule(rule) && ((_rule$grafana_alert = rule.grafana_alert) === null || _rule$grafana_alert === void 0 ? void 0 : _rule$grafana_alert.uid) === ruleIdentifier.uid;\n          });\n\n          if (rule) {\n            return {\n              group,\n              ruleSourceName: GRAFANA_RULES_SOURCE_NAME,\n              namespace: namespace,\n              rule\n            };\n          }\n        }\n      }\n    }\n\n    if (isCloudRuleIdentifier(ruleIdentifier)) {\n      const {\n        ruleSourceName,\n        namespace,\n        groupName\n      } = ruleIdentifier;\n      const group = await fetchRulerRulesGroup(rulerConfig, namespace, groupName);\n\n      if (!group) {\n        return null;\n      }\n\n      const rule = group.rules.find(rule => {\n        const identifier = ruleId.fromRulerRule(ruleSourceName, namespace, group.name, rule);\n        return ruleId.equal(identifier, ruleIdentifier);\n      });\n\n      if (!rule) {\n        return null;\n      }\n\n      return {\n        group,\n        ruleSourceName,\n        namespace,\n        rule\n      };\n    }\n\n    if (isPrometheusRuleIdentifier(ruleIdentifier)) {\n      throw new Error('Native prometheus rules can not be edited in grafana.');\n    }\n\n    return null;\n  };\n\n  const deleteRule = async ruleWithLocation => {\n    const {\n      namespace,\n      group,\n      rule\n    } = ruleWithLocation; // it was the last rule, delete the entire group\n\n    if (group.rules.length === 1) {\n      await deleteRulerRulesGroup(rulerConfig, namespace, group.name);\n      return;\n    } // post the group with rule removed\n\n\n    await setRulerRuleGroup(rulerConfig, namespace, Object.assign({}, group, {\n      rules: group.rules.filter(r => r !== rule)\n    }));\n  };\n\n  const saveLotexRule = async (values, existing) => {\n    const {\n      dataSourceName,\n      group,\n      namespace\n    } = values;\n    const formRule = formValuesToRulerRuleDTO(values);\n\n    if (dataSourceName && group && namespace) {\n      // if we're updating a rule...\n      if (existing) {\n        // refetch it so we always have the latest greatest\n        const freshExisting = await findEditableRule(ruleId.fromRuleWithLocation(existing));\n\n        if (!freshExisting) {\n          throw new Error('Rule not found.');\n        } // if namespace or group was changed, delete the old rule\n\n\n        if (freshExisting.namespace !== namespace || freshExisting.group.name !== group) {\n          await deleteRule(freshExisting);\n        } else {\n          // if same namespace or group, update the group replacing the old rule with new\n          const payload = Object.assign({}, freshExisting.group, {\n            rules: freshExisting.group.rules.map(existingRule => existingRule === freshExisting.rule ? formRule : existingRule)\n          });\n          await setRulerRuleGroup(rulerConfig, namespace, payload);\n          return ruleId.fromRulerRule(dataSourceName, namespace, group, formRule);\n        }\n      } // if creating new rule or existing rule was in a different namespace/group, create new rule in target group\n\n\n      const targetGroup = await fetchRulerRulesGroup(rulerConfig, namespace, group);\n      const payload = targetGroup ? Object.assign({}, targetGroup, {\n        rules: [...targetGroup.rules, formRule]\n      }) : {\n        name: group,\n        rules: [formRule]\n      };\n      await setRulerRuleGroup(rulerConfig, namespace, payload);\n      return ruleId.fromRulerRule(dataSourceName, namespace, group, formRule);\n    } else {\n      throw new Error('Data source and location must be specified');\n    }\n  };\n\n  const saveGrafanaRule = async (values, existingRule) => {\n    const {\n      folder,\n      group,\n      evaluateEvery\n    } = values;\n\n    if (!folder) {\n      throw new Error('Folder must be specified');\n    }\n\n    const newRule = formValuesToRulerGrafanaRuleDTO(values);\n    const namespace = folder.title;\n    const groupSpec = {\n      name: group,\n      interval: evaluateEvery\n    };\n\n    if (!existingRule) {\n      return addRuleToNamespaceAndGroup(namespace, groupSpec, newRule);\n    }\n\n    const sameNamespace = existingRule.namespace === namespace;\n    const sameGroup = existingRule.group.name === values.group;\n    const sameLocation = sameNamespace && sameGroup;\n\n    if (sameLocation) {\n      // we're update a rule in the same namespace and group\n      return updateGrafanaRule(existingRule, newRule, evaluateEvery);\n    } else {\n      // we're moving a rule to either a different group or namespace\n      return moveGrafanaRule(namespace, groupSpec, existingRule, newRule);\n    }\n  };\n\n  const addRuleToNamespaceAndGroup = async (namespace, group, newRule) => {\n    var _existingGroup$rules, _newRule$grafana_aler;\n\n    const existingGroup = await fetchRulerRulesGroup(rulerConfig, namespace, group.name);\n\n    if (!existingGroup) {\n      throw new Error(`No group found with name \"${group.name}\"`);\n    }\n\n    const payload = {\n      name: group.name,\n      interval: group.interval,\n      rules: ((_existingGroup$rules = existingGroup.rules) !== null && _existingGroup$rules !== void 0 ? _existingGroup$rules : []).concat(newRule)\n    };\n    await setRulerRuleGroup(rulerConfig, namespace, payload);\n    return {\n      uid: (_newRule$grafana_aler = newRule.grafana_alert.uid) !== null && _newRule$grafana_aler !== void 0 ? _newRule$grafana_aler : '',\n      ruleSourceName: GRAFANA_RULES_SOURCE_NAME\n    };\n  }; // move the rule to another namespace / groupname\n\n\n  const moveGrafanaRule = async (namespace, group, existingRule, newRule) => {\n    // make sure our updated alert has the same UID as before\n    // that way the rule is automatically moved to the new namespace / group name\n    copyGrafanaUID(existingRule, newRule); // add the new rule to the requested namespace and group\n\n    const identifier = await addRuleToNamespaceAndGroup(namespace, group, newRule);\n    return identifier;\n  };\n\n  const updateGrafanaRule = async (existingRule, newRule, interval) => {\n    // make sure our updated alert has the same UID as before\n    copyGrafanaUID(existingRule, newRule); // create the new array of rules we want to send to the group. Keep the order of alerts in the group.\n\n    const newRules = existingRule.group.rules.map(rule => {\n      if (!isGrafanaRulerRule(rule)) {\n        return rule;\n      }\n\n      if (rule.grafana_alert.uid === existingRule.rule.grafana_alert.uid) {\n        return newRule;\n      }\n\n      return rule;\n    });\n    await setRulerRuleGroup(rulerConfig, existingRule.namespace, {\n      name: existingRule.group.name,\n      interval: interval,\n      rules: newRules\n    });\n    return {\n      uid: existingRule.rule.grafana_alert.uid,\n      ruleSourceName: GRAFANA_RULES_SOURCE_NAME\n    };\n  }; // Would be nice to somehow align checking of ruler type between different methods\n  // Maybe each datasource should have its own ruler client implementation\n\n\n  return {\n    findEditableRule,\n    deleteRule,\n    saveLotexRule,\n    saveGrafanaRule\n  };\n} //copy the Grafana rule UID from the old rule to the new rule\n\nfunction copyGrafanaUID(oldRule, newRule) {\n  // type guard to make sure we're working with a Grafana managed rule\n  if (!isGrafanaRulerRule(oldRule.rule)) {\n    throw new Error('The rule is not a Grafana managed rule');\n  }\n\n  const uid = oldRule.rule.grafana_alert.uid;\n  newRule.grafana_alert.uid = uid;\n}","map":{"version":3,"names":["deleteRulerRulesGroup","fetchRulerRulesGroup","fetchRulerRules","setRulerRuleGroup","ruleId","GRAFANA_RULES_SOURCE_NAME","formValuesToRulerGrafanaRuleDTO","formValuesToRulerRuleDTO","isCloudRuleIdentifier","isGrafanaRuleIdentifier","isGrafanaRulerRule","isPrometheusRuleIdentifier","getRulerClient","rulerConfig","findEditableRule","ruleIdentifier","namespaces","namespace","groups","Object","entries","group","rule","rules","find","grafana_alert","uid","ruleSourceName","groupName","identifier","fromRulerRule","name","equal","Error","deleteRule","ruleWithLocation","length","filter","r","saveLotexRule","values","existing","dataSourceName","formRule","freshExisting","fromRuleWithLocation","payload","map","existingRule","targetGroup","saveGrafanaRule","folder","evaluateEvery","newRule","title","groupSpec","interval","addRuleToNamespaceAndGroup","sameNamespace","sameGroup","sameLocation","updateGrafanaRule","moveGrafanaRule","existingGroup","concat","copyGrafanaUID","newRules","oldRule"],"sources":["/home/soula/grafana/public/app/features/alerting/unified/utils/rulerClient.ts"],"sourcesContent":["import { RuleIdentifier, RulerDataSourceConfig, RuleWithLocation } from 'app/types/unified-alerting';\nimport {\n  PostableRuleGrafanaRuleDTO,\n  PostableRulerRuleGroupDTO,\n  RulerGrafanaRuleDTO,\n  RulerRuleGroupDTO,\n} from 'app/types/unified-alerting-dto';\n\nimport { deleteRulerRulesGroup, fetchRulerRulesGroup, fetchRulerRules, setRulerRuleGroup } from '../api/ruler';\nimport { RuleFormValues } from '../types/rule-form';\nimport * as ruleId from '../utils/rule-id';\n\nimport { GRAFANA_RULES_SOURCE_NAME } from './datasource';\nimport { formValuesToRulerGrafanaRuleDTO, formValuesToRulerRuleDTO } from './rule-form';\nimport {\n  isCloudRuleIdentifier,\n  isGrafanaRuleIdentifier,\n  isGrafanaRulerRule,\n  isPrometheusRuleIdentifier,\n} from './rules';\n\nexport interface RulerClient {\n  findEditableRule(ruleIdentifier: RuleIdentifier): Promise<RuleWithLocation | null>;\n  deleteRule(ruleWithLocation: RuleWithLocation): Promise<void>;\n  saveLotexRule(values: RuleFormValues, existing?: RuleWithLocation): Promise<RuleIdentifier>;\n  saveGrafanaRule(values: RuleFormValues, existing?: RuleWithLocation): Promise<RuleIdentifier>;\n}\n\nexport function getRulerClient(rulerConfig: RulerDataSourceConfig): RulerClient {\n  const findEditableRule = async (ruleIdentifier: RuleIdentifier): Promise<RuleWithLocation | null> => {\n    if (isGrafanaRuleIdentifier(ruleIdentifier)) {\n      const namespaces = await fetchRulerRules(rulerConfig);\n      // find namespace and group that contains the uid for the rule\n      for (const [namespace, groups] of Object.entries(namespaces)) {\n        for (const group of groups) {\n          const rule = group.rules.find(\n            (rule) => isGrafanaRulerRule(rule) && rule.grafana_alert?.uid === ruleIdentifier.uid\n          );\n          if (rule) {\n            return {\n              group,\n              ruleSourceName: GRAFANA_RULES_SOURCE_NAME,\n              namespace: namespace,\n              rule,\n            };\n          }\n        }\n      }\n    }\n\n    if (isCloudRuleIdentifier(ruleIdentifier)) {\n      const { ruleSourceName, namespace, groupName } = ruleIdentifier;\n      const group = await fetchRulerRulesGroup(rulerConfig, namespace, groupName);\n\n      if (!group) {\n        return null;\n      }\n\n      const rule = group.rules.find((rule) => {\n        const identifier = ruleId.fromRulerRule(ruleSourceName, namespace, group.name, rule);\n        return ruleId.equal(identifier, ruleIdentifier);\n      });\n\n      if (!rule) {\n        return null;\n      }\n\n      return {\n        group,\n        ruleSourceName,\n        namespace,\n        rule,\n      };\n    }\n\n    if (isPrometheusRuleIdentifier(ruleIdentifier)) {\n      throw new Error('Native prometheus rules can not be edited in grafana.');\n    }\n\n    return null;\n  };\n\n  const deleteRule = async (ruleWithLocation: RuleWithLocation): Promise<void> => {\n    const { namespace, group, rule } = ruleWithLocation;\n\n    // it was the last rule, delete the entire group\n    if (group.rules.length === 1) {\n      await deleteRulerRulesGroup(rulerConfig, namespace, group.name);\n      return;\n    }\n    // post the group with rule removed\n    await setRulerRuleGroup(rulerConfig, namespace, {\n      ...group,\n      rules: group.rules.filter((r) => r !== rule),\n    });\n  };\n\n  const saveLotexRule = async (values: RuleFormValues, existing?: RuleWithLocation): Promise<RuleIdentifier> => {\n    const { dataSourceName, group, namespace } = values;\n    const formRule = formValuesToRulerRuleDTO(values);\n    if (dataSourceName && group && namespace) {\n      // if we're updating a rule...\n      if (existing) {\n        // refetch it so we always have the latest greatest\n        const freshExisting = await findEditableRule(ruleId.fromRuleWithLocation(existing));\n        if (!freshExisting) {\n          throw new Error('Rule not found.');\n        }\n        // if namespace or group was changed, delete the old rule\n        if (freshExisting.namespace !== namespace || freshExisting.group.name !== group) {\n          await deleteRule(freshExisting);\n        } else {\n          // if same namespace or group, update the group replacing the old rule with new\n          const payload = {\n            ...freshExisting.group,\n            rules: freshExisting.group.rules.map((existingRule) =>\n              existingRule === freshExisting.rule ? formRule : existingRule\n            ),\n          };\n          await setRulerRuleGroup(rulerConfig, namespace, payload);\n          return ruleId.fromRulerRule(dataSourceName, namespace, group, formRule);\n        }\n      }\n\n      // if creating new rule or existing rule was in a different namespace/group, create new rule in target group\n\n      const targetGroup = await fetchRulerRulesGroup(rulerConfig, namespace, group);\n\n      const payload: RulerRuleGroupDTO = targetGroup\n        ? {\n            ...targetGroup,\n            rules: [...targetGroup.rules, formRule],\n          }\n        : {\n            name: group,\n            rules: [formRule],\n          };\n\n      await setRulerRuleGroup(rulerConfig, namespace, payload);\n      return ruleId.fromRulerRule(dataSourceName, namespace, group, formRule);\n    } else {\n      throw new Error('Data source and location must be specified');\n    }\n  };\n\n  const saveGrafanaRule = async (values: RuleFormValues, existingRule?: RuleWithLocation): Promise<RuleIdentifier> => {\n    const { folder, group, evaluateEvery } = values;\n    if (!folder) {\n      throw new Error('Folder must be specified');\n    }\n\n    const newRule = formValuesToRulerGrafanaRuleDTO(values);\n    const namespace = folder.title;\n    const groupSpec = { name: group, interval: evaluateEvery };\n\n    if (!existingRule) {\n      return addRuleToNamespaceAndGroup(namespace, groupSpec, newRule);\n    }\n\n    const sameNamespace = existingRule.namespace === namespace;\n    const sameGroup = existingRule.group.name === values.group;\n    const sameLocation = sameNamespace && sameGroup;\n\n    if (sameLocation) {\n      // we're update a rule in the same namespace and group\n      return updateGrafanaRule(existingRule, newRule, evaluateEvery);\n    } else {\n      // we're moving a rule to either a different group or namespace\n      return moveGrafanaRule(namespace, groupSpec, existingRule, newRule);\n    }\n  };\n\n  const addRuleToNamespaceAndGroup = async (\n    namespace: string,\n    group: { name: string; interval: string },\n    newRule: PostableRuleGrafanaRuleDTO\n  ): Promise<RuleIdentifier> => {\n    const existingGroup = await fetchRulerRulesGroup(rulerConfig, namespace, group.name);\n    if (!existingGroup) {\n      throw new Error(`No group found with name \"${group.name}\"`);\n    }\n\n    const payload: PostableRulerRuleGroupDTO = {\n      name: group.name,\n      interval: group.interval,\n      rules: (existingGroup.rules ?? []).concat(newRule as RulerGrafanaRuleDTO),\n    };\n\n    await setRulerRuleGroup(rulerConfig, namespace, payload);\n\n    return { uid: newRule.grafana_alert.uid ?? '', ruleSourceName: GRAFANA_RULES_SOURCE_NAME };\n  };\n\n  // move the rule to another namespace / groupname\n  const moveGrafanaRule = async (\n    namespace: string,\n    group: { name: string; interval: string },\n    existingRule: RuleWithLocation,\n    newRule: PostableRuleGrafanaRuleDTO\n  ): Promise<RuleIdentifier> => {\n    // make sure our updated alert has the same UID as before\n    // that way the rule is automatically moved to the new namespace / group name\n    copyGrafanaUID(existingRule, newRule);\n\n    // add the new rule to the requested namespace and group\n    const identifier = await addRuleToNamespaceAndGroup(namespace, group, newRule);\n\n    return identifier;\n  };\n\n  const updateGrafanaRule = async (\n    existingRule: RuleWithLocation,\n    newRule: PostableRuleGrafanaRuleDTO,\n    interval: string\n  ): Promise<RuleIdentifier> => {\n    // make sure our updated alert has the same UID as before\n    copyGrafanaUID(existingRule, newRule);\n\n    // create the new array of rules we want to send to the group. Keep the order of alerts in the group.\n    const newRules = existingRule.group.rules.map((rule) => {\n      if (!isGrafanaRulerRule(rule)) {\n        return rule;\n      }\n      if (rule.grafana_alert.uid === existingRule.rule.grafana_alert.uid) {\n        return newRule;\n      }\n      return rule;\n    });\n\n    await setRulerRuleGroup(rulerConfig, existingRule.namespace, {\n      name: existingRule.group.name,\n      interval: interval,\n      rules: newRules,\n    });\n\n    return { uid: existingRule.rule.grafana_alert.uid, ruleSourceName: GRAFANA_RULES_SOURCE_NAME };\n  };\n\n  // Would be nice to somehow align checking of ruler type between different methods\n  // Maybe each datasource should have its own ruler client implementation\n  return {\n    findEditableRule,\n    deleteRule,\n    saveLotexRule,\n    saveGrafanaRule,\n  };\n}\n\n//copy the Grafana rule UID from the old rule to the new rule\nfunction copyGrafanaUID(\n  oldRule: RuleWithLocation,\n  newRule: PostableRuleGrafanaRuleDTO\n): asserts oldRule is RuleWithLocation<RulerGrafanaRuleDTO> {\n  // type guard to make sure we're working with a Grafana managed rule\n  if (!isGrafanaRulerRule(oldRule.rule)) {\n    throw new Error('The rule is not a Grafana managed rule');\n  }\n\n  const uid = oldRule.rule.grafana_alert.uid;\n  newRule.grafana_alert.uid = uid;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}