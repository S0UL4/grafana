{"ast":null,"code":"import { eachRight, map, remove } from 'lodash';\nimport { mapSegmentsToSelectables, mapStringsToSelectables } from '../components/helpers';\nimport { TAG_PREFIX, GRAPHITE_TAG_OPERATORS, handleMetricsAutoCompleteError, handleTagsAutoCompleteError } from './helpers';\n\n/**\n * All auto-complete lists are updated while typing. To avoid performance issues we do not render more\n * than MAX_SUGGESTIONS limits in a single dropdown.\n *\n * MAX_SUGGESTIONS is per metrics and tags separately. On the very first dropdown where metrics and tags are\n * combined together meaning it may end up with max of 2 * MAX_SUGGESTIONS items in total.\n */\nconst MAX_SUGGESTIONS = 5000;\n/**\n * Providers are hooks for views to provide temporal data for autocomplete. They don't modify the state.\n */\n\n/**\n * Return list of available options for a segment with given index\n *\n * It may be:\n * - mixed list of metrics and tags (only when nothing was selected)\n * - list of metric names (if a metric name was selected for this segment)\n */\n\nasync function getAltSegments(state, index, prefix) {\n  let query = prefix.length > 0 ? '*' + prefix + '*' : '*';\n\n  if (index > 0) {\n    query = state.queryModel.getSegmentPathUpTo(index) + '.' + query;\n  }\n\n  const options = {\n    range: state.range,\n    requestId: 'get-alt-segments'\n  };\n\n  try {\n    const segments = await state.datasource.metricFindQuery(query, options);\n    const altSegments = map(segments, segment => {\n      return {\n        value: segment.text,\n        expandable: segment.expandable\n      };\n    });\n\n    if (index > 0 && altSegments.length === 0) {\n      return altSegments;\n    } // add query references\n\n\n    if (index === 0) {\n      eachRight(state.queries, target => {\n        if (target.refId === state.queryModel.target.refId) {\n          return;\n        }\n\n        altSegments.unshift({\n          type: 'series-ref',\n          value: '#' + target.refId,\n          expandable: false\n        });\n      });\n    } // add template variables\n\n\n    eachRight(state.templateSrv.getVariables(), variable => {\n      altSegments.unshift({\n        type: 'template',\n        value: '$' + variable.name,\n        expandable: true\n      });\n    }); // add wildcard option and limit number of suggestions (API doesn't support limiting\n    // hence we are doing it here)\n\n    altSegments.unshift({\n      value: '*',\n      expandable: true\n    });\n    altSegments.splice(MAX_SUGGESTIONS);\n\n    if (state.supportsTags && index === 0) {\n      removeTaggedEntry(altSegments);\n      return await addAltTagSegments(state, prefix, altSegments);\n    } else {\n      return altSegments;\n    }\n  } catch (err) {\n    if (err instanceof Error) {\n      handleMetricsAutoCompleteError(state, err);\n    }\n  }\n\n  return [];\n}\n/**\n * Get the list of segments with tags and metrics. Suggestions are reduced in getAltSegments and addAltTagSegments so in case\n * we hit MAX_SUGGESTIONS limit there are always some tags and metrics shown.\n */\n\n\nexport async function getAltSegmentsSelectables(state, index, prefix) {\n  return mapSegmentsToSelectables(await getAltSegments(state, index, prefix));\n}\nexport function getTagOperatorsSelectables() {\n  return mapStringsToSelectables(GRAPHITE_TAG_OPERATORS);\n}\n/**\n * Returns tags as dropdown options\n */\n\nasync function getTags(state, index, tagPrefix) {\n  try {\n    const tagExpressions = state.queryModel.renderTagExpressions(index);\n    const values = await state.datasource.getTagsAutoComplete(tagExpressions, tagPrefix, {\n      range: state.range,\n      limit: MAX_SUGGESTIONS\n    });\n    const altTags = map(values, 'text');\n    altTags.splice(0, 0, state.removeTagValue);\n    return altTags;\n  } catch (err) {\n    if (err instanceof Error) {\n      handleTagsAutoCompleteError(state, err);\n    }\n  }\n\n  return [];\n}\n\nexport async function getTagsSelectables(state, index, tagPrefix) {\n  return mapStringsToSelectables(await getTags(state, index, tagPrefix));\n}\n/**\n * List of tags when a tag is added. getTags is used for editing.\n * When adding - segment is used. When editing - dropdown is used.\n */\n\nasync function getTagsAsSegments(state, tagPrefix) {\n  let tagsAsSegments;\n\n  try {\n    const tagExpressions = state.queryModel.renderTagExpressions();\n    const values = await state.datasource.getTagsAutoComplete(tagExpressions, tagPrefix, {\n      range: state.range,\n      limit: MAX_SUGGESTIONS\n    });\n    tagsAsSegments = map(values, val => {\n      return {\n        value: val.text,\n        type: 'tag',\n        expandable: false\n      };\n    });\n  } catch (err) {\n    tagsAsSegments = [];\n\n    if (err instanceof Error) {\n      handleTagsAutoCompleteError(state, err);\n    }\n  }\n\n  return tagsAsSegments;\n}\n/**\n * Get list of tags, used when adding additional tags (first tag is selected from a joined list of metrics and tags)\n */\n\n\nexport async function getTagsAsSegmentsSelectables(state, tagPrefix) {\n  return mapSegmentsToSelectables(await getTagsAsSegments(state, tagPrefix));\n}\n\nasync function getTagValues(state, tag, index, valuePrefix) {\n  const tagExpressions = state.queryModel.renderTagExpressions(index);\n  const tagKey = tag.key;\n  const values = await state.datasource.getTagValuesAutoComplete(tagExpressions, tagKey, valuePrefix, {\n    limit: MAX_SUGGESTIONS\n  });\n  const altValues = map(values, 'text'); // Add template variables as additional values\n\n  eachRight(state.templateSrv.getVariables(), variable => {\n    altValues.push('${' + variable.name + ':regex}');\n  });\n  return altValues;\n}\n\nexport async function getTagValuesSelectables(state, tag, index, valuePrefix) {\n  return mapStringsToSelectables(await getTagValues(state, tag, index, valuePrefix));\n}\n/**\n * Add segments with tags prefixed with \"tag: \" to include them in the same list as metrics\n */\n\nasync function addAltTagSegments(state, prefix, altSegments) {\n  let tagSegments = await getTagsAsSegments(state, prefix);\n  tagSegments = map(tagSegments, segment => {\n    segment.value = TAG_PREFIX + segment.value;\n    return segment;\n  });\n  return altSegments.concat(...tagSegments);\n}\n\nfunction removeTaggedEntry(altSegments) {\n  remove(altSegments, s => s.value === '_tagged');\n}","map":{"version":3,"names":["eachRight","map","remove","mapSegmentsToSelectables","mapStringsToSelectables","TAG_PREFIX","GRAPHITE_TAG_OPERATORS","handleMetricsAutoCompleteError","handleTagsAutoCompleteError","MAX_SUGGESTIONS","getAltSegments","state","index","prefix","query","length","queryModel","getSegmentPathUpTo","options","range","requestId","segments","datasource","metricFindQuery","altSegments","segment","value","text","expandable","queries","target","refId","unshift","type","templateSrv","getVariables","variable","name","splice","supportsTags","removeTaggedEntry","addAltTagSegments","err","Error","getAltSegmentsSelectables","getTagOperatorsSelectables","getTags","tagPrefix","tagExpressions","renderTagExpressions","values","getTagsAutoComplete","limit","altTags","removeTagValue","getTagsSelectables","getTagsAsSegments","tagsAsSegments","val","getTagsAsSegmentsSelectables","getTagValues","tag","valuePrefix","tagKey","key","getTagValuesAutoComplete","altValues","push","getTagValuesSelectables","tagSegments","concat","s"],"sources":["/home/soula/grafana/public/app/plugins/datasource/graphite/state/providers.ts"],"sourcesContent":["import { eachRight, map, remove } from 'lodash';\n\nimport { SelectableValue } from '@grafana/data';\n\nimport { mapSegmentsToSelectables, mapStringsToSelectables } from '../components/helpers';\nimport { GraphiteSegment, GraphiteTag, GraphiteTagOperator } from '../types';\n\nimport {\n  TAG_PREFIX,\n  GRAPHITE_TAG_OPERATORS,\n  handleMetricsAutoCompleteError,\n  handleTagsAutoCompleteError,\n} from './helpers';\nimport { GraphiteQueryEditorState } from './store';\n\n/**\n * All auto-complete lists are updated while typing. To avoid performance issues we do not render more\n * than MAX_SUGGESTIONS limits in a single dropdown.\n *\n * MAX_SUGGESTIONS is per metrics and tags separately. On the very first dropdown where metrics and tags are\n * combined together meaning it may end up with max of 2 * MAX_SUGGESTIONS items in total.\n */\nconst MAX_SUGGESTIONS = 5000;\n\n/**\n * Providers are hooks for views to provide temporal data for autocomplete. They don't modify the state.\n */\n\n/**\n * Return list of available options for a segment with given index\n *\n * It may be:\n * - mixed list of metrics and tags (only when nothing was selected)\n * - list of metric names (if a metric name was selected for this segment)\n */\nasync function getAltSegments(\n  state: GraphiteQueryEditorState,\n  index: number,\n  prefix: string\n): Promise<GraphiteSegment[]> {\n  let query = prefix.length > 0 ? '*' + prefix + '*' : '*';\n  if (index > 0) {\n    query = state.queryModel.getSegmentPathUpTo(index) + '.' + query;\n  }\n  const options = {\n    range: state.range,\n    requestId: 'get-alt-segments',\n  };\n\n  try {\n    const segments = await state.datasource.metricFindQuery(query, options);\n    const altSegments: GraphiteSegment[] = map(segments, (segment) => {\n      return {\n        value: segment.text,\n        expandable: segment.expandable,\n      };\n    });\n\n    if (index > 0 && altSegments.length === 0) {\n      return altSegments;\n    }\n\n    // add query references\n    if (index === 0) {\n      eachRight(state.queries, (target) => {\n        if (target.refId === state.queryModel.target.refId) {\n          return;\n        }\n\n        altSegments.unshift({\n          type: 'series-ref',\n          value: '#' + target.refId,\n          expandable: false,\n        });\n      });\n    }\n\n    // add template variables\n    eachRight(state.templateSrv.getVariables(), (variable) => {\n      altSegments.unshift({\n        type: 'template',\n        value: '$' + variable.name,\n        expandable: true,\n      });\n    });\n\n    // add wildcard option and limit number of suggestions (API doesn't support limiting\n    // hence we are doing it here)\n    altSegments.unshift({ value: '*', expandable: true });\n    altSegments.splice(MAX_SUGGESTIONS);\n\n    if (state.supportsTags && index === 0) {\n      removeTaggedEntry(altSegments);\n      return await addAltTagSegments(state, prefix, altSegments);\n    } else {\n      return altSegments;\n    }\n  } catch (err) {\n    if (err instanceof Error) {\n      handleMetricsAutoCompleteError(state, err);\n    }\n  }\n\n  return [];\n}\n\n/**\n * Get the list of segments with tags and metrics. Suggestions are reduced in getAltSegments and addAltTagSegments so in case\n * we hit MAX_SUGGESTIONS limit there are always some tags and metrics shown.\n */\nexport async function getAltSegmentsSelectables(\n  state: GraphiteQueryEditorState,\n  index: number,\n  prefix: string\n): Promise<Array<SelectableValue<GraphiteSegment>>> {\n  return mapSegmentsToSelectables(await getAltSegments(state, index, prefix));\n}\n\nexport function getTagOperatorsSelectables(): Array<SelectableValue<GraphiteTagOperator>> {\n  return mapStringsToSelectables(GRAPHITE_TAG_OPERATORS);\n}\n\n/**\n * Returns tags as dropdown options\n */\nasync function getTags(state: GraphiteQueryEditorState, index: number, tagPrefix: string): Promise<string[]> {\n  try {\n    const tagExpressions = state.queryModel.renderTagExpressions(index);\n    const values = await state.datasource.getTagsAutoComplete(tagExpressions, tagPrefix, {\n      range: state.range,\n      limit: MAX_SUGGESTIONS,\n    });\n\n    const altTags = map(values, 'text');\n    altTags.splice(0, 0, state.removeTagValue);\n    return altTags;\n  } catch (err) {\n    if (err instanceof Error) {\n      handleTagsAutoCompleteError(state, err);\n    }\n  }\n\n  return [];\n}\n\nexport async function getTagsSelectables(\n  state: GraphiteQueryEditorState,\n  index: number,\n  tagPrefix: string\n): Promise<Array<SelectableValue<string>>> {\n  return mapStringsToSelectables(await getTags(state, index, tagPrefix));\n}\n\n/**\n * List of tags when a tag is added. getTags is used for editing.\n * When adding - segment is used. When editing - dropdown is used.\n */\nasync function getTagsAsSegments(state: GraphiteQueryEditorState, tagPrefix: string): Promise<GraphiteSegment[]> {\n  let tagsAsSegments: GraphiteSegment[];\n  try {\n    const tagExpressions = state.queryModel.renderTagExpressions();\n    const values = await state.datasource.getTagsAutoComplete(tagExpressions, tagPrefix, {\n      range: state.range,\n      limit: MAX_SUGGESTIONS,\n    });\n    tagsAsSegments = map(values, (val) => {\n      return {\n        value: val.text,\n        type: 'tag',\n        expandable: false,\n      };\n    });\n  } catch (err) {\n    tagsAsSegments = [];\n    if (err instanceof Error) {\n      handleTagsAutoCompleteError(state, err);\n    }\n  }\n\n  return tagsAsSegments;\n}\n\n/**\n * Get list of tags, used when adding additional tags (first tag is selected from a joined list of metrics and tags)\n */\nexport async function getTagsAsSegmentsSelectables(\n  state: GraphiteQueryEditorState,\n  tagPrefix: string\n): Promise<Array<SelectableValue<GraphiteSegment>>> {\n  return mapSegmentsToSelectables(await getTagsAsSegments(state, tagPrefix));\n}\n\nasync function getTagValues(\n  state: GraphiteQueryEditorState,\n  tag: GraphiteTag,\n  index: number,\n  valuePrefix: string\n): Promise<string[]> {\n  const tagExpressions = state.queryModel.renderTagExpressions(index);\n  const tagKey = tag.key;\n  const values = await state.datasource.getTagValuesAutoComplete(tagExpressions, tagKey, valuePrefix, {\n    limit: MAX_SUGGESTIONS,\n  });\n  const altValues = map(values, 'text');\n  // Add template variables as additional values\n  eachRight(state.templateSrv.getVariables(), (variable) => {\n    altValues.push('${' + variable.name + ':regex}');\n  });\n\n  return altValues;\n}\n\nexport async function getTagValuesSelectables(\n  state: GraphiteQueryEditorState,\n  tag: GraphiteTag,\n  index: number,\n  valuePrefix: string\n): Promise<Array<SelectableValue<string>>> {\n  return mapStringsToSelectables(await getTagValues(state, tag, index, valuePrefix));\n}\n\n/**\n * Add segments with tags prefixed with \"tag: \" to include them in the same list as metrics\n */\nasync function addAltTagSegments(\n  state: GraphiteQueryEditorState,\n  prefix: string,\n  altSegments: GraphiteSegment[]\n): Promise<GraphiteSegment[]> {\n  let tagSegments = await getTagsAsSegments(state, prefix);\n\n  tagSegments = map(tagSegments, (segment) => {\n    segment.value = TAG_PREFIX + segment.value;\n    return segment;\n  });\n\n  return altSegments.concat(...tagSegments);\n}\n\nfunction removeTaggedEntry(altSegments: GraphiteSegment[]) {\n  remove(altSegments, (s) => s.value === '_tagged');\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}