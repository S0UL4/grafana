{"ast":null,"code":"import { parse } from 'search-query-parser';\nimport { getDashboardSrv } from '../dashboard/services/DashboardSrv';\nimport { NO_ID_SECTIONS, SECTION_STORAGE_KEY } from './constants';\n\n/**\n * Check if folder has id. Only Recent and Starred folders are the ones without\n * ids so far, as they are created manually after results are fetched from API.\n * @param str\n */\nexport const hasId = str => {\n  return !NO_ID_SECTIONS.includes(str);\n};\n/**\n * Return ids for folders concatenated with their items ids, if section is expanded.\n * For items the id format is '{folderId}-{itemId}' to allow mapping them to their folders\n * @param sections\n */\n\nexport const getFlattenedSections = sections => {\n  return sections.flatMap(section => {\n    const id = hasId(section.title) ? String(section.id) : section.title;\n\n    if (section.expanded && section.items.length) {\n      return [id, ...section.items.map(item => `${id}-${item.id}`)];\n    }\n\n    return id;\n  });\n};\n/**\n * Get all items for currently expanded sections\n * @param sections\n */\n\nexport const getVisibleItems = sections => {\n  return sections.flatMap(section => {\n    if (section.expanded) {\n      return section.items;\n    }\n\n    return [];\n  });\n};\n/**\n * Since Recent and Starred folders don't have id, title field is used as id\n * @param title - title field of the section\n */\n\nexport const getLookupField = title => {\n  return hasId(title) ? 'id' : 'title';\n};\n/**\n * Go through all the folders and items in expanded folders and toggle their selected\n * prop according to currently selected index. Used for item highlighting when navigating\n * the search results list using keyboard arrows\n * @param sections\n * @param selectedId\n */\n\nexport const markSelected = (sections, selectedId) => {\n  return sections.map(result => {\n    const lookupField = getLookupField(selectedId);\n    result = Object.assign({}, result, {\n      selected: String(result[lookupField]) === selectedId\n    });\n\n    if (result.expanded && result.items.length) {\n      return Object.assign({}, result, {\n        items: result.items.map(item => {\n          const [sectionId, itemId] = selectedId.split('-');\n          const lookup = getLookupField(sectionId);\n          return Object.assign({}, item, {\n            selected: String(item.id) === itemId && String(result[lookup]) === sectionId\n          });\n        })\n      });\n    }\n\n    return result;\n  });\n};\n/**\n * Find items with property 'selected' set true in a list of folders and their items.\n * Does recursive search in the items list.\n * @param sections\n */\n\nexport const findSelected = sections => {\n  let found = null;\n\n  for (const section of sections) {\n    if (section.expanded && section.items.length) {\n      found = findSelected(section.items);\n    }\n\n    if (section.selected) {\n      found = section;\n    }\n\n    if (found) {\n      return found;\n    }\n  }\n\n  return null;\n};\nexport const parseQuery = query => {\n  const parsedQuery = parse(query, {\n    keywords: ['folder']\n  });\n\n  if (typeof parsedQuery === 'string') {\n    return {\n      text: parsedQuery\n    };\n  }\n\n  return parsedQuery;\n};\n/**\n * Merge multiple reducers into one, keeping the state structure flat (no nested\n * separate state for each reducer). If there are multiple state slices with the same\n * key, the latest reducer's state is applied.\n * Compared to Redux's combineReducers this allows multiple reducers to operate\n * on the same state or different slices of the same state. Useful when multiple\n * components have the same structure but different or extra logic when modifying it.\n * If reducers have the same action types, the action types from the rightmost reducer\n * take precedence\n * @param reducers\n */\n\nexport const mergeReducers = reducers => (prevState, action) => {\n  return reducers.reduce((nextState, reducer) => Object.assign({}, nextState, reducer(nextState, action)), prevState);\n};\n/**\n * Collect all the checked dashboards\n * @param sections\n */\n\nexport const getCheckedDashboards = sections => {\n  if (!sections.length) {\n    return [];\n  }\n\n  return sections.reduce((uids, section) => {\n    return section.items ? [...uids, ...section.items.filter(item => item.checked)] : uids;\n  }, []);\n};\n/**\n * Collect uids of all the checked dashboards\n * @param sections\n */\n\nexport const getCheckedDashboardsUids = sections => {\n  if (!sections.length) {\n    return [];\n  }\n\n  return getCheckedDashboards(sections).map(item => item.uid);\n};\n/**\n * Collect uids of all checked folders and dashboards. Used for delete operation, among others\n * @param sections\n */\n\nexport const getCheckedUids = sections => {\n  const emptyResults = {\n    folders: [],\n    dashboards: []\n  };\n\n  if (!sections.length) {\n    return emptyResults;\n  }\n\n  return sections.reduce((result, section) => {\n    if ((section === null || section === void 0 ? void 0 : section.id) !== 0 && section.checked && section.uid) {\n      return Object.assign({}, result, {\n        folders: [...result.folders, section.uid]\n      });\n    } else {\n      return Object.assign({}, result, {\n        dashboards: getCheckedDashboardsUids(sections)\n      });\n    }\n  }, emptyResults);\n};\n/**\n * When search is done within a dashboard folder, add folder id to the search query\n * to narrow down the results to the folder\n * @param query\n * @param queryParsing\n */\n\nexport const getParsedQuery = (query, queryParsing = false) => {\n  var _query$sort;\n\n  const parsedQuery = Object.assign({}, query, {\n    sort: (_query$sort = query.sort) === null || _query$sort === void 0 ? void 0 : _query$sort.value\n  });\n\n  if (!queryParsing) {\n    return parsedQuery;\n  }\n\n  let folderIds = [];\n\n  if (parseQuery(query.query).folder === 'current') {\n    try {\n      const dash = getDashboardSrv().getCurrent();\n\n      if (dash !== null && dash !== void 0 && dash.meta.folderId) {\n        folderIds = [dash === null || dash === void 0 ? void 0 : dash.meta.folderId];\n      }\n    } catch (e) {\n      console.error(e);\n    }\n  }\n\n  return Object.assign({}, parsedQuery, {\n    query: parseQuery(query.query).text,\n    folderIds\n  });\n};\n/**\n * Check if search query has filters enabled. Excludes folderId\n * @param query\n */\n\nexport const hasFilters = query => {\n  var _query$tag;\n\n  if (!query) {\n    return false;\n  }\n\n  return Boolean(query.query || ((_query$tag = query.tag) === null || _query$tag === void 0 ? void 0 : _query$tag.length) > 0 || query.starred || query.sort);\n};\n/**\n * Get section icon depending on expanded state. Currently works for folder icons only\n * @param section\n */\n\nexport const getSectionIcon = section => {\n  if (!hasId(section.title)) {\n    return section.icon;\n  }\n\n  return section.expanded ? 'folder-open' : 'folder';\n};\n/**\n * Get storage key for a dashboard folder by its title\n * @param title\n */\n\nexport const getSectionStorageKey = (title = 'General') => {\n  return `${SECTION_STORAGE_KEY}.${title.toLowerCase()}`;\n};\n/**\n * Remove undefined keys from url params object and format non-primitive values\n * @param params\n * @param folder\n */\n\nexport const parseRouteParams = params => {\n  const cleanedParams = Object.entries(params).reduce((obj, [key, val]) => {\n    if (!val) {\n      return obj;\n    } else if (key === 'tag' && !Array.isArray(val)) {\n      return Object.assign({}, obj, {\n        tag: [val]\n      });\n    } else if (key === 'sort') {\n      return Object.assign({}, obj, {\n        sort: {\n          value: val\n        }\n      });\n    }\n\n    return Object.assign({}, obj, {\n      [key]: val\n    });\n  }, {});\n\n  if (params.folder) {\n    var _cleanedParams$query;\n\n    const folderStr = `folder:${params.folder}`;\n    return Object.assign({}, cleanedParams, {\n      query: `${folderStr} ${((_cleanedParams$query = cleanedParams.query) !== null && _cleanedParams$query !== void 0 ? _cleanedParams$query : '').replace(folderStr, '')}`\n    });\n  }\n\n  return Object.assign({}, cleanedParams);\n};","map":{"version":3,"names":["parse","getDashboardSrv","NO_ID_SECTIONS","SECTION_STORAGE_KEY","hasId","str","includes","getFlattenedSections","sections","flatMap","section","id","title","String","expanded","items","length","map","item","getVisibleItems","getLookupField","markSelected","selectedId","result","lookupField","selected","sectionId","itemId","split","lookup","findSelected","found","parseQuery","query","parsedQuery","keywords","text","mergeReducers","reducers","prevState","action","reduce","nextState","reducer","getCheckedDashboards","uids","filter","checked","getCheckedDashboardsUids","uid","getCheckedUids","emptyResults","folders","dashboards","getParsedQuery","queryParsing","sort","value","folderIds","folder","dash","getCurrent","meta","folderId","e","console","error","hasFilters","Boolean","tag","starred","getSectionIcon","icon","getSectionStorageKey","toLowerCase","parseRouteParams","params","cleanedParams","Object","entries","obj","key","val","Array","isArray","folderStr","replace"],"sources":["/home/soula/grafana/public/app/features/search/utils.ts"],"sourcesContent":["import { parse, SearchParserResult } from 'search-query-parser';\n\nimport { UrlQueryMap } from '@grafana/data';\nimport { IconName } from '@grafana/ui';\n\nimport { getDashboardSrv } from '../dashboard/services/DashboardSrv';\n\nimport { NO_ID_SECTIONS, SECTION_STORAGE_KEY } from './constants';\nimport { DashboardQuery, DashboardSection, DashboardSectionItem, SearchAction, UidsToDelete } from './types';\n\n/**\n * Check if folder has id. Only Recent and Starred folders are the ones without\n * ids so far, as they are created manually after results are fetched from API.\n * @param str\n */\nexport const hasId = (str: string) => {\n  return !NO_ID_SECTIONS.includes(str);\n};\n\n/**\n * Return ids for folders concatenated with their items ids, if section is expanded.\n * For items the id format is '{folderId}-{itemId}' to allow mapping them to their folders\n * @param sections\n */\nexport const getFlattenedSections = (sections: DashboardSection[]): string[] => {\n  return sections.flatMap((section) => {\n    const id = hasId(section.title) ? String(section.id) : section.title;\n\n    if (section.expanded && section.items.length) {\n      return [id, ...section.items.map((item) => `${id}-${item.id}`)];\n    }\n    return id;\n  });\n};\n\n/**\n * Get all items for currently expanded sections\n * @param sections\n */\nexport const getVisibleItems = (sections: DashboardSection[]) => {\n  return sections.flatMap((section) => {\n    if (section.expanded) {\n      return section.items;\n    }\n    return [];\n  });\n};\n/**\n * Since Recent and Starred folders don't have id, title field is used as id\n * @param title - title field of the section\n */\nexport const getLookupField = (title: string) => {\n  return hasId(title) ? 'id' : 'title';\n};\n\n/**\n * Go through all the folders and items in expanded folders and toggle their selected\n * prop according to currently selected index. Used for item highlighting when navigating\n * the search results list using keyboard arrows\n * @param sections\n * @param selectedId\n */\nexport const markSelected = (sections: DashboardSection[], selectedId: string) => {\n  return sections.map((result: DashboardSection) => {\n    const lookupField = getLookupField(selectedId);\n    result = { ...result, selected: String(result[lookupField]) === selectedId };\n\n    if (result.expanded && result.items.length) {\n      return {\n        ...result,\n        items: result.items.map((item) => {\n          const [sectionId, itemId] = selectedId.split('-');\n          const lookup = getLookupField(sectionId);\n          return { ...item, selected: String(item.id) === itemId && String(result[lookup]) === sectionId };\n        }),\n      };\n    }\n    return result;\n  });\n};\n\n/**\n * Find items with property 'selected' set true in a list of folders and their items.\n * Does recursive search in the items list.\n * @param sections\n */\nexport const findSelected = (sections: any): DashboardSection | DashboardSectionItem | null => {\n  let found = null;\n  for (const section of sections) {\n    if (section.expanded && section.items.length) {\n      found = findSelected(section.items);\n    }\n    if (section.selected) {\n      found = section;\n    }\n    if (found) {\n      return found;\n    }\n  }\n\n  return null;\n};\n\nexport const parseQuery = (query: string) => {\n  const parsedQuery = parse(query, {\n    keywords: ['folder'],\n  });\n\n  if (typeof parsedQuery === 'string') {\n    return {\n      text: parsedQuery,\n    } as SearchParserResult;\n  }\n\n  return parsedQuery;\n};\n\n/**\n * Merge multiple reducers into one, keeping the state structure flat (no nested\n * separate state for each reducer). If there are multiple state slices with the same\n * key, the latest reducer's state is applied.\n * Compared to Redux's combineReducers this allows multiple reducers to operate\n * on the same state or different slices of the same state. Useful when multiple\n * components have the same structure but different or extra logic when modifying it.\n * If reducers have the same action types, the action types from the rightmost reducer\n * take precedence\n * @param reducers\n */\nexport const mergeReducers = (reducers: any[]) => (prevState: any, action: SearchAction) => {\n  return reducers.reduce((nextState, reducer) => ({ ...nextState, ...reducer(nextState, action) }), prevState);\n};\n\n/**\n * Collect all the checked dashboards\n * @param sections\n */\nexport const getCheckedDashboards = (sections: DashboardSection[]): DashboardSectionItem[] => {\n  if (!sections.length) {\n    return [];\n  }\n\n  return sections.reduce((uids, section) => {\n    return section.items ? [...uids, ...section.items.filter((item) => item.checked)] : uids;\n  }, [] as DashboardSectionItem[]);\n};\n\n/**\n * Collect uids of all the checked dashboards\n * @param sections\n */\nexport const getCheckedDashboardsUids = (sections: DashboardSection[]) => {\n  if (!sections.length) {\n    return [];\n  }\n\n  return getCheckedDashboards(sections).map((item) => item.uid);\n};\n\n/**\n * Collect uids of all checked folders and dashboards. Used for delete operation, among others\n * @param sections\n */\nexport const getCheckedUids = (sections: DashboardSection[]): UidsToDelete => {\n  const emptyResults: UidsToDelete = { folders: [], dashboards: [] };\n\n  if (!sections.length) {\n    return emptyResults;\n  }\n\n  return sections.reduce((result, section) => {\n    if (section?.id !== 0 && section.checked && section.uid) {\n      return { ...result, folders: [...result.folders, section.uid] } as UidsToDelete;\n    } else {\n      return { ...result, dashboards: getCheckedDashboardsUids(sections) } as UidsToDelete;\n    }\n  }, emptyResults);\n};\n\n/**\n * When search is done within a dashboard folder, add folder id to the search query\n * to narrow down the results to the folder\n * @param query\n * @param queryParsing\n */\nexport const getParsedQuery = (query: DashboardQuery, queryParsing = false) => {\n  const parsedQuery = { ...query, sort: query.sort?.value };\n  if (!queryParsing) {\n    return parsedQuery;\n  }\n\n  let folderIds: number[] = [];\n\n  if (parseQuery(query.query).folder === 'current') {\n    try {\n      const dash = getDashboardSrv().getCurrent();\n      if (dash?.meta.folderId) {\n        folderIds = [dash?.meta.folderId];\n      }\n    } catch (e) {\n      console.error(e);\n    }\n  }\n  return { ...parsedQuery, query: parseQuery(query.query).text as string, folderIds };\n};\n\n/**\n * Check if search query has filters enabled. Excludes folderId\n * @param query\n */\nexport const hasFilters = (query: DashboardQuery) => {\n  if (!query) {\n    return false;\n  }\n  return Boolean(query.query || query.tag?.length > 0 || query.starred || query.sort);\n};\n\n/**\n * Get section icon depending on expanded state. Currently works for folder icons only\n * @param section\n */\nexport const getSectionIcon = (section: DashboardSection): IconName => {\n  if (!hasId(section.title)) {\n    return section.icon as IconName;\n  }\n\n  return section.expanded ? 'folder-open' : 'folder';\n};\n\n/**\n * Get storage key for a dashboard folder by its title\n * @param title\n */\nexport const getSectionStorageKey = (title = 'General') => {\n  return `${SECTION_STORAGE_KEY}.${title.toLowerCase()}`;\n};\n\n/**\n * Remove undefined keys from url params object and format non-primitive values\n * @param params\n * @param folder\n */\nexport const parseRouteParams = (params: UrlQueryMap) => {\n  const cleanedParams = Object.entries(params).reduce((obj, [key, val]) => {\n    if (!val) {\n      return obj;\n    } else if (key === 'tag' && !Array.isArray(val)) {\n      return { ...obj, tag: [val] as string[] };\n    } else if (key === 'sort') {\n      return { ...obj, sort: { value: val } };\n    }\n    return { ...obj, [key]: val };\n  }, {} as Partial<DashboardQuery>);\n\n  if (params.folder) {\n    const folderStr = `folder:${params.folder}`;\n    return {\n      ...cleanedParams,\n      query: `${folderStr} ${(cleanedParams.query ?? '').replace(folderStr, '')}`,\n    };\n  }\n\n  return { ...cleanedParams };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}