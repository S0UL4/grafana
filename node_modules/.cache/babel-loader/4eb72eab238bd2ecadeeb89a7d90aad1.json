{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { Lexer } from './lexer';\nimport { isGraphiteParserError } from './utils';\nexport class Parser {\n  constructor(expression) {\n    _defineProperty(this, \"expression\", void 0);\n\n    _defineProperty(this, \"lexer\", void 0);\n\n    _defineProperty(this, \"tokens\", void 0);\n\n    _defineProperty(this, \"index\", void 0);\n\n    this.expression = expression;\n    this.lexer = new Lexer(expression);\n    this.tokens = this.lexer.tokenize();\n    this.index = 0;\n  }\n\n  getAst() {\n    return this.start();\n  }\n\n  start() {\n    try {\n      return this.functionCall() || this.metricExpression();\n    } catch (e) {\n      if (isGraphiteParserError(e)) {\n        return {\n          type: 'error',\n          message: e.message,\n          pos: e.pos\n        };\n      }\n    }\n  }\n\n  curlyBraceSegment() {\n    if (this.match('identifier', '{') || this.match('{')) {\n      let curlySegment = '';\n\n      while (!this.match('') && !this.match('}')) {\n        curlySegment += this.consumeToken().value;\n      }\n\n      if (!this.match('}')) {\n        this.errorMark(\"Expected closing '}'\");\n      }\n\n      curlySegment += this.consumeToken().value; // if curly segment is directly followed by identifier\n      // include it in the segment\n\n      if (this.match('identifier')) {\n        curlySegment += this.consumeToken().value;\n      }\n\n      return {\n        type: 'segment',\n        value: curlySegment\n      };\n    } else {\n      return null;\n    }\n  }\n\n  metricSegment() {\n    const curly = this.curlyBraceSegment();\n\n    if (curly) {\n      return curly;\n    }\n\n    if (this.match('identifier') || this.match('number')) {\n      // hack to handle float numbers in metric segments\n      const parts = this.consumeToken().value.split('.');\n\n      if (parts.length === 2) {\n        this.tokens.splice(this.index, 0, {\n          type: '.'\n        });\n        this.tokens.splice(this.index + 1, 0, {\n          type: 'number',\n          value: parts[1]\n        });\n      }\n\n      return {\n        type: 'segment',\n        value: parts[0]\n      };\n    }\n\n    if (!this.match('templateStart')) {\n      this.errorMark('Expected metric identifier');\n    }\n\n    this.consumeToken();\n\n    if (!this.match('identifier')) {\n      this.errorMark('Expected identifier after templateStart');\n    }\n\n    const node = {\n      type: 'template',\n      value: this.consumeToken().value\n    };\n\n    if (!this.match('templateEnd')) {\n      this.errorMark('Expected templateEnd');\n    }\n\n    this.consumeToken();\n    return node;\n  }\n\n  metricExpression() {\n    if (!this.match('templateStart') && !this.match('identifier') && !this.match('number') && !this.match('{')) {\n      return null;\n    }\n\n    const node = {\n      type: 'metric',\n      segments: []\n    };\n    node.segments.push(this.metricSegment());\n\n    while (this.match('.')) {\n      this.consumeToken();\n      const segment = this.metricSegment();\n\n      if (!segment) {\n        this.errorMark('Expected metric identifier');\n      }\n\n      node.segments.push(segment);\n    }\n\n    return node;\n  }\n\n  functionCall() {\n    if (!this.match('identifier', '(')) {\n      return null;\n    }\n\n    const node = {\n      type: 'function',\n      name: this.consumeToken().value\n    }; // consume left parenthesis\n\n    this.consumeToken();\n    node.params = this.functionParameters();\n\n    if (!this.match(')')) {\n      this.errorMark('Expected closing parenthesis');\n    }\n\n    this.consumeToken();\n    return node;\n  }\n\n  boolExpression() {\n    if (!this.match('bool')) {\n      return null;\n    }\n\n    return {\n      type: 'bool',\n      value: this.consumeToken().value === 'true'\n    };\n  }\n\n  functionParameters() {\n    if (this.match(')') || this.match('')) {\n      return [];\n    }\n\n    const param = this.functionCall() || this.numericLiteral() || this.seriesRefExpression() || this.boolExpression() || this.metricExpression() || this.stringLiteral();\n\n    if (!this.match(',')) {\n      return [param];\n    }\n\n    this.consumeToken();\n    return [param].concat(this.functionParameters());\n  }\n\n  seriesRefExpression() {\n    if (!this.match('identifier')) {\n      return null;\n    }\n\n    const value = this.tokens[this.index].value;\n\n    if (!value.match(/\\#[A-Z]/)) {\n      return null;\n    }\n\n    const token = this.consumeToken();\n    return {\n      type: 'series-ref',\n      value: token.value\n    };\n  }\n\n  numericLiteral() {\n    if (!this.match('number')) {\n      return null;\n    }\n\n    return {\n      type: 'number',\n      value: parseFloat(this.consumeToken().value)\n    };\n  }\n\n  stringLiteral() {\n    if (!this.match('string')) {\n      return null;\n    }\n\n    const token = this.consumeToken();\n\n    if (token.isUnclosed) {\n      const error = {\n        message: 'Unclosed string parameter',\n        pos: token.pos\n      };\n      throw error;\n    }\n\n    return {\n      type: 'string',\n      value: token.value\n    };\n  }\n\n  errorMark(text) {\n    const currentToken = this.tokens[this.index];\n    const type = currentToken ? currentToken.type : 'end of string';\n    const error = {\n      message: text + ' instead found ' + type,\n      pos: currentToken ? currentToken.pos : this.lexer.char\n    };\n    throw error;\n  } // returns token value and incre\n\n\n  consumeToken() {\n    this.index++;\n    return this.tokens[this.index - 1];\n  }\n\n  matchToken(type, index) {\n    const token = this.tokens[this.index + index];\n    return token === undefined && type === '' || token && token.type === type;\n  }\n\n  match(token1, token2) {\n    return this.matchToken(token1, 0) && (!token2 || this.matchToken(token2, 1));\n  }\n\n}","map":{"version":3,"names":["Lexer","isGraphiteParserError","Parser","constructor","expression","lexer","tokens","tokenize","index","getAst","start","functionCall","metricExpression","e","type","message","pos","curlyBraceSegment","match","curlySegment","consumeToken","value","errorMark","metricSegment","curly","parts","split","length","splice","node","segments","push","segment","name","params","functionParameters","boolExpression","param","numericLiteral","seriesRefExpression","stringLiteral","concat","token","parseFloat","isUnclosed","error","text","currentToken","char","matchToken","undefined","token1","token2"],"sources":["/home/soula/grafana/public/app/plugins/datasource/graphite/parser.ts"],"sourcesContent":["import { Lexer } from './lexer';\nimport { GraphiteParserError } from './types';\nimport { isGraphiteParserError } from './utils';\n\nexport class Parser {\n  expression: any;\n  lexer: Lexer;\n  tokens: any;\n  index: number;\n\n  constructor(expression: any) {\n    this.expression = expression;\n    this.lexer = new Lexer(expression);\n    this.tokens = this.lexer.tokenize();\n    this.index = 0;\n  }\n\n  getAst() {\n    return this.start();\n  }\n\n  start() {\n    try {\n      return this.functionCall() || this.metricExpression();\n    } catch (e) {\n      if (isGraphiteParserError(e)) {\n        return {\n          type: 'error',\n          message: e.message,\n          pos: e.pos,\n        };\n      }\n    }\n  }\n\n  curlyBraceSegment() {\n    if (this.match('identifier', '{') || this.match('{')) {\n      let curlySegment = '';\n\n      while (!this.match('') && !this.match('}')) {\n        curlySegment += this.consumeToken().value;\n      }\n\n      if (!this.match('}')) {\n        this.errorMark(\"Expected closing '}'\");\n      }\n\n      curlySegment += this.consumeToken().value;\n\n      // if curly segment is directly followed by identifier\n      // include it in the segment\n      if (this.match('identifier')) {\n        curlySegment += this.consumeToken().value;\n      }\n\n      return {\n        type: 'segment',\n        value: curlySegment,\n      };\n    } else {\n      return null;\n    }\n  }\n\n  metricSegment() {\n    const curly = this.curlyBraceSegment();\n    if (curly) {\n      return curly;\n    }\n\n    if (this.match('identifier') || this.match('number')) {\n      // hack to handle float numbers in metric segments\n      const parts = this.consumeToken().value.split('.');\n      if (parts.length === 2) {\n        this.tokens.splice(this.index, 0, { type: '.' });\n        this.tokens.splice(this.index + 1, 0, {\n          type: 'number',\n          value: parts[1],\n        });\n      }\n\n      return {\n        type: 'segment',\n        value: parts[0],\n      };\n    }\n\n    if (!this.match('templateStart')) {\n      this.errorMark('Expected metric identifier');\n    }\n\n    this.consumeToken();\n\n    if (!this.match('identifier')) {\n      this.errorMark('Expected identifier after templateStart');\n    }\n\n    const node = {\n      type: 'template',\n      value: this.consumeToken().value,\n    };\n\n    if (!this.match('templateEnd')) {\n      this.errorMark('Expected templateEnd');\n    }\n\n    this.consumeToken();\n    return node;\n  }\n\n  metricExpression() {\n    if (!this.match('templateStart') && !this.match('identifier') && !this.match('number') && !this.match('{')) {\n      return null;\n    }\n\n    const node: any = {\n      type: 'metric',\n      segments: [],\n    };\n\n    node.segments.push(this.metricSegment());\n\n    while (this.match('.')) {\n      this.consumeToken();\n\n      const segment = this.metricSegment();\n      if (!segment) {\n        this.errorMark('Expected metric identifier');\n      }\n\n      node.segments.push(segment);\n    }\n\n    return node;\n  }\n\n  functionCall() {\n    if (!this.match('identifier', '(')) {\n      return null;\n    }\n\n    const node: any = {\n      type: 'function',\n      name: this.consumeToken().value,\n    };\n\n    // consume left parenthesis\n    this.consumeToken();\n\n    node.params = this.functionParameters();\n\n    if (!this.match(')')) {\n      this.errorMark('Expected closing parenthesis');\n    }\n\n    this.consumeToken();\n\n    return node;\n  }\n\n  boolExpression() {\n    if (!this.match('bool')) {\n      return null;\n    }\n\n    return {\n      type: 'bool',\n      value: this.consumeToken().value === 'true',\n    };\n  }\n\n  functionParameters(): any {\n    if (this.match(')') || this.match('')) {\n      return [];\n    }\n\n    const param =\n      this.functionCall() ||\n      this.numericLiteral() ||\n      this.seriesRefExpression() ||\n      this.boolExpression() ||\n      this.metricExpression() ||\n      this.stringLiteral();\n\n    if (!this.match(',')) {\n      return [param];\n    }\n\n    this.consumeToken();\n    return [param].concat(this.functionParameters());\n  }\n\n  seriesRefExpression() {\n    if (!this.match('identifier')) {\n      return null;\n    }\n\n    const value = this.tokens[this.index].value;\n    if (!value.match(/\\#[A-Z]/)) {\n      return null;\n    }\n\n    const token = this.consumeToken();\n\n    return {\n      type: 'series-ref',\n      value: token.value,\n    };\n  }\n\n  numericLiteral() {\n    if (!this.match('number')) {\n      return null;\n    }\n\n    return {\n      type: 'number',\n      value: parseFloat(this.consumeToken().value),\n    };\n  }\n\n  stringLiteral() {\n    if (!this.match('string')) {\n      return null;\n    }\n\n    const token = this.consumeToken();\n    if (token.isUnclosed) {\n      const error: GraphiteParserError = {\n        message: 'Unclosed string parameter',\n        pos: token.pos,\n      };\n      throw error;\n    }\n\n    return {\n      type: 'string',\n      value: token.value,\n    };\n  }\n\n  errorMark(text: string) {\n    const currentToken = this.tokens[this.index];\n    const type = currentToken ? currentToken.type : 'end of string';\n    const error: GraphiteParserError = {\n      message: text + ' instead found ' + type,\n      pos: currentToken ? currentToken.pos : this.lexer.char,\n    };\n    throw error;\n  }\n\n  // returns token value and incre\n  consumeToken() {\n    this.index++;\n    return this.tokens[this.index - 1];\n  }\n\n  matchToken(type: any, index: number) {\n    const token = this.tokens[this.index + index];\n    return (token === undefined && type === '') || (token && token.type === type);\n  }\n\n  match(token1: any, token2?: any) {\n    return this.matchToken(token1, 0) && (!token2 || this.matchToken(token2, 1));\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}