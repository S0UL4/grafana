{"ast":null,"code":"import { map } from 'rxjs/operators';\nimport { getFieldDisplayName } from '../../field/fieldState';\nimport { stringToJsRegex } from '../../text/string';\nimport { DataTransformerID } from './ids';\n/**\n * Options for renameByRegexTransformer\n *\n * @public\n */\n\n/**\n * Replaces the displayName of a field by applying a regular expression\n * to match the name and a pattern for the replacement.\n *\n * @public\n */\nexport const renameByRegexTransformer = {\n  id: DataTransformerID.renameByRegex,\n  name: 'Rename fields by regex',\n  description: 'Rename fields based on regular expression by users.',\n  defaultOptions: {\n    regex: '(.*)',\n    renamePattern: '$1'\n  },\n\n  /**\n   * Return a modified copy of the series.  If the transform is not or should not\n   * be applied, just return the input series\n   */\n  operator: options => source => source.pipe(map(data => {\n    if (!Array.isArray(data) || data.length === 0) {\n      return data;\n    }\n\n    return data.map(renameFieldsByRegex(options));\n  }))\n};\n\nconst renameFieldsByRegex = options => frame => {\n  const regex = stringToJsRegex(options.regex);\n  const fields = frame.fields.map(field => {\n    const displayName = getFieldDisplayName(field, frame);\n\n    if (!regex.test(displayName)) {\n      return field;\n    }\n\n    const newDisplayName = displayName.replace(regex, options.renamePattern);\n    return Object.assign({}, field, {\n      config: Object.assign({}, field.config, {\n        displayName: newDisplayName\n      }),\n      state: Object.assign({}, field.state, {\n        displayName: newDisplayName\n      })\n    });\n  });\n  return Object.assign({}, frame, {\n    fields\n  });\n};","map":{"version":3,"names":["map","getFieldDisplayName","stringToJsRegex","DataTransformerID","renameByRegexTransformer","id","renameByRegex","name","description","defaultOptions","regex","renamePattern","operator","options","source","pipe","data","Array","isArray","length","renameFieldsByRegex","frame","fields","field","displayName","test","newDisplayName","replace","config","state"],"sources":["/home/soula/grafana/packages/grafana-data/src/transformations/transformers/renameByRegex.ts"],"sourcesContent":["import { map } from 'rxjs/operators';\n\nimport { getFieldDisplayName } from '../../field/fieldState';\nimport { stringToJsRegex } from '../../text/string';\nimport { DataFrame } from '../../types/dataFrame';\nimport { DataTransformerInfo } from '../../types/transformations';\n\nimport { DataTransformerID } from './ids';\n\n/**\n * Options for renameByRegexTransformer\n *\n * @public\n */\nexport interface RenameByRegexTransformerOptions {\n  regex: string;\n  renamePattern: string;\n}\n\n/**\n * Replaces the displayName of a field by applying a regular expression\n * to match the name and a pattern for the replacement.\n *\n * @public\n */\nexport const renameByRegexTransformer: DataTransformerInfo<RenameByRegexTransformerOptions> = {\n  id: DataTransformerID.renameByRegex,\n  name: 'Rename fields by regex',\n  description: 'Rename fields based on regular expression by users.',\n  defaultOptions: {\n    regex: '(.*)',\n    renamePattern: '$1',\n  },\n\n  /**\n   * Return a modified copy of the series.  If the transform is not or should not\n   * be applied, just return the input series\n   */\n  operator: (options) => (source) =>\n    source.pipe(\n      map((data) => {\n        if (!Array.isArray(data) || data.length === 0) {\n          return data;\n        }\n        return data.map(renameFieldsByRegex(options));\n      })\n    ),\n};\n\nconst renameFieldsByRegex = (options: RenameByRegexTransformerOptions) => (frame: DataFrame) => {\n  const regex = stringToJsRegex(options.regex);\n  const fields = frame.fields.map((field) => {\n    const displayName = getFieldDisplayName(field, frame);\n    if (!regex.test(displayName)) {\n      return field;\n    }\n    const newDisplayName = displayName.replace(regex, options.renamePattern);\n    return {\n      ...field,\n      config: { ...field.config, displayName: newDisplayName },\n      state: { ...field.state, displayName: newDisplayName },\n    };\n  });\n  return { ...frame, fields };\n};\n"],"mappings":"AAAA,SAASA,GAAT,QAAoB,gBAApB;AAEA,SAASC,mBAAT,QAAoC,wBAApC;AACA,SAASC,eAAT,QAAgC,mBAAhC;AAIA,SAASC,iBAAT,QAAkC,OAAlC;AAEA;AACA;AACA;AACA;AACA;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,wBAA8E,GAAG;EAC5FC,EAAE,EAAEF,iBAAiB,CAACG,aADsE;EAE5FC,IAAI,EAAE,wBAFsF;EAG5FC,WAAW,EAAE,qDAH+E;EAI5FC,cAAc,EAAE;IACdC,KAAK,EAAE,MADO;IAEdC,aAAa,EAAE;EAFD,CAJ4E;;EAS5F;AACF;AACA;AACA;EACEC,QAAQ,EAAGC,OAAD,IAAcC,MAAD,IACrBA,MAAM,CAACC,IAAP,CACEf,GAAG,CAAEgB,IAAD,IAAU;IACZ,IAAI,CAACC,KAAK,CAACC,OAAN,CAAcF,IAAd,CAAD,IAAwBA,IAAI,CAACG,MAAL,KAAgB,CAA5C,EAA+C;MAC7C,OAAOH,IAAP;IACD;;IACD,OAAOA,IAAI,CAAChB,GAAL,CAASoB,mBAAmB,CAACP,OAAD,CAA5B,CAAP;EACD,CALE,CADL;AAd0F,CAAvF;;AAwBP,MAAMO,mBAAmB,GAAIP,OAAD,IAA+CQ,KAAD,IAAsB;EAC9F,MAAMX,KAAK,GAAGR,eAAe,CAACW,OAAO,CAACH,KAAT,CAA7B;EACA,MAAMY,MAAM,GAAGD,KAAK,CAACC,MAAN,CAAatB,GAAb,CAAkBuB,KAAD,IAAW;IACzC,MAAMC,WAAW,GAAGvB,mBAAmB,CAACsB,KAAD,EAAQF,KAAR,CAAvC;;IACA,IAAI,CAACX,KAAK,CAACe,IAAN,CAAWD,WAAX,CAAL,EAA8B;MAC5B,OAAOD,KAAP;IACD;;IACD,MAAMG,cAAc,GAAGF,WAAW,CAACG,OAAZ,CAAoBjB,KAApB,EAA2BG,OAAO,CAACF,aAAnC,CAAvB;IACA,yBACKY,KADL;MAEEK,MAAM,oBAAOL,KAAK,CAACK,MAAb;QAAqBJ,WAAW,EAAEE;MAAlC,EAFR;MAGEG,KAAK,oBAAON,KAAK,CAACM,KAAb;QAAoBL,WAAW,EAAEE;MAAjC;IAHP;EAKD,CAXc,CAAf;EAYA,yBAAYL,KAAZ;IAAmBC;EAAnB;AACD,CAfD"},"metadata":{},"sourceType":"module"}