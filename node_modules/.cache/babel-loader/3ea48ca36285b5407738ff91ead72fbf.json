{"ast":null,"code":"import { omit } from 'lodash';\nimport { map } from 'rxjs/operators';\nimport { MutableDataFrame, sortDataFrame } from '../../dataframe';\nimport { isTimeSeries } from '../../dataframe/utils';\nimport { getFrameDisplayName } from '../../field/fieldState';\nimport { FieldType, TIME_SERIES_METRIC_FIELD_NAME, TIME_SERIES_TIME_FIELD_NAME, TIME_SERIES_VALUE_FIELD_NAME } from '../../types/dataFrame';\nimport { ArrayVector } from '../../vector';\nimport { DataTransformerID } from './ids';\nexport const seriesToRowsTransformer = {\n  id: DataTransformerID.seriesToRows,\n  name: 'Series to rows',\n  description: 'Combines multiple series into a single serie and appends a column with metric name per value.',\n  defaultOptions: {},\n  operator: options => source => source.pipe(map(data => {\n    if (!Array.isArray(data) || data.length <= 1) {\n      return data;\n    }\n\n    if (!isTimeSeries(data)) {\n      return data;\n    }\n\n    const timeFieldByIndex = {};\n    const targetFields = new Set();\n    const dataFrame = new MutableDataFrame();\n    const metricField = {\n      name: TIME_SERIES_METRIC_FIELD_NAME,\n      values: new ArrayVector(),\n      config: {},\n      type: FieldType.string\n    };\n\n    for (let frameIndex = 0; frameIndex < data.length; frameIndex++) {\n      const frame = data[frameIndex];\n\n      for (let fieldIndex = 0; fieldIndex < frame.fields.length; fieldIndex++) {\n        const field = frame.fields[fieldIndex];\n\n        if (field.type === FieldType.time) {\n          timeFieldByIndex[frameIndex] = fieldIndex;\n\n          if (!targetFields.has(TIME_SERIES_TIME_FIELD_NAME)) {\n            dataFrame.addField(copyFieldStructure(field, TIME_SERIES_TIME_FIELD_NAME));\n            dataFrame.addField(metricField);\n            targetFields.add(TIME_SERIES_TIME_FIELD_NAME);\n          }\n\n          continue;\n        }\n\n        if (!targetFields.has(TIME_SERIES_VALUE_FIELD_NAME)) {\n          dataFrame.addField(copyFieldStructure(field, TIME_SERIES_VALUE_FIELD_NAME));\n          targetFields.add(TIME_SERIES_VALUE_FIELD_NAME);\n        }\n      }\n    }\n\n    for (let frameIndex = 0; frameIndex < data.length; frameIndex++) {\n      const frame = data[frameIndex];\n\n      for (let valueIndex = 0; valueIndex < frame.length; valueIndex++) {\n        const timeFieldIndex = timeFieldByIndex[frameIndex];\n        const valueFieldIndex = timeFieldIndex === 0 ? 1 : 0;\n        dataFrame.add({\n          [TIME_SERIES_TIME_FIELD_NAME]: frame.fields[timeFieldIndex].values.get(valueIndex),\n          [TIME_SERIES_METRIC_FIELD_NAME]: getFrameDisplayName(frame),\n          [TIME_SERIES_VALUE_FIELD_NAME]: frame.fields[valueFieldIndex].values.get(valueIndex)\n        });\n      }\n    }\n\n    return [sortDataFrame(dataFrame, 0, true)];\n  }))\n};\n\nconst copyFieldStructure = (field, name) => {\n  return Object.assign({}, omit(field, ['values', 'state', 'labels', 'config', 'name']), {\n    name: name,\n    values: new ArrayVector(),\n    config: Object.assign({}, omit(field.config, ['displayName', 'displayNameFromDS']))\n  });\n};","map":{"version":3,"names":["omit","map","MutableDataFrame","sortDataFrame","isTimeSeries","getFrameDisplayName","FieldType","TIME_SERIES_METRIC_FIELD_NAME","TIME_SERIES_TIME_FIELD_NAME","TIME_SERIES_VALUE_FIELD_NAME","ArrayVector","DataTransformerID","seriesToRowsTransformer","id","seriesToRows","name","description","defaultOptions","operator","options","source","pipe","data","Array","isArray","length","timeFieldByIndex","targetFields","Set","dataFrame","metricField","values","config","type","string","frameIndex","frame","fieldIndex","fields","field","time","has","addField","copyFieldStructure","add","valueIndex","timeFieldIndex","valueFieldIndex","get"],"sources":["/home/soula/grafana/packages/grafana-data/src/transformations/transformers/seriesToRows.ts"],"sourcesContent":["import { omit } from 'lodash';\nimport { map } from 'rxjs/operators';\n\nimport { MutableDataFrame, sortDataFrame } from '../../dataframe';\nimport { isTimeSeries } from '../../dataframe/utils';\nimport { getFrameDisplayName } from '../../field/fieldState';\nimport {\n  Field,\n  FieldType,\n  TIME_SERIES_METRIC_FIELD_NAME,\n  TIME_SERIES_TIME_FIELD_NAME,\n  TIME_SERIES_VALUE_FIELD_NAME,\n} from '../../types/dataFrame';\nimport { DataTransformerInfo } from '../../types/transformations';\nimport { ArrayVector } from '../../vector';\n\nimport { DataTransformerID } from './ids';\n\nexport interface SeriesToRowsTransformerOptions {}\n\nexport const seriesToRowsTransformer: DataTransformerInfo<SeriesToRowsTransformerOptions> = {\n  id: DataTransformerID.seriesToRows,\n  name: 'Series to rows',\n  description: 'Combines multiple series into a single serie and appends a column with metric name per value.',\n  defaultOptions: {},\n  operator: (options) => (source) =>\n    source.pipe(\n      map((data) => {\n        if (!Array.isArray(data) || data.length <= 1) {\n          return data;\n        }\n\n        if (!isTimeSeries(data)) {\n          return data;\n        }\n\n        const timeFieldByIndex: Record<number, number> = {};\n        const targetFields = new Set<string>();\n        const dataFrame = new MutableDataFrame();\n        const metricField: Field = {\n          name: TIME_SERIES_METRIC_FIELD_NAME,\n          values: new ArrayVector(),\n          config: {},\n          type: FieldType.string,\n        };\n\n        for (let frameIndex = 0; frameIndex < data.length; frameIndex++) {\n          const frame = data[frameIndex];\n\n          for (let fieldIndex = 0; fieldIndex < frame.fields.length; fieldIndex++) {\n            const field = frame.fields[fieldIndex];\n\n            if (field.type === FieldType.time) {\n              timeFieldByIndex[frameIndex] = fieldIndex;\n\n              if (!targetFields.has(TIME_SERIES_TIME_FIELD_NAME)) {\n                dataFrame.addField(copyFieldStructure(field, TIME_SERIES_TIME_FIELD_NAME));\n                dataFrame.addField(metricField);\n                targetFields.add(TIME_SERIES_TIME_FIELD_NAME);\n              }\n              continue;\n            }\n\n            if (!targetFields.has(TIME_SERIES_VALUE_FIELD_NAME)) {\n              dataFrame.addField(copyFieldStructure(field, TIME_SERIES_VALUE_FIELD_NAME));\n              targetFields.add(TIME_SERIES_VALUE_FIELD_NAME);\n            }\n          }\n        }\n\n        for (let frameIndex = 0; frameIndex < data.length; frameIndex++) {\n          const frame = data[frameIndex];\n\n          for (let valueIndex = 0; valueIndex < frame.length; valueIndex++) {\n            const timeFieldIndex = timeFieldByIndex[frameIndex];\n            const valueFieldIndex = timeFieldIndex === 0 ? 1 : 0;\n\n            dataFrame.add({\n              [TIME_SERIES_TIME_FIELD_NAME]: frame.fields[timeFieldIndex].values.get(valueIndex),\n              [TIME_SERIES_METRIC_FIELD_NAME]: getFrameDisplayName(frame),\n              [TIME_SERIES_VALUE_FIELD_NAME]: frame.fields[valueFieldIndex].values.get(valueIndex),\n            });\n          }\n        }\n\n        return [sortDataFrame(dataFrame, 0, true)];\n      })\n    ),\n};\n\nconst copyFieldStructure = (field: Field, name: string): Field => {\n  return {\n    ...omit(field, ['values', 'state', 'labels', 'config', 'name']),\n    name: name,\n    values: new ArrayVector(),\n    config: {\n      ...omit(field.config, ['displayName', 'displayNameFromDS']),\n    },\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}