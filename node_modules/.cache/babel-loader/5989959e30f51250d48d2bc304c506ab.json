{"ast":null,"code":"import { groupBy } from 'lodash';\nimport { of } from 'rxjs';\nimport { map, mergeMap } from 'rxjs/operators';\nimport { FieldType, getDisplayProcessor, sortLogsResult, standardTransformers } from '@grafana/data';\nimport { config } from '@grafana/runtime';\nimport { dataFrameToLogsModel } from '../../../core/logs_model';\nimport { refreshIntervalToSortOrder } from '../../../core/utils/explore';\nimport { preProcessPanelData } from '../../query/state/runRequest';\n/**\n * When processing response first we try to determine what kind of dataframes we got as one query can return multiple\n * dataFrames with different type of data. This is later used for type specific processing. As we use this in\n * Observable pipeline, it decorates the existing panelData to pass the results to later processing stages.\n */\n\nexport const decorateWithFrameTypeMetadata = data => {\n  var _frame$meta;\n\n  const graphFrames = [];\n  const tableFrames = [];\n  const logsFrames = [];\n  const traceFrames = [];\n  const nodeGraphFrames = [];\n\n  for (const frame of data.series) {\n    switch ((_frame$meta = frame.meta) === null || _frame$meta === void 0 ? void 0 : _frame$meta.preferredVisualisationType) {\n      case 'logs':\n        logsFrames.push(frame);\n        break;\n\n      case 'graph':\n        graphFrames.push(frame);\n        break;\n\n      case 'trace':\n        traceFrames.push(frame);\n        break;\n\n      case 'table':\n        tableFrames.push(frame);\n        break;\n\n      case 'nodeGraph':\n        nodeGraphFrames.push(frame);\n        break;\n\n      default:\n        if (isTimeSeries(frame)) {\n          graphFrames.push(frame);\n          tableFrames.push(frame);\n        } else {\n          // We fallback to table if we do not have any better meta info about the dataframe.\n          tableFrames.push(frame);\n        }\n\n    }\n  }\n\n  return Object.assign({}, data, {\n    graphFrames,\n    tableFrames,\n    logsFrames,\n    traceFrames,\n    nodeGraphFrames,\n    graphResult: null,\n    tableResult: null,\n    logsResult: null\n  });\n};\nexport const decorateWithGraphResult = data => {\n  if (!data.graphFrames.length) {\n    return Object.assign({}, data, {\n      graphResult: null\n    });\n  }\n\n  return Object.assign({}, data, {\n    graphResult: data.graphFrames\n  });\n};\n/**\n * This processing returns Observable because it uses Transformer internally which result type is also Observable.\n * In this case the transformer should return single result but it is possible that in the future it could return\n * multiple results and so this should be used with mergeMap or similar to unbox the internal observable.\n */\n\nexport const decorateWithTableResult = data => {\n  if (data.tableFrames.length === 0) {\n    return of(Object.assign({}, data, {\n      tableResult: null\n    }));\n  }\n\n  data.tableFrames.sort((frameA, frameB) => {\n    const frameARefId = frameA.refId;\n    const frameBRefId = frameB.refId;\n\n    if (frameARefId > frameBRefId) {\n      return 1;\n    }\n\n    if (frameARefId < frameBRefId) {\n      return -1;\n    }\n\n    return 0;\n  });\n  const hasOnlyTimeseries = data.tableFrames.every(df => isTimeSeries(df)); // If we have only timeseries we do join on default time column which makes more sense. If we are showing\n  // non timeseries or some mix of data we are not trying to join on anything and just try to merge them in\n  // single table, which may not make sense in most cases, but it's up to the user to query something sensible.\n\n  const transformer = hasOnlyTimeseries ? of(data.tableFrames).pipe(standardTransformers.seriesToColumnsTransformer.operator({})) : of(data.tableFrames).pipe(standardTransformers.mergeTransformer.operator({}));\n  return transformer.pipe(map(frames => {\n    const frame = frames[0]; // set display processor\n\n    for (const field of frame.fields) {\n      var _field$display, _data$request$timezon, _data$request;\n\n      field.display = (_field$display = field.display) !== null && _field$display !== void 0 ? _field$display : getDisplayProcessor({\n        field,\n        theme: config.theme2,\n        timeZone: (_data$request$timezon = (_data$request = data.request) === null || _data$request === void 0 ? void 0 : _data$request.timezone) !== null && _data$request$timezon !== void 0 ? _data$request$timezon : 'browser'\n      });\n    }\n\n    return Object.assign({}, data, {\n      tableResult: frame\n    });\n  }));\n};\nexport const decorateWithLogsResult = (options = {}) => data => {\n  var _data$request2;\n\n  if (data.logsFrames.length === 0) {\n    return Object.assign({}, data, {\n      logsResult: null\n    });\n  }\n\n  const intervalMs = (_data$request2 = data.request) === null || _data$request2 === void 0 ? void 0 : _data$request2.intervalMs;\n  const newResults = dataFrameToLogsModel(data.logsFrames, intervalMs, options.absoluteRange, options.queries);\n  const sortOrder = refreshIntervalToSortOrder(options.refreshInterval);\n  const sortedNewResults = sortLogsResult(newResults, sortOrder);\n  const rows = sortedNewResults.rows;\n  const series = options.fullRangeLogsVolumeAvailable ? undefined : sortedNewResults.series;\n  const logsResult = Object.assign({}, sortedNewResults, {\n    rows,\n    series\n  });\n  return Object.assign({}, data, {\n    logsResult\n  });\n}; // decorateData applies all decorators\n\nexport function decorateData(data, queryResponse, absoluteRange, refreshInterval, queries, fullRangeLogsVolumeAvailable) {\n  return of(data).pipe(map(data => preProcessPanelData(data, queryResponse)), map(decorateWithFrameTypeMetadata), map(decorateWithGraphResult), map(decorateWithLogsResult({\n    absoluteRange,\n    refreshInterval,\n    queries,\n    fullRangeLogsVolumeAvailable\n  })), mergeMap(decorateWithTableResult));\n}\n/**\n * Check if frame contains time series, which for our purpose means 1 time column and 1 or more numeric columns.\n */\n\nfunction isTimeSeries(frame) {\n  var _grouped$FieldType$ti;\n\n  const grouped = groupBy(frame.fields, field => field.type);\n  return Boolean(Object.keys(grouped).length === 2 && ((_grouped$FieldType$ti = grouped[FieldType.time]) === null || _grouped$FieldType$ti === void 0 ? void 0 : _grouped$FieldType$ti.length) === 1 && grouped[FieldType.number]);\n}","map":{"version":3,"names":["groupBy","of","map","mergeMap","FieldType","getDisplayProcessor","sortLogsResult","standardTransformers","config","dataFrameToLogsModel","refreshIntervalToSortOrder","preProcessPanelData","decorateWithFrameTypeMetadata","data","graphFrames","tableFrames","logsFrames","traceFrames","nodeGraphFrames","frame","series","meta","preferredVisualisationType","push","isTimeSeries","graphResult","tableResult","logsResult","decorateWithGraphResult","length","decorateWithTableResult","sort","frameA","frameB","frameARefId","refId","frameBRefId","hasOnlyTimeseries","every","df","transformer","pipe","seriesToColumnsTransformer","operator","mergeTransformer","frames","field","fields","display","theme","theme2","timeZone","request","timezone","decorateWithLogsResult","options","intervalMs","newResults","absoluteRange","queries","sortOrder","refreshInterval","sortedNewResults","rows","fullRangeLogsVolumeAvailable","undefined","decorateData","queryResponse","grouped","type","Boolean","Object","keys","time","number"],"sources":["/home/soula/grafana/public/app/features/explore/utils/decorators.ts"],"sourcesContent":["import { groupBy } from 'lodash';\nimport { Observable, of } from 'rxjs';\nimport { map, mergeMap } from 'rxjs/operators';\n\nimport {\n  AbsoluteTimeRange,\n  DataFrame,\n  FieldType,\n  getDisplayProcessor,\n  PanelData,\n  sortLogsResult,\n  standardTransformers,\n  DataQuery,\n} from '@grafana/data';\nimport { config } from '@grafana/runtime';\n\nimport { dataFrameToLogsModel } from '../../../core/logs_model';\nimport { refreshIntervalToSortOrder } from '../../../core/utils/explore';\nimport { ExplorePanelData } from '../../../types';\nimport { preProcessPanelData } from '../../query/state/runRequest';\n\n/**\n * When processing response first we try to determine what kind of dataframes we got as one query can return multiple\n * dataFrames with different type of data. This is later used for type specific processing. As we use this in\n * Observable pipeline, it decorates the existing panelData to pass the results to later processing stages.\n */\nexport const decorateWithFrameTypeMetadata = (data: PanelData): ExplorePanelData => {\n  const graphFrames: DataFrame[] = [];\n  const tableFrames: DataFrame[] = [];\n  const logsFrames: DataFrame[] = [];\n  const traceFrames: DataFrame[] = [];\n  const nodeGraphFrames: DataFrame[] = [];\n\n  for (const frame of data.series) {\n    switch (frame.meta?.preferredVisualisationType) {\n      case 'logs':\n        logsFrames.push(frame);\n        break;\n      case 'graph':\n        graphFrames.push(frame);\n        break;\n      case 'trace':\n        traceFrames.push(frame);\n        break;\n      case 'table':\n        tableFrames.push(frame);\n        break;\n      case 'nodeGraph':\n        nodeGraphFrames.push(frame);\n        break;\n      default:\n        if (isTimeSeries(frame)) {\n          graphFrames.push(frame);\n          tableFrames.push(frame);\n        } else {\n          // We fallback to table if we do not have any better meta info about the dataframe.\n          tableFrames.push(frame);\n        }\n    }\n  }\n\n  return {\n    ...data,\n    graphFrames,\n    tableFrames,\n    logsFrames,\n    traceFrames,\n    nodeGraphFrames,\n    graphResult: null,\n    tableResult: null,\n    logsResult: null,\n  };\n};\n\nexport const decorateWithGraphResult = (data: ExplorePanelData): ExplorePanelData => {\n  if (!data.graphFrames.length) {\n    return { ...data, graphResult: null };\n  }\n\n  return { ...data, graphResult: data.graphFrames };\n};\n\n/**\n * This processing returns Observable because it uses Transformer internally which result type is also Observable.\n * In this case the transformer should return single result but it is possible that in the future it could return\n * multiple results and so this should be used with mergeMap or similar to unbox the internal observable.\n */\nexport const decorateWithTableResult = (data: ExplorePanelData): Observable<ExplorePanelData> => {\n  if (data.tableFrames.length === 0) {\n    return of({ ...data, tableResult: null });\n  }\n\n  data.tableFrames.sort((frameA: DataFrame, frameB: DataFrame) => {\n    const frameARefId = frameA.refId!;\n    const frameBRefId = frameB.refId!;\n\n    if (frameARefId > frameBRefId) {\n      return 1;\n    }\n    if (frameARefId < frameBRefId) {\n      return -1;\n    }\n    return 0;\n  });\n\n  const hasOnlyTimeseries = data.tableFrames.every((df) => isTimeSeries(df));\n\n  // If we have only timeseries we do join on default time column which makes more sense. If we are showing\n  // non timeseries or some mix of data we are not trying to join on anything and just try to merge them in\n  // single table, which may not make sense in most cases, but it's up to the user to query something sensible.\n  const transformer = hasOnlyTimeseries\n    ? of(data.tableFrames).pipe(standardTransformers.seriesToColumnsTransformer.operator({}))\n    : of(data.tableFrames).pipe(standardTransformers.mergeTransformer.operator({}));\n\n  return transformer.pipe(\n    map((frames) => {\n      const frame = frames[0];\n\n      // set display processor\n      for (const field of frame.fields) {\n        field.display =\n          field.display ??\n          getDisplayProcessor({\n            field,\n            theme: config.theme2,\n            timeZone: data.request?.timezone ?? 'browser',\n          });\n      }\n\n      return { ...data, tableResult: frame };\n    })\n  );\n};\n\nexport const decorateWithLogsResult =\n  (\n    options: {\n      absoluteRange?: AbsoluteTimeRange;\n      refreshInterval?: string;\n      queries?: DataQuery[];\n      fullRangeLogsVolumeAvailable?: boolean;\n    } = {}\n  ) =>\n  (data: ExplorePanelData): ExplorePanelData => {\n    if (data.logsFrames.length === 0) {\n      return { ...data, logsResult: null };\n    }\n\n    const intervalMs = data.request?.intervalMs;\n    const newResults = dataFrameToLogsModel(data.logsFrames, intervalMs, options.absoluteRange, options.queries);\n    const sortOrder = refreshIntervalToSortOrder(options.refreshInterval);\n    const sortedNewResults = sortLogsResult(newResults, sortOrder);\n    const rows = sortedNewResults.rows;\n    const series = options.fullRangeLogsVolumeAvailable ? undefined : sortedNewResults.series;\n    const logsResult = { ...sortedNewResults, rows, series };\n\n    return { ...data, logsResult };\n  };\n\n// decorateData applies all decorators\nexport function decorateData(\n  data: PanelData,\n  queryResponse: PanelData,\n  absoluteRange: AbsoluteTimeRange,\n  refreshInterval: string | undefined,\n  queries: DataQuery[] | undefined,\n  fullRangeLogsVolumeAvailable: boolean\n): Observable<ExplorePanelData> {\n  return of(data).pipe(\n    map((data: PanelData) => preProcessPanelData(data, queryResponse)),\n    map(decorateWithFrameTypeMetadata),\n    map(decorateWithGraphResult),\n    map(decorateWithLogsResult({ absoluteRange, refreshInterval, queries, fullRangeLogsVolumeAvailable })),\n    mergeMap(decorateWithTableResult)\n  );\n}\n\n/**\n * Check if frame contains time series, which for our purpose means 1 time column and 1 or more numeric columns.\n */\nfunction isTimeSeries(frame: DataFrame): boolean {\n  const grouped = groupBy(frame.fields, (field) => field.type);\n  return Boolean(\n    Object.keys(grouped).length === 2 && grouped[FieldType.time]?.length === 1 && grouped[FieldType.number]\n  );\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}