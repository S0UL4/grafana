{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { cloneDeep, find, first as _first, isNumber, isObject, isString, map as _map } from 'lodash';\nimport { generate, lastValueFrom, of, throwError } from 'rxjs';\nimport { catchError, first, map, mergeMap, skipWhile, throwIfEmpty } from 'rxjs/operators';\nimport { gte, lt, satisfies } from 'semver';\nimport { DataSourceApi, dateTime, getDefaultTimeRange, getLogLevelFromKey, LogLevel, toUtc } from '@grafana/data';\nimport { getBackendSrv, getDataSourceSrv } from '@grafana/runtime';\nimport { queryLogsVolume } from 'app/core/logs_model';\nimport { getTemplateSrv } from 'app/features/templating/template_srv';\nimport { ElasticsearchAnnotationsQueryEditor } from './components/QueryEditor/AnnotationQueryEditor';\nimport { isBucketAggregationWithField } from './components/QueryEditor/BucketAggregationsEditor/aggregations';\nimport { bucketAggregationConfig } from './components/QueryEditor/BucketAggregationsEditor/utils';\nimport { isMetricAggregationWithField, isPipelineAggregationWithMultipleBucketPaths } from './components/QueryEditor/MetricAggregationsEditor/aggregations';\nimport { metricAggregationConfig } from './components/QueryEditor/MetricAggregationsEditor/utils';\nimport { ElasticResponse } from './elastic_response';\nimport { IndexPattern } from './index_pattern';\nimport LanguageProvider from './language_provider';\nimport { ElasticQueryBuilder } from './query_builder';\nimport { defaultBucketAgg, hasMetricOfType } from './query_def';\nimport { coerceESVersion, getScriptValue, isSupportedVersion } from './utils'; // Those are metadata fields as defined in https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-fields.html#_identity_metadata_fields.\n// custom fields can start with underscores, therefore is not safe to exclude anything that starts with one.\n\nconst ELASTIC_META_FIELDS = ['_index', '_type', '_id', '_source', '_size', '_field_names', '_ignored', '_routing', '_meta'];\nexport class ElasticDatasource extends DataSourceApi {\n  constructor(instanceSettings, templateSrv = getTemplateSrv()) {\n    var _instanceSettings$dat, _settingsData$include;\n\n    super(instanceSettings);\n\n    _defineProperty(this, \"basicAuth\", void 0);\n\n    _defineProperty(this, \"withCredentials\", void 0);\n\n    _defineProperty(this, \"url\", void 0);\n\n    _defineProperty(this, \"name\", void 0);\n\n    _defineProperty(this, \"index\", void 0);\n\n    _defineProperty(this, \"timeField\", void 0);\n\n    _defineProperty(this, \"esVersion\", void 0);\n\n    _defineProperty(this, \"xpack\", void 0);\n\n    _defineProperty(this, \"interval\", void 0);\n\n    _defineProperty(this, \"maxConcurrentShardRequests\", void 0);\n\n    _defineProperty(this, \"queryBuilder\", void 0);\n\n    _defineProperty(this, \"indexPattern\", void 0);\n\n    _defineProperty(this, \"logMessageField\", void 0);\n\n    _defineProperty(this, \"logLevelField\", void 0);\n\n    _defineProperty(this, \"dataLinks\", void 0);\n\n    _defineProperty(this, \"languageProvider\", void 0);\n\n    _defineProperty(this, \"includeFrozen\", void 0);\n\n    _defineProperty(this, \"isProxyAccess\", void 0);\n\n    _defineProperty(this, \"getLogRowContext\", async (row, options) => {\n      var _options$limit;\n\n      const sortField = row.dataFrame.fields.find(f => f.name === 'sort');\n      const searchAfter = (sortField === null || sortField === void 0 ? void 0 : sortField.values.get(row.rowIndex)) || [row.timeEpochMs];\n      const sort = (options === null || options === void 0 ? void 0 : options.direction) === 'FORWARD' ? 'asc' : 'desc';\n      const header = (options === null || options === void 0 ? void 0 : options.direction) === 'FORWARD' ? this.getQueryHeader('query_then_fetch', dateTime(row.timeEpochMs)) : this.getQueryHeader('query_then_fetch', undefined, dateTime(row.timeEpochMs));\n      const limit = (_options$limit = options === null || options === void 0 ? void 0 : options.limit) !== null && _options$limit !== void 0 ? _options$limit : 10;\n      const esQuery = JSON.stringify({\n        size: limit,\n        query: {\n          bool: {\n            filter: [{\n              range: {\n                [this.timeField]: {\n                  [(options === null || options === void 0 ? void 0 : options.direction) === 'FORWARD' ? 'gte' : 'lte']: row.timeEpochMs,\n                  format: 'epoch_millis'\n                }\n              }\n            }]\n          }\n        },\n        sort: [{\n          [this.timeField]: sort\n        }, {\n          _doc: sort\n        }],\n        search_after: searchAfter\n      });\n      const payload = [header, esQuery].join('\\n') + '\\n';\n      const url = this.getMultiSearchUrl();\n      const response = await lastValueFrom(this.post(url, payload));\n      const targets = [{\n        refId: `${row.dataFrame.refId}`,\n        metrics: [{\n          type: 'logs',\n          id: '1'\n        }]\n      }];\n      const elasticResponse = new ElasticResponse(targets, transformHitsBasedOnDirection(response, sort));\n      const logResponse = elasticResponse.getLogs(this.logMessageField, this.logLevelField);\n\n      const dataFrame = _first(logResponse.data);\n\n      if (!dataFrame) {\n        return {\n          data: []\n        };\n      }\n      /**\n       * The LogRowContextProvider requires there is a field in the dataFrame.fields\n       * named `ts` for timestamp and `line` for the actual log line to display.\n       * Unfortunatly these fields are hardcoded and are required for the lines to\n       * be properly displayed. This code just copies the fields based on this.timeField\n       * and this.logMessageField and recreates the dataFrame so it works.\n       */\n\n\n      const timestampField = dataFrame.fields.find(f => f.name === this.timeField);\n      const lineField = dataFrame.fields.find(f => f.name === this.logMessageField);\n\n      if (timestampField && lineField) {\n        return {\n          data: [Object.assign({}, dataFrame, {\n            fields: [...dataFrame.fields, Object.assign({}, timestampField, {\n              name: 'ts'\n            }), Object.assign({}, lineField, {\n              name: 'line'\n            })]\n          })]\n        };\n      }\n\n      return logResponse;\n    });\n\n    this.templateSrv = templateSrv;\n    this.basicAuth = instanceSettings.basicAuth;\n    this.withCredentials = instanceSettings.withCredentials;\n    this.url = instanceSettings.url;\n    this.name = instanceSettings.name;\n    this.index = (_instanceSettings$dat = instanceSettings.database) !== null && _instanceSettings$dat !== void 0 ? _instanceSettings$dat : '';\n    this.isProxyAccess = instanceSettings.access === 'proxy';\n    const settingsData = instanceSettings.jsonData || {};\n    this.timeField = settingsData.timeField;\n    this.esVersion = coerceESVersion(settingsData.esVersion);\n    this.xpack = Boolean(settingsData.xpack);\n    this.indexPattern = new IndexPattern(this.index, settingsData.interval);\n    this.interval = settingsData.timeInterval;\n    this.maxConcurrentShardRequests = settingsData.maxConcurrentShardRequests;\n    this.queryBuilder = new ElasticQueryBuilder({\n      timeField: this.timeField,\n      esVersion: this.esVersion\n    });\n    this.logMessageField = settingsData.logMessageField || '';\n    this.logLevelField = settingsData.logLevelField || '';\n    this.dataLinks = settingsData.dataLinks || [];\n    this.includeFrozen = (_settingsData$include = settingsData.includeFrozen) !== null && _settingsData$include !== void 0 ? _settingsData$include : false;\n    this.annotations = {\n      QueryEditor: ElasticsearchAnnotationsQueryEditor\n    };\n\n    if (this.logMessageField === '') {\n      this.logMessageField = undefined;\n    }\n\n    if (this.logLevelField === '') {\n      this.logLevelField = undefined;\n    }\n\n    this.languageProvider = new LanguageProvider(this);\n  }\n\n  request(method, url, data, headers) {\n    if (!this.isProxyAccess) {\n      const error = new Error('Browser access mode in the Elasticsearch datasource is no longer available. Switch to server access mode.');\n      return throwError(() => error);\n    }\n\n    if (!isSupportedVersion(this.esVersion)) {\n      const error = new Error('Support for Elasticsearch versions after their end-of-life (currently versions < 7.10) was removed.');\n      return throwError(() => error);\n    }\n\n    const options = {\n      url: this.url + '/' + url,\n      method,\n      data,\n      headers\n    };\n\n    if (this.basicAuth || this.withCredentials) {\n      options.withCredentials = true;\n    }\n\n    if (this.basicAuth) {\n      options.headers = {\n        Authorization: this.basicAuth\n      };\n    }\n\n    return getBackendSrv().fetch(options).pipe(map(results => {\n      results.data.$$config = results.config;\n      return results.data;\n    }), catchError(err => {\n      if (err.data) {\n        var _ref, _err$data$error$reaso, _err$data$error;\n\n        const message = (_ref = (_err$data$error$reaso = (_err$data$error = err.data.error) === null || _err$data$error === void 0 ? void 0 : _err$data$error.reason) !== null && _err$data$error$reaso !== void 0 ? _err$data$error$reaso : err.data.message) !== null && _ref !== void 0 ? _ref : 'Unknown error';\n        return throwError({\n          message: 'Elasticsearch error: ' + message,\n          error: err.data.error\n        });\n      }\n\n      return throwError(err);\n    }));\n  }\n\n  async importFromAbstractQueries(abstractQueries) {\n    return abstractQueries.map(abstractQuery => this.languageProvider.importFromAbstractQuery(abstractQuery));\n  }\n  /**\n   * Sends a GET request to the specified url on the newest matching and available index.\n   *\n   * When multiple indices span the provided time range, the request is sent starting from the newest index,\n   * and then going backwards until an index is found.\n   *\n   * @param url the url to query the index on, for example `/_mapping`.\n   */\n\n\n  get(url, range = getDefaultTimeRange()) {\n    let indexList = this.indexPattern.getIndexList(range.from, range.to);\n\n    if (!Array.isArray(indexList)) {\n      indexList = [this.indexPattern.getIndexForToday()];\n    }\n\n    const indexUrlList = indexList.map(index => index + url);\n    return this.requestAllIndices(indexUrlList);\n  }\n\n  requestAllIndices(indexList) {\n    const maxTraversals = 7; // do not go beyond one week (for a daily pattern)\n\n    const listLen = indexList.length;\n    return generate({\n      initialState: 0,\n      condition: i => i < Math.min(listLen, maxTraversals),\n      iterate: i => i + 1\n    }).pipe(mergeMap(index => {\n      // catch all errors and emit an object with an err property to simplify checks later in the pipeline\n      return this.request('GET', indexList[listLen - index - 1]).pipe(catchError(err => of({\n        err\n      })));\n    }), skipWhile(resp => {\n      var _resp$err;\n\n      return (resp === null || resp === void 0 ? void 0 : (_resp$err = resp.err) === null || _resp$err === void 0 ? void 0 : _resp$err.status) === 404;\n    }), // skip all requests that fail because missing Elastic index\n    throwIfEmpty(() => 'Could not find an available index for this time range.'), // when i === Math.min(listLen, maxTraversals) generate will complete but without emitting any values which means we didn't find a valid index\n    first(), // take the first value that isn't skipped\n    map(resp => {\n      if (resp.err) {\n        throw resp.err; // if there is some other error except 404 then we must throw it\n      }\n\n      return resp;\n    }));\n  }\n\n  post(url, data) {\n    return this.request('POST', url, data, {\n      'Content-Type': 'application/x-ndjson'\n    });\n  }\n\n  annotationQuery(options) {\n    const annotation = options.annotation;\n    const timeField = annotation.timeField || '@timestamp';\n    const timeEndField = annotation.timeEndField || null;\n    const queryString = annotation.query;\n    const tagsField = annotation.tagsField || 'tags';\n    const textField = annotation.textField || null;\n    const dateRanges = [];\n    const rangeStart = {};\n    rangeStart[timeField] = {\n      from: options.range.from.valueOf(),\n      to: options.range.to.valueOf(),\n      format: 'epoch_millis'\n    };\n    dateRanges.push({\n      range: rangeStart\n    });\n\n    if (timeEndField) {\n      const rangeEnd = {};\n      rangeEnd[timeEndField] = {\n        from: options.range.from.valueOf(),\n        to: options.range.to.valueOf(),\n        format: 'epoch_millis'\n      };\n      dateRanges.push({\n        range: rangeEnd\n      });\n    }\n\n    const queryInterpolated = this.interpolateLuceneQuery(queryString);\n    const query = {\n      bool: {\n        filter: [{\n          bool: {\n            should: dateRanges,\n            minimum_should_match: 1\n          }\n        }]\n      }\n    };\n\n    if (queryInterpolated) {\n      query.bool.filter.push({\n        query_string: {\n          query: queryInterpolated\n        }\n      });\n    }\n\n    const data = {\n      query,\n      size: 10000\n    }; // fields field not supported on ES 5.x\n\n    if (lt(this.esVersion, '5.0.0')) {\n      data['fields'] = [timeField, '_source'];\n    }\n\n    const header = {\n      search_type: 'query_then_fetch',\n      ignore_unavailable: true\n    }; // old elastic annotations had index specified on them\n\n    if (annotation.index) {\n      header.index = annotation.index;\n    } else {\n      header.index = this.indexPattern.getIndexList(options.range.from, options.range.to);\n    }\n\n    const payload = JSON.stringify(header) + '\\n' + JSON.stringify(data) + '\\n';\n    return lastValueFrom(this.post('_msearch', payload).pipe(map(res => {\n      const list = [];\n      const hits = res.responses[0].hits.hits;\n\n      const getFieldFromSource = (source, fieldName) => {\n        if (!fieldName) {\n          return;\n        }\n\n        const fieldNames = fieldName.split('.');\n        let fieldValue = source;\n\n        for (let i = 0; i < fieldNames.length; i++) {\n          fieldValue = fieldValue[fieldNames[i]];\n\n          if (!fieldValue) {\n            console.log('could not find field in annotation: ', fieldName);\n            return '';\n          }\n        }\n\n        return fieldValue;\n      };\n\n      for (let i = 0; i < hits.length; i++) {\n        const source = hits[i]._source;\n        let time = getFieldFromSource(source, timeField);\n\n        if (typeof hits[i].fields !== 'undefined') {\n          const fields = hits[i].fields;\n\n          if (isString(fields[timeField]) || isNumber(fields[timeField])) {\n            time = fields[timeField];\n          }\n        }\n\n        const event = {\n          annotation: annotation,\n          time: toUtc(time).valueOf(),\n          text: getFieldFromSource(source, textField),\n          tags: getFieldFromSource(source, tagsField)\n        };\n\n        if (timeEndField) {\n          const timeEnd = getFieldFromSource(source, timeEndField);\n\n          if (timeEnd) {\n            event.timeEnd = toUtc(timeEnd).valueOf();\n          }\n        } // legacy support for title tield\n\n\n        if (annotation.titleField) {\n          const title = getFieldFromSource(source, annotation.titleField);\n\n          if (title) {\n            event.text = title + '\\n' + event.text;\n          }\n        }\n\n        if (typeof event.tags === 'string') {\n          event.tags = event.tags.split(',');\n        }\n\n        list.push(event);\n      }\n\n      return list;\n    })));\n  }\n\n  interpolateLuceneQuery(queryString, scopedVars) {\n    return this.templateSrv.replace(queryString, scopedVars, 'lucene');\n  }\n\n  interpolateVariablesInQueries(queries, scopedVars) {\n    // We need a separate interpolation format for lucene queries, therefore we first interpolate any\n    // lucene query string and then everything else\n    const interpolateBucketAgg = bucketAgg => {\n      if (bucketAgg.type === 'filters') {\n        var _bucketAgg$settings, _bucketAgg$settings$f;\n\n        return Object.assign({}, bucketAgg, {\n          settings: Object.assign({}, bucketAgg.settings, {\n            filters: (_bucketAgg$settings = bucketAgg.settings) === null || _bucketAgg$settings === void 0 ? void 0 : (_bucketAgg$settings$f = _bucketAgg$settings.filters) === null || _bucketAgg$settings$f === void 0 ? void 0 : _bucketAgg$settings$f.map(filter => Object.assign({}, filter, {\n              query: this.interpolateLuceneQuery(filter.query, scopedVars) || '*'\n            }))\n          })\n        });\n      }\n\n      return bucketAgg;\n    };\n\n    const expandedQueries = queries.map(query => {\n      var _query$bucketAggs;\n\n      return Object.assign({}, query, {\n        datasource: this.getRef(),\n        query: this.interpolateLuceneQuery(query.query || '', scopedVars),\n        bucketAggs: (_query$bucketAggs = query.bucketAggs) === null || _query$bucketAggs === void 0 ? void 0 : _query$bucketAggs.map(interpolateBucketAgg)\n      });\n    });\n    const finalQueries = JSON.parse(this.templateSrv.replace(JSON.stringify(expandedQueries), scopedVars));\n    return finalQueries;\n  }\n\n  testDatasource() {\n    // validate that the index exist and has date field\n    return lastValueFrom(this.getFields(['date']).pipe(mergeMap(dateFields => {\n      const timeField = find(dateFields, {\n        text: this.timeField\n      });\n\n      if (!timeField) {\n        return of({\n          status: 'error',\n          message: 'No date field named ' + this.timeField + ' found'\n        });\n      }\n\n      return of({\n        status: 'success',\n        message: 'Index OK. Time field name OK.'\n      });\n    }), catchError(err => {\n      console.error(err);\n\n      if (err.message) {\n        return of({\n          status: 'error',\n          message: err.message\n        });\n      } else {\n        return of({\n          status: 'error',\n          message: err.status\n        });\n      }\n    })));\n  }\n\n  getQueryHeader(searchType, timeFrom, timeTo) {\n    const queryHeader = {\n      search_type: searchType,\n      ignore_unavailable: true,\n      index: this.indexPattern.getIndexList(timeFrom, timeTo)\n    };\n\n    if (satisfies(this.esVersion, '>=5.6.0 <7.0.0')) {\n      queryHeader['max_concurrent_shard_requests'] = this.maxConcurrentShardRequests;\n    }\n\n    return JSON.stringify(queryHeader);\n  }\n\n  getQueryDisplayText(query) {\n    // TODO: This might be refactored a bit.\n    const metricAggs = query.metrics;\n    const bucketAggs = query.bucketAggs;\n    let text = '';\n\n    if (query.query) {\n      text += 'Query: ' + query.query + ', ';\n    }\n\n    text += 'Metrics: ';\n    text += metricAggs === null || metricAggs === void 0 ? void 0 : metricAggs.reduce((acc, metric) => {\n      const metricConfig = metricAggregationConfig[metric.type];\n      let text = metricConfig.label + '(';\n\n      if (isMetricAggregationWithField(metric)) {\n        text += metric.field;\n      }\n\n      if (isPipelineAggregationWithMultipleBucketPaths(metric)) {\n        text += getScriptValue(metric).replace(new RegExp('params.', 'g'), '');\n      }\n\n      text += '), ';\n      return `${acc} ${text}`;\n    }, '');\n    text += bucketAggs === null || bucketAggs === void 0 ? void 0 : bucketAggs.reduce((acc, bucketAgg, index) => {\n      const bucketConfig = bucketAggregationConfig[bucketAgg.type];\n      let text = '';\n\n      if (index === 0) {\n        text += ' Group by: ';\n      }\n\n      text += bucketConfig.label + '(';\n\n      if (isBucketAggregationWithField(bucketAgg)) {\n        text += bucketAgg.field;\n      }\n\n      return `${acc} ${text}), `;\n    }, '');\n\n    if (query.alias) {\n      text += 'Alias: ' + query.alias;\n    }\n\n    return text;\n  }\n  /**\n   * This method checks to ensure the user is running a 5.0+ cluster. This is\n   * necessary bacause the query being used for the getLogRowContext relies on the\n   * search_after feature.\n   */\n\n\n  showContextToggle() {\n    return gte(this.esVersion, '5.0.0');\n  }\n\n  getLogsVolumeDataProvider(request) {\n    const isLogsVolumeAvailable = request.targets.some(target => {\n      var _target$metrics;\n\n      return ((_target$metrics = target.metrics) === null || _target$metrics === void 0 ? void 0 : _target$metrics.length) === 1 && target.metrics[0].type === 'logs';\n    });\n\n    if (!isLogsVolumeAvailable) {\n      return undefined;\n    }\n\n    const logsVolumeRequest = cloneDeep(request);\n    logsVolumeRequest.targets = logsVolumeRequest.targets.map(target => {\n      var _this$timeField;\n\n      const bucketAggs = [];\n      const timeField = (_this$timeField = this.timeField) !== null && _this$timeField !== void 0 ? _this$timeField : '@timestamp';\n\n      if (this.logLevelField) {\n        bucketAggs.push({\n          id: '2',\n          type: 'terms',\n          settings: {\n            min_doc_count: '0',\n            size: '0',\n            order: 'desc',\n            orderBy: '_count',\n            missing: LogLevel.unknown\n          },\n          field: this.logLevelField\n        });\n      }\n\n      bucketAggs.push({\n        id: '3',\n        type: 'date_histogram',\n        settings: {\n          interval: 'auto',\n          min_doc_count: '0',\n          trimEdges: '0'\n        },\n        field: timeField\n      });\n      const logsVolumeQuery = {\n        refId: target.refId,\n        query: target.query,\n        metrics: [{\n          type: 'count',\n          id: '1'\n        }],\n        timeField,\n        bucketAggs\n      };\n      return logsVolumeQuery;\n    });\n    return queryLogsVolume(this, logsVolumeRequest, {\n      range: request.range,\n      targets: request.targets,\n      extractLevel: dataFrame => getLogLevelFromKey(dataFrame.name || '')\n    });\n  }\n\n  query(options) {\n    let payload = '';\n    const targets = this.interpolateVariablesInQueries(cloneDeep(options.targets), options.scopedVars);\n    const sentTargets = [];\n    let targetsContainsLogsQuery = targets.some(target => hasMetricOfType(target, 'logs')); // add global adhoc filters to timeFilter\n\n    const adhocFilters = this.templateSrv.getAdhocFilters(this.name);\n    const logLimits = [];\n\n    for (const target of targets) {\n      if (target.hide) {\n        continue;\n      }\n\n      let queryObj;\n\n      if (hasMetricOfType(target, 'logs')) {\n        var _target$metrics2, _log$settings, _log$settings2;\n\n        // FIXME: All this logic here should be in the query builder.\n        // When moving to the BE-only implementation we should remove this and let the BE\n        // Handle this.\n        // TODO: defaultBucketAgg creates a dete_histogram aggregation without a field, so it fallbacks to\n        // the configured timeField. we should allow people to use a different time field here.\n        target.bucketAggs = [defaultBucketAgg()];\n        const log = (_target$metrics2 = target.metrics) === null || _target$metrics2 === void 0 ? void 0 : _target$metrics2.find(m => m.type === 'logs');\n        const limit = (_log$settings = log.settings) !== null && _log$settings !== void 0 && _log$settings.limit ? parseInt((_log$settings2 = log.settings) === null || _log$settings2 === void 0 ? void 0 : _log$settings2.limit, 10) : 500;\n        logLimits.push(limit);\n        target.metrics = []; // Setting this for metrics queries that are typed as logs\n\n        queryObj = this.queryBuilder.getLogsQuery(target, limit, adhocFilters);\n      } else {\n        logLimits.push();\n\n        if (target.alias) {\n          target.alias = this.interpolateLuceneQuery(target.alias, options.scopedVars);\n        }\n\n        queryObj = this.queryBuilder.build(target, adhocFilters);\n      }\n\n      const esQuery = JSON.stringify(queryObj);\n      const searchType = queryObj.size === 0 && lt(this.esVersion, '5.0.0') ? 'count' : 'query_then_fetch';\n      const header = this.getQueryHeader(searchType, options.range.from, options.range.to);\n      payload += header + '\\n';\n      payload += esQuery + '\\n';\n      sentTargets.push(target);\n    }\n\n    if (sentTargets.length === 0) {\n      return of({\n        data: []\n      });\n    } // We replace the range here for actual values. We need to replace it together with enclosing \"\" so that we replace\n    // it as an integer not as string with digits. This is because elastic will convert the string only if the time\n    // field is specified as type date (which probably should) but can also be specified as integer (millisecond epoch)\n    // and then sending string will error out.\n\n\n    payload = payload.replace(/\"\\$timeFrom\"/g, options.range.from.valueOf().toString());\n    payload = payload.replace(/\"\\$timeTo\"/g, options.range.to.valueOf().toString());\n    payload = this.templateSrv.replace(payload, options.scopedVars);\n    const url = this.getMultiSearchUrl();\n    return this.post(url, payload).pipe(map(res => {\n      const er = new ElasticResponse(sentTargets, res); // TODO: This needs to be revisited, it seems wrong to process ALL the sent queries as logs if only one of them was a log query\n\n      if (targetsContainsLogsQuery) {\n        const response = er.getLogs(this.logMessageField, this.logLevelField);\n        response.data.forEach((dataFrame, index) => {\n          enhanceDataFrame(dataFrame, this.dataLinks, logLimits[index]);\n        });\n        return response;\n      }\n\n      return er.getTimeSeries();\n    }));\n  }\n\n  isMetadataField(fieldName) {\n    return ELASTIC_META_FIELDS.includes(fieldName);\n  } // TODO: instead of being a string, this could be a custom type representing all the elastic types\n  // FIXME: This doesn't seem to return actual MetricFindValues, we should either change the return type\n  // or fix the implementation.\n\n\n  getFields(type, range) {\n    const typeMap = {\n      float: 'number',\n      double: 'number',\n      integer: 'number',\n      long: 'number',\n      date: 'date',\n      date_nanos: 'date',\n      string: 'string',\n      text: 'string',\n      scaled_float: 'number',\n      nested: 'nested',\n      histogram: 'number'\n    };\n    return this.get('/_mapping', range).pipe(map(result => {\n      const shouldAddField = (obj, key) => {\n        if (this.isMetadataField(key)) {\n          return false;\n        }\n\n        if (!type || type.length === 0) {\n          return true;\n        } // equal query type filter, or via typemap translation\n\n\n        return type.includes(obj.type) || type.includes(typeMap[obj.type]);\n      }; // Store subfield names: [system, process, cpu, total] -> system.process.cpu.total\n\n\n      const fieldNameParts = [];\n      const fields = {};\n\n      function getFieldsRecursively(obj) {\n        for (const key in obj) {\n          const subObj = obj[key]; // Check mapping field for nested fields\n\n          if (isObject(subObj.properties)) {\n            fieldNameParts.push(key);\n            getFieldsRecursively(subObj.properties);\n          }\n\n          if (isObject(subObj.fields)) {\n            fieldNameParts.push(key);\n            getFieldsRecursively(subObj.fields);\n          }\n\n          if (isString(subObj.type)) {\n            const fieldName = fieldNameParts.concat(key).join('.'); // Hide meta-fields and check field type\n\n            if (shouldAddField(subObj, key)) {\n              fields[fieldName] = {\n                text: fieldName,\n                type: subObj.type\n              };\n            }\n          }\n        }\n\n        fieldNameParts.pop();\n      }\n\n      for (const indexName in result) {\n        const index = result[indexName];\n\n        if (index && index.mappings) {\n          const mappings = index.mappings;\n\n          if (lt(this.esVersion, '7.0.0')) {\n            for (const typeName in mappings) {\n              const properties = mappings[typeName].properties;\n              getFieldsRecursively(properties);\n            }\n          } else {\n            const properties = mappings.properties;\n            getFieldsRecursively(properties);\n          }\n        }\n      } // transform to array\n\n\n      return _map(fields, value => {\n        return value;\n      });\n    }));\n  }\n\n  getTerms(queryDef, range = getDefaultTimeRange()) {\n    const searchType = gte(this.esVersion, '5.0.0') ? 'query_then_fetch' : 'count';\n    const header = this.getQueryHeader(searchType, range.from, range.to);\n    let esQuery = JSON.stringify(this.queryBuilder.getTermsQuery(queryDef));\n    esQuery = esQuery.replace(/\\$timeFrom/g, range.from.valueOf().toString());\n    esQuery = esQuery.replace(/\\$timeTo/g, range.to.valueOf().toString());\n    esQuery = header + '\\n' + esQuery + '\\n';\n    const url = this.getMultiSearchUrl();\n    return this.post(url, esQuery).pipe(map(res => {\n      if (!res.responses[0].aggregations) {\n        return [];\n      }\n\n      const buckets = res.responses[0].aggregations['1'].buckets;\n      return _map(buckets, bucket => {\n        return {\n          text: bucket.key_as_string || bucket.key,\n          value: bucket.key\n        };\n      });\n    }));\n  }\n\n  getMultiSearchUrl() {\n    const searchParams = new URLSearchParams();\n\n    if (gte(this.esVersion, '7.0.0') && this.maxConcurrentShardRequests) {\n      searchParams.append('max_concurrent_shard_requests', `${this.maxConcurrentShardRequests}`);\n    }\n\n    if (gte(this.esVersion, '6.6.0') && this.xpack && this.includeFrozen) {\n      searchParams.append('ignore_throttled', 'false');\n    }\n\n    return ('_msearch?' + searchParams.toString()).replace(/\\?$/, '');\n  }\n\n  metricFindQuery(query, options) {\n    const range = options === null || options === void 0 ? void 0 : options.range;\n    const parsedQuery = JSON.parse(query);\n\n    if (query) {\n      if (parsedQuery.find === 'fields') {\n        parsedQuery.type = this.interpolateLuceneQuery(parsedQuery.type);\n        return lastValueFrom(this.getFields(parsedQuery.type, range));\n      }\n\n      if (parsedQuery.find === 'terms') {\n        parsedQuery.field = this.interpolateLuceneQuery(parsedQuery.field);\n        parsedQuery.query = this.interpolateLuceneQuery(parsedQuery.query);\n        return lastValueFrom(this.getTerms(parsedQuery, range));\n      }\n    }\n\n    return Promise.resolve([]);\n  }\n\n  getTagKeys() {\n    return lastValueFrom(this.getFields());\n  }\n\n  getTagValues(options) {\n    return lastValueFrom(this.getTerms({\n      field: options.key\n    }));\n  }\n\n  targetContainsTemplate(target) {\n    if (this.templateSrv.containsTemplate(target.query) || this.templateSrv.containsTemplate(target.alias)) {\n      return true;\n    }\n\n    for (const bucketAgg of target.bucketAggs) {\n      if (this.templateSrv.containsTemplate(bucketAgg.field) || this.objectContainsTemplate(bucketAgg.settings)) {\n        return true;\n      }\n    }\n\n    for (const metric of target.metrics) {\n      if (this.templateSrv.containsTemplate(metric.field) || this.objectContainsTemplate(metric.settings) || this.objectContainsTemplate(metric.meta)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  isPrimitive(obj) {\n    if (obj === null || obj === undefined) {\n      return true;\n    }\n\n    if (['string', 'number', 'boolean'].some(type => type === typeof true)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  objectContainsTemplate(obj) {\n    if (!obj) {\n      return false;\n    }\n\n    for (const key of Object.keys(obj)) {\n      if (this.isPrimitive(obj[key])) {\n        if (this.templateSrv.containsTemplate(obj[key])) {\n          return true;\n        }\n      } else if (Array.isArray(obj[key])) {\n        for (const item of obj[key]) {\n          if (this.objectContainsTemplate(item)) {\n            return true;\n          }\n        }\n      } else {\n        if (this.objectContainsTemplate(obj[key])) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n}\n/**\n * Modifies dataframe and adds dataLinks from the config.\n * Exported for tests.\n */\n\nexport function enhanceDataFrame(dataFrame, dataLinks, limit) {\n  if (limit) {\n    dataFrame.meta = Object.assign({}, dataFrame.meta, {\n      limit\n    });\n  }\n\n  if (!dataLinks.length) {\n    return;\n  }\n\n  for (const field of dataFrame.fields) {\n    const linksToApply = dataLinks.filter(dataLink => new RegExp(dataLink.field).test(field.name));\n\n    if (linksToApply.length === 0) {\n      continue;\n    }\n\n    field.config = field.config || {};\n    field.config.links = [...(field.config.links || [], linksToApply.map(generateDataLink))];\n  }\n}\n\nfunction generateDataLink(linkConfig) {\n  const dataSourceSrv = getDataSourceSrv();\n\n  if (linkConfig.datasourceUid) {\n    var _dsSettings$name;\n\n    const dsSettings = dataSourceSrv.getInstanceSettings(linkConfig.datasourceUid);\n    return {\n      title: linkConfig.urlDisplayLabel || '',\n      url: '',\n      internal: {\n        query: {\n          query: linkConfig.url\n        },\n        datasourceUid: linkConfig.datasourceUid,\n        datasourceName: (_dsSettings$name = dsSettings === null || dsSettings === void 0 ? void 0 : dsSettings.name) !== null && _dsSettings$name !== void 0 ? _dsSettings$name : 'Data source not found'\n      }\n    };\n  } else {\n    return {\n      title: linkConfig.urlDisplayLabel || '',\n      url: linkConfig.url\n    };\n  }\n}\n\nfunction transformHitsBasedOnDirection(response, direction) {\n  if (direction === 'desc') {\n    return response;\n  }\n\n  const actualResponse = response.responses[0];\n  return Object.assign({}, response, {\n    responses: [Object.assign({}, actualResponse, {\n      hits: Object.assign({}, actualResponse.hits, {\n        hits: actualResponse.hits.hits.reverse()\n      })\n    })]\n  });\n}","map":{"version":3,"names":["cloneDeep","find","first","_first","isNumber","isObject","isString","map","_map","generate","lastValueFrom","of","throwError","catchError","mergeMap","skipWhile","throwIfEmpty","gte","lt","satisfies","DataSourceApi","dateTime","getDefaultTimeRange","getLogLevelFromKey","LogLevel","toUtc","getBackendSrv","getDataSourceSrv","queryLogsVolume","getTemplateSrv","ElasticsearchAnnotationsQueryEditor","isBucketAggregationWithField","bucketAggregationConfig","isMetricAggregationWithField","isPipelineAggregationWithMultipleBucketPaths","metricAggregationConfig","ElasticResponse","IndexPattern","LanguageProvider","ElasticQueryBuilder","defaultBucketAgg","hasMetricOfType","coerceESVersion","getScriptValue","isSupportedVersion","ELASTIC_META_FIELDS","ElasticDatasource","constructor","instanceSettings","templateSrv","row","options","sortField","dataFrame","fields","f","name","searchAfter","values","get","rowIndex","timeEpochMs","sort","direction","header","getQueryHeader","undefined","limit","esQuery","JSON","stringify","size","query","bool","filter","range","timeField","format","_doc","search_after","payload","join","url","getMultiSearchUrl","response","post","targets","refId","metrics","type","id","elasticResponse","transformHitsBasedOnDirection","logResponse","getLogs","logMessageField","logLevelField","data","timestampField","lineField","basicAuth","withCredentials","index","database","isProxyAccess","access","settingsData","jsonData","esVersion","xpack","Boolean","indexPattern","interval","timeInterval","maxConcurrentShardRequests","queryBuilder","dataLinks","includeFrozen","annotations","QueryEditor","languageProvider","request","method","headers","error","Error","Authorization","fetch","pipe","results","$$config","config","err","message","reason","importFromAbstractQueries","abstractQueries","abstractQuery","importFromAbstractQuery","indexList","getIndexList","from","to","Array","isArray","getIndexForToday","indexUrlList","requestAllIndices","maxTraversals","listLen","length","initialState","condition","i","Math","min","iterate","resp","status","annotationQuery","annotation","timeEndField","queryString","tagsField","textField","dateRanges","rangeStart","valueOf","push","rangeEnd","queryInterpolated","interpolateLuceneQuery","should","minimum_should_match","query_string","search_type","ignore_unavailable","res","list","hits","responses","getFieldFromSource","source","fieldName","fieldNames","split","fieldValue","console","log","_source","time","event","text","tags","timeEnd","titleField","title","scopedVars","replace","interpolateVariablesInQueries","queries","interpolateBucketAgg","bucketAgg","settings","filters","expandedQueries","datasource","getRef","bucketAggs","finalQueries","parse","testDatasource","getFields","dateFields","searchType","timeFrom","timeTo","queryHeader","getQueryDisplayText","metricAggs","reduce","acc","metric","metricConfig","label","field","RegExp","bucketConfig","alias","showContextToggle","getLogsVolumeDataProvider","isLogsVolumeAvailable","some","target","logsVolumeRequest","min_doc_count","order","orderBy","missing","unknown","trimEdges","logsVolumeQuery","extractLevel","sentTargets","targetsContainsLogsQuery","adhocFilters","getAdhocFilters","logLimits","hide","queryObj","m","parseInt","getLogsQuery","build","toString","er","forEach","enhanceDataFrame","getTimeSeries","isMetadataField","includes","typeMap","float","double","integer","long","date","date_nanos","string","scaled_float","nested","histogram","result","shouldAddField","obj","key","fieldNameParts","getFieldsRecursively","subObj","properties","concat","pop","indexName","mappings","typeName","value","getTerms","queryDef","getTermsQuery","aggregations","buckets","bucket","key_as_string","searchParams","URLSearchParams","append","metricFindQuery","parsedQuery","Promise","resolve","getTagKeys","getTagValues","targetContainsTemplate","containsTemplate","objectContainsTemplate","meta","isPrimitive","Object","keys","item","linksToApply","dataLink","test","links","generateDataLink","linkConfig","dataSourceSrv","datasourceUid","dsSettings","getInstanceSettings","urlDisplayLabel","internal","datasourceName","actualResponse","reverse"],"sources":["/home/soula/grafana/public/app/plugins/datasource/elasticsearch/datasource.ts"],"sourcesContent":["import { cloneDeep, find, first as _first, isNumber, isObject, isString, map as _map } from 'lodash';\nimport { generate, lastValueFrom, Observable, of, throwError } from 'rxjs';\nimport { catchError, first, map, mergeMap, skipWhile, throwIfEmpty } from 'rxjs/operators';\nimport { gte, lt, satisfies } from 'semver';\n\nimport {\n  DataFrame,\n  DataLink,\n  DataQueryRequest,\n  DataQueryResponse,\n  DataSourceApi,\n  DataSourceInstanceSettings,\n  DataSourceWithLogsContextSupport,\n  DataSourceWithQueryImportSupport,\n  DataSourceWithLogsVolumeSupport,\n  DateTime,\n  dateTime,\n  Field,\n  getDefaultTimeRange,\n  AbstractQuery,\n  getLogLevelFromKey,\n  LogLevel,\n  LogRowModel,\n  MetricFindValue,\n  ScopedVars,\n  TimeRange,\n  toUtc,\n} from '@grafana/data';\nimport { BackendSrvRequest, getBackendSrv, getDataSourceSrv } from '@grafana/runtime';\nimport { RowContextOptions } from '@grafana/ui/src/components/Logs/LogRowContextProvider';\nimport { queryLogsVolume } from 'app/core/logs_model';\nimport { getTemplateSrv, TemplateSrv } from 'app/features/templating/template_srv';\n\nimport { ElasticsearchAnnotationsQueryEditor } from './components/QueryEditor/AnnotationQueryEditor';\nimport {\n  BucketAggregation,\n  isBucketAggregationWithField,\n} from './components/QueryEditor/BucketAggregationsEditor/aggregations';\nimport { bucketAggregationConfig } from './components/QueryEditor/BucketAggregationsEditor/utils';\nimport {\n  isMetricAggregationWithField,\n  isPipelineAggregationWithMultipleBucketPaths,\n  Logs,\n} from './components/QueryEditor/MetricAggregationsEditor/aggregations';\nimport { metricAggregationConfig } from './components/QueryEditor/MetricAggregationsEditor/utils';\nimport { ElasticResponse } from './elastic_response';\nimport { IndexPattern } from './index_pattern';\nimport LanguageProvider from './language_provider';\nimport { ElasticQueryBuilder } from './query_builder';\nimport { defaultBucketAgg, hasMetricOfType } from './query_def';\nimport { DataLinkConfig, ElasticsearchOptions, ElasticsearchQuery, TermsQuery } from './types';\nimport { coerceESVersion, getScriptValue, isSupportedVersion } from './utils';\n\n// Those are metadata fields as defined in https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-fields.html#_identity_metadata_fields.\n// custom fields can start with underscores, therefore is not safe to exclude anything that starts with one.\nconst ELASTIC_META_FIELDS = [\n  '_index',\n  '_type',\n  '_id',\n  '_source',\n  '_size',\n  '_field_names',\n  '_ignored',\n  '_routing',\n  '_meta',\n];\n\nexport class ElasticDatasource\n  extends DataSourceApi<ElasticsearchQuery, ElasticsearchOptions>\n  implements\n    DataSourceWithLogsContextSupport,\n    DataSourceWithQueryImportSupport<ElasticsearchQuery>,\n    DataSourceWithLogsVolumeSupport<ElasticsearchQuery>\n{\n  basicAuth?: string;\n  withCredentials?: boolean;\n  url: string;\n  name: string;\n  index: string;\n  timeField: string;\n  esVersion: string;\n  xpack: boolean;\n  interval: string;\n  maxConcurrentShardRequests?: number;\n  queryBuilder: ElasticQueryBuilder;\n  indexPattern: IndexPattern;\n  logMessageField?: string;\n  logLevelField?: string;\n  dataLinks: DataLinkConfig[];\n  languageProvider: LanguageProvider;\n  includeFrozen: boolean;\n  isProxyAccess: boolean;\n\n  constructor(\n    instanceSettings: DataSourceInstanceSettings<ElasticsearchOptions>,\n    private readonly templateSrv: TemplateSrv = getTemplateSrv()\n  ) {\n    super(instanceSettings);\n    this.basicAuth = instanceSettings.basicAuth;\n    this.withCredentials = instanceSettings.withCredentials;\n    this.url = instanceSettings.url!;\n    this.name = instanceSettings.name;\n    this.index = instanceSettings.database ?? '';\n    this.isProxyAccess = instanceSettings.access === 'proxy';\n    const settingsData = instanceSettings.jsonData || ({} as ElasticsearchOptions);\n\n    this.timeField = settingsData.timeField;\n    this.esVersion = coerceESVersion(settingsData.esVersion);\n    this.xpack = Boolean(settingsData.xpack);\n    this.indexPattern = new IndexPattern(this.index, settingsData.interval);\n    this.interval = settingsData.timeInterval;\n    this.maxConcurrentShardRequests = settingsData.maxConcurrentShardRequests;\n    this.queryBuilder = new ElasticQueryBuilder({\n      timeField: this.timeField,\n      esVersion: this.esVersion,\n    });\n    this.logMessageField = settingsData.logMessageField || '';\n    this.logLevelField = settingsData.logLevelField || '';\n    this.dataLinks = settingsData.dataLinks || [];\n    this.includeFrozen = settingsData.includeFrozen ?? false;\n    this.annotations = {\n      QueryEditor: ElasticsearchAnnotationsQueryEditor,\n    };\n\n    if (this.logMessageField === '') {\n      this.logMessageField = undefined;\n    }\n\n    if (this.logLevelField === '') {\n      this.logLevelField = undefined;\n    }\n    this.languageProvider = new LanguageProvider(this);\n  }\n\n  private request(\n    method: string,\n    url: string,\n    data?: undefined,\n    headers?: BackendSrvRequest['headers']\n  ): Observable<any> {\n    if (!this.isProxyAccess) {\n      const error = new Error(\n        'Browser access mode in the Elasticsearch datasource is no longer available. Switch to server access mode.'\n      );\n      return throwError(() => error);\n    }\n\n    if (!isSupportedVersion(this.esVersion)) {\n      const error = new Error(\n        'Support for Elasticsearch versions after their end-of-life (currently versions < 7.10) was removed.'\n      );\n      return throwError(() => error);\n    }\n\n    const options: BackendSrvRequest = {\n      url: this.url + '/' + url,\n      method,\n      data,\n      headers,\n    };\n\n    if (this.basicAuth || this.withCredentials) {\n      options.withCredentials = true;\n    }\n    if (this.basicAuth) {\n      options.headers = {\n        Authorization: this.basicAuth,\n      };\n    }\n\n    return getBackendSrv()\n      .fetch<any>(options)\n      .pipe(\n        map((results) => {\n          results.data.$$config = results.config;\n          return results.data;\n        }),\n        catchError((err) => {\n          if (err.data) {\n            const message = err.data.error?.reason ?? err.data.message ?? 'Unknown error';\n\n            return throwError({\n              message: 'Elasticsearch error: ' + message,\n              error: err.data.error,\n            });\n          }\n\n          return throwError(err);\n        })\n      );\n  }\n\n  async importFromAbstractQueries(abstractQueries: AbstractQuery[]): Promise<ElasticsearchQuery[]> {\n    return abstractQueries.map((abstractQuery) => this.languageProvider.importFromAbstractQuery(abstractQuery));\n  }\n\n  /**\n   * Sends a GET request to the specified url on the newest matching and available index.\n   *\n   * When multiple indices span the provided time range, the request is sent starting from the newest index,\n   * and then going backwards until an index is found.\n   *\n   * @param url the url to query the index on, for example `/_mapping`.\n   */\n  private get(url: string, range = getDefaultTimeRange()): Observable<any> {\n    let indexList = this.indexPattern.getIndexList(range.from, range.to);\n    if (!Array.isArray(indexList)) {\n      indexList = [this.indexPattern.getIndexForToday()];\n    }\n\n    const indexUrlList = indexList.map((index) => index + url);\n\n    return this.requestAllIndices(indexUrlList);\n  }\n\n  private requestAllIndices(indexList: string[]): Observable<any> {\n    const maxTraversals = 7; // do not go beyond one week (for a daily pattern)\n    const listLen = indexList.length;\n\n    return generate({\n      initialState: 0,\n      condition: (i) => i < Math.min(listLen, maxTraversals),\n      iterate: (i) => i + 1,\n    }).pipe(\n      mergeMap((index) => {\n        // catch all errors and emit an object with an err property to simplify checks later in the pipeline\n        return this.request('GET', indexList[listLen - index - 1]).pipe(catchError((err) => of({ err })));\n      }),\n      skipWhile((resp) => resp?.err?.status === 404), // skip all requests that fail because missing Elastic index\n      throwIfEmpty(() => 'Could not find an available index for this time range.'), // when i === Math.min(listLen, maxTraversals) generate will complete but without emitting any values which means we didn't find a valid index\n      first(), // take the first value that isn't skipped\n      map((resp) => {\n        if (resp.err) {\n          throw resp.err; // if there is some other error except 404 then we must throw it\n        }\n\n        return resp;\n      })\n    );\n  }\n\n  private post(url: string, data: any): Observable<any> {\n    return this.request('POST', url, data, { 'Content-Type': 'application/x-ndjson' });\n  }\n\n  annotationQuery(options: any): Promise<any> {\n    const annotation = options.annotation;\n    const timeField = annotation.timeField || '@timestamp';\n    const timeEndField = annotation.timeEndField || null;\n    const queryString = annotation.query;\n    const tagsField = annotation.tagsField || 'tags';\n    const textField = annotation.textField || null;\n\n    const dateRanges = [];\n    const rangeStart: any = {};\n    rangeStart[timeField] = {\n      from: options.range.from.valueOf(),\n      to: options.range.to.valueOf(),\n      format: 'epoch_millis',\n    };\n    dateRanges.push({ range: rangeStart });\n\n    if (timeEndField) {\n      const rangeEnd: any = {};\n      rangeEnd[timeEndField] = {\n        from: options.range.from.valueOf(),\n        to: options.range.to.valueOf(),\n        format: 'epoch_millis',\n      };\n      dateRanges.push({ range: rangeEnd });\n    }\n\n    const queryInterpolated = this.interpolateLuceneQuery(queryString);\n    const query: any = {\n      bool: {\n        filter: [\n          {\n            bool: {\n              should: dateRanges,\n              minimum_should_match: 1,\n            },\n          },\n        ],\n      },\n    };\n\n    if (queryInterpolated) {\n      query.bool.filter.push({\n        query_string: {\n          query: queryInterpolated,\n        },\n      });\n    }\n    const data: any = {\n      query,\n      size: 10000,\n    };\n\n    // fields field not supported on ES 5.x\n    if (lt(this.esVersion, '5.0.0')) {\n      data['fields'] = [timeField, '_source'];\n    }\n\n    const header: any = {\n      search_type: 'query_then_fetch',\n      ignore_unavailable: true,\n    };\n\n    // old elastic annotations had index specified on them\n    if (annotation.index) {\n      header.index = annotation.index;\n    } else {\n      header.index = this.indexPattern.getIndexList(options.range.from, options.range.to);\n    }\n\n    const payload = JSON.stringify(header) + '\\n' + JSON.stringify(data) + '\\n';\n\n    return lastValueFrom(\n      this.post('_msearch', payload).pipe(\n        map((res) => {\n          const list = [];\n          const hits = res.responses[0].hits.hits;\n\n          const getFieldFromSource = (source: any, fieldName: any) => {\n            if (!fieldName) {\n              return;\n            }\n\n            const fieldNames = fieldName.split('.');\n            let fieldValue = source;\n\n            for (let i = 0; i < fieldNames.length; i++) {\n              fieldValue = fieldValue[fieldNames[i]];\n              if (!fieldValue) {\n                console.log('could not find field in annotation: ', fieldName);\n                return '';\n              }\n            }\n\n            return fieldValue;\n          };\n\n          for (let i = 0; i < hits.length; i++) {\n            const source = hits[i]._source;\n            let time = getFieldFromSource(source, timeField);\n            if (typeof hits[i].fields !== 'undefined') {\n              const fields = hits[i].fields;\n              if (isString(fields[timeField]) || isNumber(fields[timeField])) {\n                time = fields[timeField];\n              }\n            }\n\n            const event: {\n              annotation: any;\n              time: number;\n              timeEnd?: number;\n              text: string;\n              tags: string | string[];\n            } = {\n              annotation: annotation,\n              time: toUtc(time).valueOf(),\n              text: getFieldFromSource(source, textField),\n              tags: getFieldFromSource(source, tagsField),\n            };\n\n            if (timeEndField) {\n              const timeEnd = getFieldFromSource(source, timeEndField);\n              if (timeEnd) {\n                event.timeEnd = toUtc(timeEnd).valueOf();\n              }\n            }\n\n            // legacy support for title tield\n            if (annotation.titleField) {\n              const title = getFieldFromSource(source, annotation.titleField);\n              if (title) {\n                event.text = title + '\\n' + event.text;\n              }\n            }\n\n            if (typeof event.tags === 'string') {\n              event.tags = event.tags.split(',');\n            }\n\n            list.push(event);\n          }\n          return list;\n        })\n      )\n    );\n  }\n\n  private interpolateLuceneQuery(queryString: string, scopedVars?: ScopedVars) {\n    return this.templateSrv.replace(queryString, scopedVars, 'lucene');\n  }\n\n  interpolateVariablesInQueries(queries: ElasticsearchQuery[], scopedVars: ScopedVars): ElasticsearchQuery[] {\n    // We need a separate interpolation format for lucene queries, therefore we first interpolate any\n    // lucene query string and then everything else\n    const interpolateBucketAgg = (bucketAgg: BucketAggregation): BucketAggregation => {\n      if (bucketAgg.type === 'filters') {\n        return {\n          ...bucketAgg,\n          settings: {\n            ...bucketAgg.settings,\n            filters: bucketAgg.settings?.filters?.map((filter) => ({\n              ...filter,\n              query: this.interpolateLuceneQuery(filter.query, scopedVars) || '*',\n            })),\n          },\n        };\n      }\n\n      return bucketAgg;\n    };\n\n    const expandedQueries = queries.map(\n      (query): ElasticsearchQuery => ({\n        ...query,\n        datasource: this.getRef(),\n        query: this.interpolateLuceneQuery(query.query || '', scopedVars),\n        bucketAggs: query.bucketAggs?.map(interpolateBucketAgg),\n      })\n    );\n\n    const finalQueries: ElasticsearchQuery[] = JSON.parse(\n      this.templateSrv.replace(JSON.stringify(expandedQueries), scopedVars)\n    );\n\n    return finalQueries;\n  }\n\n  testDatasource() {\n    // validate that the index exist and has date field\n    return lastValueFrom(\n      this.getFields(['date']).pipe(\n        mergeMap((dateFields) => {\n          const timeField: any = find(dateFields, { text: this.timeField });\n          if (!timeField) {\n            return of({ status: 'error', message: 'No date field named ' + this.timeField + ' found' });\n          }\n          return of({ status: 'success', message: 'Index OK. Time field name OK.' });\n        }),\n        catchError((err) => {\n          console.error(err);\n          if (err.message) {\n            return of({ status: 'error', message: err.message });\n          } else {\n            return of({ status: 'error', message: err.status });\n          }\n        })\n      )\n    );\n  }\n\n  getQueryHeader(searchType: any, timeFrom?: DateTime, timeTo?: DateTime): string {\n    const queryHeader: any = {\n      search_type: searchType,\n      ignore_unavailable: true,\n      index: this.indexPattern.getIndexList(timeFrom, timeTo),\n    };\n\n    if (satisfies(this.esVersion, '>=5.6.0 <7.0.0')) {\n      queryHeader['max_concurrent_shard_requests'] = this.maxConcurrentShardRequests;\n    }\n\n    return JSON.stringify(queryHeader);\n  }\n\n  getQueryDisplayText(query: ElasticsearchQuery) {\n    // TODO: This might be refactored a bit.\n    const metricAggs = query.metrics;\n    const bucketAggs = query.bucketAggs;\n    let text = '';\n\n    if (query.query) {\n      text += 'Query: ' + query.query + ', ';\n    }\n\n    text += 'Metrics: ';\n\n    text += metricAggs?.reduce((acc, metric) => {\n      const metricConfig = metricAggregationConfig[metric.type];\n\n      let text = metricConfig.label + '(';\n\n      if (isMetricAggregationWithField(metric)) {\n        text += metric.field;\n      }\n      if (isPipelineAggregationWithMultipleBucketPaths(metric)) {\n        text += getScriptValue(metric).replace(new RegExp('params.', 'g'), '');\n      }\n      text += '), ';\n\n      return `${acc} ${text}`;\n    }, '');\n\n    text += bucketAggs?.reduce((acc, bucketAgg, index) => {\n      const bucketConfig = bucketAggregationConfig[bucketAgg.type];\n\n      let text = '';\n      if (index === 0) {\n        text += ' Group by: ';\n      }\n\n      text += bucketConfig.label + '(';\n      if (isBucketAggregationWithField(bucketAgg)) {\n        text += bucketAgg.field;\n      }\n\n      return `${acc} ${text}), `;\n    }, '');\n\n    if (query.alias) {\n      text += 'Alias: ' + query.alias;\n    }\n\n    return text;\n  }\n\n  /**\n   * This method checks to ensure the user is running a 5.0+ cluster. This is\n   * necessary bacause the query being used for the getLogRowContext relies on the\n   * search_after feature.\n   */\n  showContextToggle(): boolean {\n    return gte(this.esVersion, '5.0.0');\n  }\n\n  getLogRowContext = async (row: LogRowModel, options?: RowContextOptions): Promise<{ data: DataFrame[] }> => {\n    const sortField = row.dataFrame.fields.find((f) => f.name === 'sort');\n    const searchAfter = sortField?.values.get(row.rowIndex) || [row.timeEpochMs];\n    const sort = options?.direction === 'FORWARD' ? 'asc' : 'desc';\n\n    const header =\n      options?.direction === 'FORWARD'\n        ? this.getQueryHeader('query_then_fetch', dateTime(row.timeEpochMs))\n        : this.getQueryHeader('query_then_fetch', undefined, dateTime(row.timeEpochMs));\n\n    const limit = options?.limit ?? 10;\n    const esQuery = JSON.stringify({\n      size: limit,\n      query: {\n        bool: {\n          filter: [\n            {\n              range: {\n                [this.timeField]: {\n                  [options?.direction === 'FORWARD' ? 'gte' : 'lte']: row.timeEpochMs,\n                  format: 'epoch_millis',\n                },\n              },\n            },\n          ],\n        },\n      },\n      sort: [{ [this.timeField]: sort }, { _doc: sort }],\n      search_after: searchAfter,\n    });\n    const payload = [header, esQuery].join('\\n') + '\\n';\n    const url = this.getMultiSearchUrl();\n    const response = await lastValueFrom(this.post(url, payload));\n    const targets: ElasticsearchQuery[] = [{ refId: `${row.dataFrame.refId}`, metrics: [{ type: 'logs', id: '1' }] }];\n    const elasticResponse = new ElasticResponse(targets, transformHitsBasedOnDirection(response, sort));\n    const logResponse = elasticResponse.getLogs(this.logMessageField, this.logLevelField);\n    const dataFrame = _first(logResponse.data);\n    if (!dataFrame) {\n      return { data: [] };\n    }\n    /**\n     * The LogRowContextProvider requires there is a field in the dataFrame.fields\n     * named `ts` for timestamp and `line` for the actual log line to display.\n     * Unfortunatly these fields are hardcoded and are required for the lines to\n     * be properly displayed. This code just copies the fields based on this.timeField\n     * and this.logMessageField and recreates the dataFrame so it works.\n     */\n    const timestampField = dataFrame.fields.find((f: Field) => f.name === this.timeField);\n    const lineField = dataFrame.fields.find((f: Field) => f.name === this.logMessageField);\n    if (timestampField && lineField) {\n      return {\n        data: [\n          {\n            ...dataFrame,\n            fields: [...dataFrame.fields, { ...timestampField, name: 'ts' }, { ...lineField, name: 'line' }],\n          },\n        ],\n      };\n    }\n    return logResponse;\n  };\n\n  getLogsVolumeDataProvider(request: DataQueryRequest<ElasticsearchQuery>): Observable<DataQueryResponse> | undefined {\n    const isLogsVolumeAvailable = request.targets.some((target) => {\n      return target.metrics?.length === 1 && target.metrics[0].type === 'logs';\n    });\n    if (!isLogsVolumeAvailable) {\n      return undefined;\n    }\n    const logsVolumeRequest = cloneDeep(request);\n    logsVolumeRequest.targets = logsVolumeRequest.targets.map((target) => {\n      const bucketAggs: BucketAggregation[] = [];\n      const timeField = this.timeField ?? '@timestamp';\n\n      if (this.logLevelField) {\n        bucketAggs.push({\n          id: '2',\n          type: 'terms',\n          settings: {\n            min_doc_count: '0',\n            size: '0',\n            order: 'desc',\n            orderBy: '_count',\n            missing: LogLevel.unknown,\n          },\n          field: this.logLevelField,\n        });\n      }\n      bucketAggs.push({\n        id: '3',\n        type: 'date_histogram',\n        settings: {\n          interval: 'auto',\n          min_doc_count: '0',\n          trimEdges: '0',\n        },\n        field: timeField,\n      });\n\n      const logsVolumeQuery: ElasticsearchQuery = {\n        refId: target.refId,\n        query: target.query,\n        metrics: [{ type: 'count', id: '1' }],\n        timeField,\n        bucketAggs,\n      };\n      return logsVolumeQuery;\n    });\n\n    return queryLogsVolume(this, logsVolumeRequest, {\n      range: request.range,\n      targets: request.targets,\n      extractLevel: (dataFrame) => getLogLevelFromKey(dataFrame.name || ''),\n    });\n  }\n\n  query(options: DataQueryRequest<ElasticsearchQuery>): Observable<DataQueryResponse> {\n    let payload = '';\n    const targets = this.interpolateVariablesInQueries(cloneDeep(options.targets), options.scopedVars);\n    const sentTargets: ElasticsearchQuery[] = [];\n    let targetsContainsLogsQuery = targets.some((target) => hasMetricOfType(target, 'logs'));\n\n    // add global adhoc filters to timeFilter\n    const adhocFilters = this.templateSrv.getAdhocFilters(this.name);\n\n    const logLimits: Array<number | undefined> = [];\n\n    for (const target of targets) {\n      if (target.hide) {\n        continue;\n      }\n\n      let queryObj;\n      if (hasMetricOfType(target, 'logs')) {\n        // FIXME: All this logic here should be in the query builder.\n        // When moving to the BE-only implementation we should remove this and let the BE\n        // Handle this.\n        // TODO: defaultBucketAgg creates a dete_histogram aggregation without a field, so it fallbacks to\n        // the configured timeField. we should allow people to use a different time field here.\n        target.bucketAggs = [defaultBucketAgg()];\n\n        const log = target.metrics?.find((m) => m.type === 'logs') as Logs;\n        const limit = log.settings?.limit ? parseInt(log.settings?.limit, 10) : 500;\n        logLimits.push(limit);\n\n        target.metrics = [];\n        // Setting this for metrics queries that are typed as logs\n        queryObj = this.queryBuilder.getLogsQuery(target, limit, adhocFilters);\n      } else {\n        logLimits.push();\n        if (target.alias) {\n          target.alias = this.interpolateLuceneQuery(target.alias, options.scopedVars);\n        }\n\n        queryObj = this.queryBuilder.build(target, adhocFilters);\n      }\n\n      const esQuery = JSON.stringify(queryObj);\n\n      const searchType = queryObj.size === 0 && lt(this.esVersion, '5.0.0') ? 'count' : 'query_then_fetch';\n      const header = this.getQueryHeader(searchType, options.range.from, options.range.to);\n      payload += header + '\\n';\n\n      payload += esQuery + '\\n';\n\n      sentTargets.push(target);\n    }\n\n    if (sentTargets.length === 0) {\n      return of({ data: [] });\n    }\n\n    // We replace the range here for actual values. We need to replace it together with enclosing \"\" so that we replace\n    // it as an integer not as string with digits. This is because elastic will convert the string only if the time\n    // field is specified as type date (which probably should) but can also be specified as integer (millisecond epoch)\n    // and then sending string will error out.\n    payload = payload.replace(/\"\\$timeFrom\"/g, options.range.from.valueOf().toString());\n    payload = payload.replace(/\"\\$timeTo\"/g, options.range.to.valueOf().toString());\n    payload = this.templateSrv.replace(payload, options.scopedVars);\n\n    const url = this.getMultiSearchUrl();\n\n    return this.post(url, payload).pipe(\n      map((res) => {\n        const er = new ElasticResponse(sentTargets, res);\n\n        // TODO: This needs to be revisited, it seems wrong to process ALL the sent queries as logs if only one of them was a log query\n        if (targetsContainsLogsQuery) {\n          const response = er.getLogs(this.logMessageField, this.logLevelField);\n\n          response.data.forEach((dataFrame, index) => {\n            enhanceDataFrame(dataFrame, this.dataLinks, logLimits[index]);\n          });\n          return response;\n        }\n\n        return er.getTimeSeries();\n      })\n    );\n  }\n\n  isMetadataField(fieldName: string) {\n    return ELASTIC_META_FIELDS.includes(fieldName);\n  }\n\n  // TODO: instead of being a string, this could be a custom type representing all the elastic types\n  // FIXME: This doesn't seem to return actual MetricFindValues, we should either change the return type\n  // or fix the implementation.\n  getFields(type?: string[], range?: TimeRange): Observable<MetricFindValue[]> {\n    const typeMap: Record<string, string> = {\n      float: 'number',\n      double: 'number',\n      integer: 'number',\n      long: 'number',\n      date: 'date',\n      date_nanos: 'date',\n      string: 'string',\n      text: 'string',\n      scaled_float: 'number',\n      nested: 'nested',\n      histogram: 'number',\n    };\n    return this.get('/_mapping', range).pipe(\n      map((result) => {\n        const shouldAddField = (obj: any, key: string) => {\n          if (this.isMetadataField(key)) {\n            return false;\n          }\n\n          if (!type || type.length === 0) {\n            return true;\n          }\n\n          // equal query type filter, or via typemap translation\n          return type.includes(obj.type) || type.includes(typeMap[obj.type]);\n        };\n\n        // Store subfield names: [system, process, cpu, total] -> system.process.cpu.total\n        const fieldNameParts: any = [];\n        const fields: any = {};\n\n        function getFieldsRecursively(obj: any) {\n          for (const key in obj) {\n            const subObj = obj[key];\n\n            // Check mapping field for nested fields\n            if (isObject(subObj.properties)) {\n              fieldNameParts.push(key);\n              getFieldsRecursively(subObj.properties);\n            }\n\n            if (isObject(subObj.fields)) {\n              fieldNameParts.push(key);\n              getFieldsRecursively(subObj.fields);\n            }\n\n            if (isString(subObj.type)) {\n              const fieldName = fieldNameParts.concat(key).join('.');\n\n              // Hide meta-fields and check field type\n              if (shouldAddField(subObj, key)) {\n                fields[fieldName] = {\n                  text: fieldName,\n                  type: subObj.type,\n                };\n              }\n            }\n          }\n          fieldNameParts.pop();\n        }\n\n        for (const indexName in result) {\n          const index = result[indexName];\n          if (index && index.mappings) {\n            const mappings = index.mappings;\n\n            if (lt(this.esVersion, '7.0.0')) {\n              for (const typeName in mappings) {\n                const properties = mappings[typeName].properties;\n                getFieldsRecursively(properties);\n              }\n            } else {\n              const properties = mappings.properties;\n              getFieldsRecursively(properties);\n            }\n          }\n        }\n\n        // transform to array\n        return _map(fields, (value) => {\n          return value;\n        });\n      })\n    );\n  }\n\n  getTerms(queryDef: TermsQuery, range = getDefaultTimeRange()): Observable<MetricFindValue[]> {\n    const searchType = gte(this.esVersion, '5.0.0') ? 'query_then_fetch' : 'count';\n    const header = this.getQueryHeader(searchType, range.from, range.to);\n    let esQuery = JSON.stringify(this.queryBuilder.getTermsQuery(queryDef));\n\n    esQuery = esQuery.replace(/\\$timeFrom/g, range.from.valueOf().toString());\n    esQuery = esQuery.replace(/\\$timeTo/g, range.to.valueOf().toString());\n    esQuery = header + '\\n' + esQuery + '\\n';\n\n    const url = this.getMultiSearchUrl();\n\n    return this.post(url, esQuery).pipe(\n      map((res) => {\n        if (!res.responses[0].aggregations) {\n          return [];\n        }\n\n        const buckets = res.responses[0].aggregations['1'].buckets;\n        return _map(buckets, (bucket) => {\n          return {\n            text: bucket.key_as_string || bucket.key,\n            value: bucket.key,\n          };\n        });\n      })\n    );\n  }\n\n  getMultiSearchUrl() {\n    const searchParams = new URLSearchParams();\n\n    if (gte(this.esVersion, '7.0.0') && this.maxConcurrentShardRequests) {\n      searchParams.append('max_concurrent_shard_requests', `${this.maxConcurrentShardRequests}`);\n    }\n\n    if (gte(this.esVersion, '6.6.0') && this.xpack && this.includeFrozen) {\n      searchParams.append('ignore_throttled', 'false');\n    }\n\n    return ('_msearch?' + searchParams.toString()).replace(/\\?$/, '');\n  }\n\n  metricFindQuery(query: string, options?: any): Promise<MetricFindValue[]> {\n    const range = options?.range;\n    const parsedQuery = JSON.parse(query);\n    if (query) {\n      if (parsedQuery.find === 'fields') {\n        parsedQuery.type = this.interpolateLuceneQuery(parsedQuery.type);\n        return lastValueFrom(this.getFields(parsedQuery.type, range));\n      }\n\n      if (parsedQuery.find === 'terms') {\n        parsedQuery.field = this.interpolateLuceneQuery(parsedQuery.field);\n        parsedQuery.query = this.interpolateLuceneQuery(parsedQuery.query);\n        return lastValueFrom(this.getTerms(parsedQuery, range));\n      }\n    }\n\n    return Promise.resolve([]);\n  }\n\n  getTagKeys() {\n    return lastValueFrom(this.getFields());\n  }\n\n  getTagValues(options: any) {\n    return lastValueFrom(this.getTerms({ field: options.key }));\n  }\n\n  targetContainsTemplate(target: any) {\n    if (this.templateSrv.containsTemplate(target.query) || this.templateSrv.containsTemplate(target.alias)) {\n      return true;\n    }\n\n    for (const bucketAgg of target.bucketAggs) {\n      if (this.templateSrv.containsTemplate(bucketAgg.field) || this.objectContainsTemplate(bucketAgg.settings)) {\n        return true;\n      }\n    }\n\n    for (const metric of target.metrics) {\n      if (\n        this.templateSrv.containsTemplate(metric.field) ||\n        this.objectContainsTemplate(metric.settings) ||\n        this.objectContainsTemplate(metric.meta)\n      ) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private isPrimitive(obj: any) {\n    if (obj === null || obj === undefined) {\n      return true;\n    }\n    if (['string', 'number', 'boolean'].some((type) => type === typeof true)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  private objectContainsTemplate(obj: any) {\n    if (!obj) {\n      return false;\n    }\n\n    for (const key of Object.keys(obj)) {\n      if (this.isPrimitive(obj[key])) {\n        if (this.templateSrv.containsTemplate(obj[key])) {\n          return true;\n        }\n      } else if (Array.isArray(obj[key])) {\n        for (const item of obj[key]) {\n          if (this.objectContainsTemplate(item)) {\n            return true;\n          }\n        }\n      } else {\n        if (this.objectContainsTemplate(obj[key])) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n}\n\n/**\n * Modifies dataframe and adds dataLinks from the config.\n * Exported for tests.\n */\nexport function enhanceDataFrame(dataFrame: DataFrame, dataLinks: DataLinkConfig[], limit?: number) {\n  if (limit) {\n    dataFrame.meta = {\n      ...dataFrame.meta,\n      limit,\n    };\n  }\n\n  if (!dataLinks.length) {\n    return;\n  }\n\n  for (const field of dataFrame.fields) {\n    const linksToApply = dataLinks.filter((dataLink) => new RegExp(dataLink.field).test(field.name));\n\n    if (linksToApply.length === 0) {\n      continue;\n    }\n\n    field.config = field.config || {};\n    field.config.links = [...(field.config.links || [], linksToApply.map(generateDataLink))];\n  }\n}\n\nfunction generateDataLink(linkConfig: DataLinkConfig): DataLink {\n  const dataSourceSrv = getDataSourceSrv();\n\n  if (linkConfig.datasourceUid) {\n    const dsSettings = dataSourceSrv.getInstanceSettings(linkConfig.datasourceUid);\n\n    return {\n      title: linkConfig.urlDisplayLabel || '',\n      url: '',\n      internal: {\n        query: { query: linkConfig.url },\n        datasourceUid: linkConfig.datasourceUid,\n        datasourceName: dsSettings?.name ?? 'Data source not found',\n      },\n    };\n  } else {\n    return {\n      title: linkConfig.urlDisplayLabel || '',\n      url: linkConfig.url,\n    };\n  }\n}\n\nfunction transformHitsBasedOnDirection(response: any, direction: 'asc' | 'desc') {\n  if (direction === 'desc') {\n    return response;\n  }\n  const actualResponse = response.responses[0];\n  return {\n    ...response,\n    responses: [\n      {\n        ...actualResponse,\n        hits: {\n          ...actualResponse.hits,\n          hits: actualResponse.hits.hits.reverse(),\n        },\n      },\n    ],\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}