{"ast":null,"code":"import { escapeLabelValueInExactSelector } from '../../../language_utils';\nimport { FUNCTIONS } from '../../../promql';\nimport { NeverCaseError } from './util'; // FIXME: we should not load this from the \"outside\", but we cannot do that while we have the \"old\" query-field too\n\n// we order items like: history, functions, metrics\nasync function getAllMetricNamesCompletions(dataProvider) {\n  const metrics = await dataProvider.getAllMetricNames();\n  return metrics.map(metric => ({\n    type: 'METRIC_NAME',\n    label: metric.name,\n    insertText: metric.name,\n    detail: `${metric.name} : ${metric.type}`,\n    documentation: metric.help\n  }));\n}\n\nconst FUNCTION_COMPLETIONS = FUNCTIONS.map(f => {\n  var _f$insertText;\n\n  return {\n    type: 'FUNCTION',\n    label: f.label,\n    insertText: (_f$insertText = f.insertText) !== null && _f$insertText !== void 0 ? _f$insertText : '',\n    // i don't know what to do when this is nullish. it should not be.\n    detail: f.detail,\n    documentation: f.documentation\n  };\n});\n\nasync function getAllFunctionsAndMetricNamesCompletions(dataProvider) {\n  const metricNames = await getAllMetricNamesCompletions(dataProvider);\n  return [...FUNCTION_COMPLETIONS, ...metricNames];\n}\n\nconst DURATION_COMPLETIONS = ['$__interval', '$__range', '$__rate_interval', '1m', '5m', '10m', '30m', '1h', '1d'].map(text => ({\n  type: 'DURATION',\n  label: text,\n  insertText: text\n}));\n\nasync function getAllHistoryCompletions(dataProvider) {\n  // function getAllHistoryCompletions(queryHistory: PromHistoryItem[]): Completion[] {\n  // NOTE: the typescript types are wrong. historyItem.query.expr can be undefined\n  const allHistory = await dataProvider.getHistory(); // FIXME: find a better history-limit\n\n  return allHistory.slice(0, 10).map(expr => ({\n    type: 'HISTORY',\n    label: expr,\n    insertText: expr\n  }));\n}\n\nfunction makeSelector(metricName, labels) {\n  const allLabels = [...labels]; // we transform the metricName to a label, if it exists\n\n  if (metricName !== undefined) {\n    allLabels.push({\n      name: '__name__',\n      value: metricName,\n      op: '='\n    });\n  }\n\n  const allLabelTexts = allLabels.map(label => `${label.name}${label.op}\"${escapeLabelValueInExactSelector(label.value)}\"`);\n  return `{${allLabelTexts.join(',')}}`;\n}\n\nasync function getLabelNames(metric, otherLabels, dataProvider) {\n  if (metric === undefined && otherLabels.length === 0) {\n    // if there is no filtering, we have to use a special endpoint\n    return dataProvider.getAllLabelNames();\n  } else {\n    const selector = makeSelector(metric, otherLabels);\n    const data = await dataProvider.getSeries(selector);\n    const possibleLabelNames = Object.keys(data); // all names from prometheus\n\n    const usedLabelNames = new Set(otherLabels.map(l => l.name)); // names used in the query\n\n    return possibleLabelNames.filter(l => !usedLabelNames.has(l));\n  }\n}\n\nasync function getLabelNamesForCompletions(metric, suffix, triggerOnInsert, otherLabels, dataProvider) {\n  const labelNames = await getLabelNames(metric, otherLabels, dataProvider);\n  return labelNames.map(text => ({\n    type: 'LABEL_NAME',\n    label: text,\n    insertText: `${text}${suffix}`,\n    triggerOnInsert\n  }));\n}\n\nasync function getLabelNamesForSelectorCompletions(metric, otherLabels, dataProvider) {\n  return getLabelNamesForCompletions(metric, '=', true, otherLabels, dataProvider);\n}\n\nasync function getLabelNamesForByCompletions(metric, otherLabels, dataProvider) {\n  return getLabelNamesForCompletions(metric, '', false, otherLabels, dataProvider);\n}\n\nasync function getLabelValues(metric, labelName, otherLabels, dataProvider) {\n  if (metric === undefined && otherLabels.length === 0) {\n    // if there is no filtering, we have to use a special endpoint\n    return dataProvider.getLabelValues(labelName);\n  } else {\n    var _data$labelName;\n\n    const selector = makeSelector(metric, otherLabels);\n    const data = await dataProvider.getSeries(selector);\n    return (_data$labelName = data[labelName]) !== null && _data$labelName !== void 0 ? _data$labelName : [];\n  }\n}\n\nasync function getLabelValuesForMetricCompletions(metric, labelName, betweenQuotes, otherLabels, dataProvider) {\n  const values = await getLabelValues(metric, labelName, otherLabels, dataProvider);\n  return values.map(text => ({\n    type: 'LABEL_VALUE',\n    label: text,\n    insertText: betweenQuotes ? text : `\"${text}\"` // FIXME: escaping strange characters?\n\n  }));\n}\n\nexport async function getCompletions(situation, dataProvider) {\n  switch (situation.type) {\n    case 'IN_DURATION':\n      return DURATION_COMPLETIONS;\n\n    case 'IN_FUNCTION':\n      return getAllFunctionsAndMetricNamesCompletions(dataProvider);\n\n    case 'AT_ROOT':\n      {\n        return getAllFunctionsAndMetricNamesCompletions(dataProvider);\n      }\n\n    case 'EMPTY':\n      {\n        const metricNames = await getAllMetricNamesCompletions(dataProvider);\n        const historyCompletions = await getAllHistoryCompletions(dataProvider);\n        return [...historyCompletions, ...FUNCTION_COMPLETIONS, ...metricNames];\n      }\n\n    case 'IN_LABEL_SELECTOR_NO_LABEL_NAME':\n      return getLabelNamesForSelectorCompletions(situation.metricName, situation.otherLabels, dataProvider);\n\n    case 'IN_GROUPING':\n      return getLabelNamesForByCompletions(situation.metricName, situation.otherLabels, dataProvider);\n\n    case 'IN_LABEL_SELECTOR_WITH_LABEL_NAME':\n      return getLabelValuesForMetricCompletions(situation.metricName, situation.labelName, situation.betweenQuotes, situation.otherLabels, dataProvider);\n\n    default:\n      throw new NeverCaseError(situation);\n  }\n}","map":{"version":3,"names":["escapeLabelValueInExactSelector","FUNCTIONS","NeverCaseError","getAllMetricNamesCompletions","dataProvider","metrics","getAllMetricNames","map","metric","type","label","name","insertText","detail","documentation","help","FUNCTION_COMPLETIONS","f","getAllFunctionsAndMetricNamesCompletions","metricNames","DURATION_COMPLETIONS","text","getAllHistoryCompletions","allHistory","getHistory","slice","expr","makeSelector","metricName","labels","allLabels","undefined","push","value","op","allLabelTexts","join","getLabelNames","otherLabels","length","getAllLabelNames","selector","data","getSeries","possibleLabelNames","Object","keys","usedLabelNames","Set","l","filter","has","getLabelNamesForCompletions","suffix","triggerOnInsert","labelNames","getLabelNamesForSelectorCompletions","getLabelNamesForByCompletions","getLabelValues","labelName","getLabelValuesForMetricCompletions","betweenQuotes","values","getCompletions","situation","historyCompletions"],"sources":["/home/soula/grafana/public/app/plugins/datasource/prometheus/components/monaco-query-field/monaco-completion-provider/completions.ts"],"sourcesContent":["import { escapeLabelValueInExactSelector } from '../../../language_utils';\nimport { FUNCTIONS } from '../../../promql';\n\nimport type { Situation, Label } from './situation';\nimport { NeverCaseError } from './util';\n// FIXME: we should not load this from the \"outside\", but we cannot do that while we have the \"old\" query-field too\n\nexport type CompletionType = 'HISTORY' | 'FUNCTION' | 'METRIC_NAME' | 'DURATION' | 'LABEL_NAME' | 'LABEL_VALUE';\n\ntype Completion = {\n  type: CompletionType;\n  label: string;\n  insertText: string;\n  detail?: string;\n  documentation?: string;\n  triggerOnInsert?: boolean;\n};\n\ntype Metric = {\n  name: string;\n  help: string;\n  type: string;\n};\n\nexport type DataProvider = {\n  getHistory: () => Promise<string[]>;\n  getAllMetricNames: () => Promise<Metric[]>;\n  getAllLabelNames: () => Promise<string[]>;\n  getLabelValues: (labelName: string) => Promise<string[]>;\n  getSeries: (selector: string) => Promise<Record<string, string[]>>;\n};\n\n// we order items like: history, functions, metrics\n\nasync function getAllMetricNamesCompletions(dataProvider: DataProvider): Promise<Completion[]> {\n  const metrics = await dataProvider.getAllMetricNames();\n  return metrics.map((metric) => ({\n    type: 'METRIC_NAME',\n    label: metric.name,\n    insertText: metric.name,\n    detail: `${metric.name} : ${metric.type}`,\n    documentation: metric.help,\n  }));\n}\n\nconst FUNCTION_COMPLETIONS: Completion[] = FUNCTIONS.map((f) => ({\n  type: 'FUNCTION',\n  label: f.label,\n  insertText: f.insertText ?? '', // i don't know what to do when this is nullish. it should not be.\n  detail: f.detail,\n  documentation: f.documentation,\n}));\n\nasync function getAllFunctionsAndMetricNamesCompletions(dataProvider: DataProvider): Promise<Completion[]> {\n  const metricNames = await getAllMetricNamesCompletions(dataProvider);\n  return [...FUNCTION_COMPLETIONS, ...metricNames];\n}\n\nconst DURATION_COMPLETIONS: Completion[] = [\n  '$__interval',\n  '$__range',\n  '$__rate_interval',\n  '1m',\n  '5m',\n  '10m',\n  '30m',\n  '1h',\n  '1d',\n].map((text) => ({\n  type: 'DURATION',\n  label: text,\n  insertText: text,\n}));\n\nasync function getAllHistoryCompletions(dataProvider: DataProvider): Promise<Completion[]> {\n  // function getAllHistoryCompletions(queryHistory: PromHistoryItem[]): Completion[] {\n  // NOTE: the typescript types are wrong. historyItem.query.expr can be undefined\n  const allHistory = await dataProvider.getHistory();\n  // FIXME: find a better history-limit\n  return allHistory.slice(0, 10).map((expr) => ({\n    type: 'HISTORY',\n    label: expr,\n    insertText: expr,\n  }));\n}\n\nfunction makeSelector(metricName: string | undefined, labels: Label[]): string {\n  const allLabels = [...labels];\n\n  // we transform the metricName to a label, if it exists\n  if (metricName !== undefined) {\n    allLabels.push({ name: '__name__', value: metricName, op: '=' });\n  }\n\n  const allLabelTexts = allLabels.map(\n    (label) => `${label.name}${label.op}\"${escapeLabelValueInExactSelector(label.value)}\"`\n  );\n\n  return `{${allLabelTexts.join(',')}}`;\n}\n\nasync function getLabelNames(\n  metric: string | undefined,\n  otherLabels: Label[],\n  dataProvider: DataProvider\n): Promise<string[]> {\n  if (metric === undefined && otherLabels.length === 0) {\n    // if there is no filtering, we have to use a special endpoint\n    return dataProvider.getAllLabelNames();\n  } else {\n    const selector = makeSelector(metric, otherLabels);\n    const data = await dataProvider.getSeries(selector);\n    const possibleLabelNames = Object.keys(data); // all names from prometheus\n    const usedLabelNames = new Set(otherLabels.map((l) => l.name)); // names used in the query\n    return possibleLabelNames.filter((l) => !usedLabelNames.has(l));\n  }\n}\n\nasync function getLabelNamesForCompletions(\n  metric: string | undefined,\n  suffix: string,\n  triggerOnInsert: boolean,\n  otherLabels: Label[],\n  dataProvider: DataProvider\n): Promise<Completion[]> {\n  const labelNames = await getLabelNames(metric, otherLabels, dataProvider);\n  return labelNames.map((text) => ({\n    type: 'LABEL_NAME',\n    label: text,\n    insertText: `${text}${suffix}`,\n    triggerOnInsert,\n  }));\n}\n\nasync function getLabelNamesForSelectorCompletions(\n  metric: string | undefined,\n  otherLabels: Label[],\n  dataProvider: DataProvider\n): Promise<Completion[]> {\n  return getLabelNamesForCompletions(metric, '=', true, otherLabels, dataProvider);\n}\nasync function getLabelNamesForByCompletions(\n  metric: string | undefined,\n  otherLabels: Label[],\n  dataProvider: DataProvider\n): Promise<Completion[]> {\n  return getLabelNamesForCompletions(metric, '', false, otherLabels, dataProvider);\n}\n\nasync function getLabelValues(\n  metric: string | undefined,\n  labelName: string,\n  otherLabels: Label[],\n  dataProvider: DataProvider\n): Promise<string[]> {\n  if (metric === undefined && otherLabels.length === 0) {\n    // if there is no filtering, we have to use a special endpoint\n    return dataProvider.getLabelValues(labelName);\n  } else {\n    const selector = makeSelector(metric, otherLabels);\n    const data = await dataProvider.getSeries(selector);\n    return data[labelName] ?? [];\n  }\n}\n\nasync function getLabelValuesForMetricCompletions(\n  metric: string | undefined,\n  labelName: string,\n  betweenQuotes: boolean,\n  otherLabels: Label[],\n  dataProvider: DataProvider\n): Promise<Completion[]> {\n  const values = await getLabelValues(metric, labelName, otherLabels, dataProvider);\n  return values.map((text) => ({\n    type: 'LABEL_VALUE',\n    label: text,\n    insertText: betweenQuotes ? text : `\"${text}\"`, // FIXME: escaping strange characters?\n  }));\n}\n\nexport async function getCompletions(situation: Situation, dataProvider: DataProvider): Promise<Completion[]> {\n  switch (situation.type) {\n    case 'IN_DURATION':\n      return DURATION_COMPLETIONS;\n    case 'IN_FUNCTION':\n      return getAllFunctionsAndMetricNamesCompletions(dataProvider);\n    case 'AT_ROOT': {\n      return getAllFunctionsAndMetricNamesCompletions(dataProvider);\n    }\n    case 'EMPTY': {\n      const metricNames = await getAllMetricNamesCompletions(dataProvider);\n      const historyCompletions = await getAllHistoryCompletions(dataProvider);\n      return [...historyCompletions, ...FUNCTION_COMPLETIONS, ...metricNames];\n    }\n    case 'IN_LABEL_SELECTOR_NO_LABEL_NAME':\n      return getLabelNamesForSelectorCompletions(situation.metricName, situation.otherLabels, dataProvider);\n    case 'IN_GROUPING':\n      return getLabelNamesForByCompletions(situation.metricName, situation.otherLabels, dataProvider);\n    case 'IN_LABEL_SELECTOR_WITH_LABEL_NAME':\n      return getLabelValuesForMetricCompletions(\n        situation.metricName,\n        situation.labelName,\n        situation.betweenQuotes,\n        situation.otherLabels,\n        dataProvider\n      );\n    default:\n      throw new NeverCaseError(situation);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}