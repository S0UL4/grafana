{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport Centrifuge from 'centrifuge/dist/centrifuge';\nimport { BehaviorSubject, share, startWith } from 'rxjs';\nimport { LiveChannelConnectionState, toLiveChannelId } from '@grafana/data';\nimport { StreamingFrameAction } from '@grafana/runtime/src/services/live';\nimport { LiveDataStream } from './LiveDataStream';\nimport { CentrifugeLiveChannel } from './channel';\nconst defaultStreamingFrameOptions = {\n  maxLength: 100,\n  maxDelta: Infinity,\n  action: StreamingFrameAction.Append\n};\nconst dataStreamShutdownDelayInMs = 5000;\nexport class CentrifugeService {\n  constructor(deps) {\n    _defineProperty(this, \"open\", new Map());\n\n    _defineProperty(this, \"liveDataStreamByChannelId\", {});\n\n    _defineProperty(this, \"centrifuge\", void 0);\n\n    _defineProperty(this, \"connectionState\", void 0);\n\n    _defineProperty(this, \"connectionBlocker\", void 0);\n\n    _defineProperty(this, \"dataStreamSubscriberReadiness\", void 0);\n\n    _defineProperty(this, \"onConnect\", context => {\n      this.connectionState.next(true);\n    });\n\n    _defineProperty(this, \"onDisconnect\", context => {\n      this.connectionState.next(false);\n    });\n\n    _defineProperty(this, \"onServerSideMessage\", context => {\n      console.log('Publication from server-side channel', context);\n    });\n\n    _defineProperty(this, \"getConnectionState\", () => {\n      return this.connectionState.asObservable();\n    });\n\n    _defineProperty(this, \"getStream\", address => {\n      return this.getChannel(address).getStream();\n    });\n\n    _defineProperty(this, \"createSubscriptionKey\", options => {\n      var _options$key;\n\n      return (_options$key = options.key) !== null && _options$key !== void 0 ? _options$key : `xstr/${streamCounter++}`;\n    });\n\n    _defineProperty(this, \"getLiveDataStream\", options => {\n      const channelId = toLiveChannelId(options.addr);\n      const existingStream = this.liveDataStreamByChannelId[channelId];\n\n      if (existingStream) {\n        return existingStream;\n      }\n\n      const channel = this.getChannel(options.addr);\n      this.liveDataStreamByChannelId[channelId] = new LiveDataStream({\n        channelId,\n        onShutdown: () => {\n          delete this.liveDataStreamByChannelId[channelId];\n        },\n        liveEventsObservable: channel.getStream(),\n        subscriberReadiness: this.dataStreamSubscriberReadiness,\n        defaultStreamingFrameOptions,\n        shutdownDelayInMs: dataStreamShutdownDelayInMs\n      });\n      return this.liveDataStreamByChannelId[channelId];\n    });\n\n    _defineProperty(this, \"getDataStream\", options => {\n      const subscriptionKey = this.createSubscriptionKey(options);\n      const stream = this.getLiveDataStream(options);\n      return stream.get(options, subscriptionKey);\n    });\n\n    _defineProperty(this, \"getQueryData\", async options => {\n      if (!this.centrifuge.isConnected()) {\n        await this.connectionBlocker;\n      }\n\n      return this.centrifuge.namedRPC('grafana.query', options.body);\n    });\n\n    _defineProperty(this, \"getPresence\", address => {\n      return this.getChannel(address).getPresence();\n    });\n\n    this.deps = deps;\n    this.dataStreamSubscriberReadiness = deps.dataStreamSubscriberReadiness.pipe(share(), startWith(true));\n    const liveUrl = `${deps.appUrl.replace(/^http/, 'ws')}/api/live/ws`;\n    this.centrifuge = new Centrifuge(liveUrl, {\n      timeout: 30000\n    });\n    this.centrifuge.setConnectData({\n      sessionId: deps.sessionId,\n      orgId: deps.orgId\n    }); // orgRole is set when logged in *or* anonomus users can use grafana\n\n    if (deps.liveEnabled && deps.orgRole !== '') {\n      this.centrifuge.connect(); // do connection\n    }\n\n    this.connectionState = new BehaviorSubject(this.centrifuge.isConnected());\n    this.connectionBlocker = new Promise(resolve => {\n      if (this.centrifuge.isConnected()) {\n        return resolve();\n      }\n\n      const connectListener = () => {\n        resolve();\n        this.centrifuge.removeListener('connect', connectListener);\n      };\n\n      this.centrifuge.addListener('connect', connectListener);\n    }); // Register global listeners\n\n    this.centrifuge.on('connect', this.onConnect);\n    this.centrifuge.on('disconnect', this.onDisconnect);\n    this.centrifuge.on('publish', this.onServerSideMessage);\n  } //----------------------------------------------------------\n  // Internal functions\n  //----------------------------------------------------------\n\n\n  /**\n   * Get a channel.  If the scope, namespace, or path is invalid, a shutdown\n   * channel will be returned with an error state indicated in its status\n   */\n  getChannel(addr) {\n    const id = `${this.deps.orgId}/${addr.scope}/${addr.namespace}/${addr.path}`;\n    let channel = this.open.get(id);\n\n    if (channel != null) {\n      return channel;\n    }\n\n    channel = new CentrifugeLiveChannel(id, addr);\n\n    if (channel.currentStatus.state === LiveChannelConnectionState.Invalid) {\n      return channel;\n    }\n\n    channel.shutdownCallback = () => {\n      this.open.delete(id); // remove it from the list of open channels\n    };\n\n    this.open.set(id, channel); // Initialize the channel in the background\n\n    this.initChannel(channel).catch(err => {\n      if (channel) {\n        channel.currentStatus.state = LiveChannelConnectionState.Invalid;\n        channel.shutdownWithError(err);\n      }\n\n      this.open.delete(id);\n    }); // return the not-yet initialized channel\n\n    return channel;\n  }\n\n  async initChannel(channel) {\n    const events = channel.initalize();\n\n    if (!this.centrifuge.isConnected()) {\n      await this.connectionBlocker;\n    }\n\n    channel.subscription = this.centrifuge.subscribe(channel.id, events, {\n      data: channel.addr.data\n    });\n    return;\n  } //----------------------------------------------------------\n  // Exported functions\n  //----------------------------------------------------------\n\n  /**\n   * Listen for changes to the connection state\n   */\n\n\n} // This is used to give a unique key for each stream.  The actual value does not matter\n\nlet streamCounter = 0;","map":{"version":3,"names":["Centrifuge","BehaviorSubject","share","startWith","LiveChannelConnectionState","toLiveChannelId","StreamingFrameAction","LiveDataStream","CentrifugeLiveChannel","defaultStreamingFrameOptions","maxLength","maxDelta","Infinity","action","Append","dataStreamShutdownDelayInMs","CentrifugeService","constructor","deps","Map","context","connectionState","next","console","log","asObservable","address","getChannel","getStream","options","key","streamCounter","channelId","addr","existingStream","liveDataStreamByChannelId","channel","onShutdown","liveEventsObservable","subscriberReadiness","dataStreamSubscriberReadiness","shutdownDelayInMs","subscriptionKey","createSubscriptionKey","stream","getLiveDataStream","get","centrifuge","isConnected","connectionBlocker","namedRPC","body","getPresence","pipe","liveUrl","appUrl","replace","timeout","setConnectData","sessionId","orgId","liveEnabled","orgRole","connect","Promise","resolve","connectListener","removeListener","addListener","on","onConnect","onDisconnect","onServerSideMessage","id","scope","namespace","path","open","currentStatus","state","Invalid","shutdownCallback","delete","set","initChannel","catch","err","shutdownWithError","events","initalize","subscription","subscribe","data"],"sources":["/home/soula/grafana/public/app/features/live/centrifuge/service.ts"],"sourcesContent":["import Centrifuge from 'centrifuge/dist/centrifuge';\nimport { BehaviorSubject, Observable, share, startWith } from 'rxjs';\n\nimport {\n  DataQueryError,\n  DataQueryResponse,\n  LiveChannelAddress,\n  LiveChannelConnectionState,\n  LiveChannelId,\n  toLiveChannelId,\n} from '@grafana/data';\nimport { FetchResponse } from '@grafana/runtime/src/services/backendSrv';\nimport {\n  GrafanaLiveSrv,\n  LiveDataStreamOptions,\n  LiveQueryDataOptions,\n  StreamingFrameAction,\n  StreamingFrameOptions,\n} from '@grafana/runtime/src/services/live';\nimport { BackendDataSourceResponse } from '@grafana/runtime/src/utils/queryResponse';\n\nimport { StreamingResponseData } from '../data/utils';\n\nimport { LiveDataStream } from './LiveDataStream';\nimport { CentrifugeLiveChannel } from './channel';\n\nexport type CentrifugeSrvDeps = {\n  appUrl: string;\n  orgId: number;\n  orgRole: string;\n  sessionId: string;\n  liveEnabled: boolean;\n  dataStreamSubscriberReadiness: Observable<boolean>;\n};\n\nexport type StreamingDataQueryResponse = Omit<DataQueryResponse, 'data'> & { data: [StreamingResponseData] };\n\nexport type CentrifugeSrv = Omit<GrafanaLiveSrv, 'publish' | 'getDataStream' | 'getQueryData'> & {\n  getDataStream: (options: LiveDataStreamOptions) => Observable<StreamingDataQueryResponse>;\n  getQueryData: (\n    options: LiveQueryDataOptions\n  ) => Promise<\n    | { data: BackendDataSourceResponse | undefined }\n    | FetchResponse<BackendDataSourceResponse | undefined>\n    | DataQueryError\n  >;\n};\n\nexport type DataStreamSubscriptionKey = string;\n\nconst defaultStreamingFrameOptions: Readonly<StreamingFrameOptions> = {\n  maxLength: 100,\n  maxDelta: Infinity,\n  action: StreamingFrameAction.Append,\n};\n\nconst dataStreamShutdownDelayInMs = 5000;\n\nexport class CentrifugeService implements CentrifugeSrv {\n  readonly open = new Map<string, CentrifugeLiveChannel>();\n  private readonly liveDataStreamByChannelId: Record<LiveChannelId, LiveDataStream> = {};\n  readonly centrifuge: Centrifuge;\n  readonly connectionState: BehaviorSubject<boolean>;\n  readonly connectionBlocker: Promise<void>;\n  private readonly dataStreamSubscriberReadiness: Observable<boolean>;\n\n  constructor(private deps: CentrifugeSrvDeps) {\n    this.dataStreamSubscriberReadiness = deps.dataStreamSubscriberReadiness.pipe(share(), startWith(true));\n    const liveUrl = `${deps.appUrl.replace(/^http/, 'ws')}/api/live/ws`;\n    this.centrifuge = new Centrifuge(liveUrl, {\n      timeout: 30000,\n    });\n    this.centrifuge.setConnectData({\n      sessionId: deps.sessionId,\n      orgId: deps.orgId,\n    });\n    // orgRole is set when logged in *or* anonomus users can use grafana\n    if (deps.liveEnabled && deps.orgRole !== '') {\n      this.centrifuge.connect(); // do connection\n    }\n    this.connectionState = new BehaviorSubject<boolean>(this.centrifuge.isConnected());\n    this.connectionBlocker = new Promise<void>((resolve) => {\n      if (this.centrifuge.isConnected()) {\n        return resolve();\n      }\n      const connectListener = () => {\n        resolve();\n        this.centrifuge.removeListener('connect', connectListener);\n      };\n      this.centrifuge.addListener('connect', connectListener);\n    });\n\n    // Register global listeners\n    this.centrifuge.on('connect', this.onConnect);\n    this.centrifuge.on('disconnect', this.onDisconnect);\n    this.centrifuge.on('publish', this.onServerSideMessage);\n  }\n\n  //----------------------------------------------------------\n  // Internal functions\n  //----------------------------------------------------------\n\n  private onConnect = (context: any) => {\n    this.connectionState.next(true);\n  };\n\n  private onDisconnect = (context: any) => {\n    this.connectionState.next(false);\n  };\n\n  private onServerSideMessage = (context: any) => {\n    console.log('Publication from server-side channel', context);\n  };\n\n  /**\n   * Get a channel.  If the scope, namespace, or path is invalid, a shutdown\n   * channel will be returned with an error state indicated in its status\n   */\n  private getChannel<TMessage>(addr: LiveChannelAddress): CentrifugeLiveChannel<TMessage> {\n    const id = `${this.deps.orgId}/${addr.scope}/${addr.namespace}/${addr.path}`;\n    let channel = this.open.get(id);\n    if (channel != null) {\n      return channel;\n    }\n\n    channel = new CentrifugeLiveChannel(id, addr);\n    if (channel.currentStatus.state === LiveChannelConnectionState.Invalid) {\n      return channel;\n    }\n    channel.shutdownCallback = () => {\n      this.open.delete(id); // remove it from the list of open channels\n    };\n    this.open.set(id, channel);\n\n    // Initialize the channel in the background\n    this.initChannel(channel).catch((err) => {\n      if (channel) {\n        channel.currentStatus.state = LiveChannelConnectionState.Invalid;\n        channel.shutdownWithError(err);\n      }\n      this.open.delete(id);\n    });\n\n    // return the not-yet initialized channel\n    return channel;\n  }\n\n  private async initChannel(channel: CentrifugeLiveChannel): Promise<void> {\n    const events = channel.initalize();\n    if (!this.centrifuge.isConnected()) {\n      await this.connectionBlocker;\n    }\n    channel.subscription = this.centrifuge.subscribe(channel.id, events, { data: channel.addr.data });\n    return;\n  }\n\n  //----------------------------------------------------------\n  // Exported functions\n  //----------------------------------------------------------\n\n  /**\n   * Listen for changes to the connection state\n   */\n  getConnectionState = () => {\n    return this.connectionState.asObservable();\n  };\n\n  /**\n   * Watch for messages in a channel\n   */\n  getStream: CentrifugeSrv['getStream'] = <T>(address: LiveChannelAddress) => {\n    return this.getChannel<T>(address).getStream();\n  };\n\n  private createSubscriptionKey = (options: LiveDataStreamOptions): DataStreamSubscriptionKey =>\n    options.key ?? `xstr/${streamCounter++}`;\n\n  private getLiveDataStream = (options: LiveDataStreamOptions): LiveDataStream => {\n    const channelId = toLiveChannelId(options.addr);\n    const existingStream = this.liveDataStreamByChannelId[channelId];\n\n    if (existingStream) {\n      return existingStream;\n    }\n\n    const channel = this.getChannel(options.addr);\n    this.liveDataStreamByChannelId[channelId] = new LiveDataStream({\n      channelId,\n      onShutdown: () => {\n        delete this.liveDataStreamByChannelId[channelId];\n      },\n      liveEventsObservable: channel.getStream(),\n      subscriberReadiness: this.dataStreamSubscriberReadiness,\n      defaultStreamingFrameOptions,\n      shutdownDelayInMs: dataStreamShutdownDelayInMs,\n    });\n    return this.liveDataStreamByChannelId[channelId];\n  };\n  /**\n   * Connect to a channel and return results as DataFrames\n   */\n  getDataStream: CentrifugeSrv['getDataStream'] = (options) => {\n    const subscriptionKey = this.createSubscriptionKey(options);\n\n    const stream = this.getLiveDataStream(options);\n    return stream.get(options, subscriptionKey);\n  };\n\n  /**\n   * Executes a query over the live websocket. Query response can contain live channels we can subscribe to for further updates\n   *\n   * Since the initial request and subscription are on the same socket, this will support HA setups\n   */\n  getQueryData: CentrifugeSrv['getQueryData'] = async (options) => {\n    if (!this.centrifuge.isConnected()) {\n      await this.connectionBlocker;\n    }\n    return this.centrifuge.namedRPC('grafana.query', options.body);\n  };\n\n  /**\n   * For channels that support presence, this will request the current state from the server.\n   *\n   * Join and leave messages will be sent to the open stream\n   */\n  getPresence: CentrifugeSrv['getPresence'] = (address) => {\n    return this.getChannel(address).getPresence();\n  };\n}\n\n// This is used to give a unique key for each stream.  The actual value does not matter\nlet streamCounter = 0;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}