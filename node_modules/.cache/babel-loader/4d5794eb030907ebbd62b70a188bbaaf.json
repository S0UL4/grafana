{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { compact, each, findIndex, flatten, get, join, keyBy, last, map, reduce, without } from 'lodash';\nimport { arrayMove } from 'app/core/utils/arrayMove';\nimport { Parser } from './parser';\nexport default class GraphiteQuery {\n  /** @ngInject */\n  constructor(datasource, target, templateSrv, scopedVars) {\n    _defineProperty(this, \"datasource\", void 0);\n\n    _defineProperty(this, \"target\", void 0);\n\n    _defineProperty(this, \"functions\", []);\n\n    _defineProperty(this, \"segments\", []);\n\n    _defineProperty(this, \"tags\", []);\n\n    _defineProperty(this, \"error\", void 0);\n\n    _defineProperty(this, \"seriesByTagUsed\", false);\n\n    _defineProperty(this, \"checkOtherSegmentsIndex\", 0);\n\n    _defineProperty(this, \"removeTagValue\", void 0);\n\n    _defineProperty(this, \"templateSrv\", void 0);\n\n    _defineProperty(this, \"scopedVars\", void 0);\n\n    this.datasource = datasource;\n    this.target = target;\n    this.templateSrv = templateSrv;\n    this.scopedVars = scopedVars;\n    this.parseTarget();\n    this.removeTagValue = '-- remove tag --';\n  }\n\n  parseTarget() {\n    this.functions = [];\n    this.segments = [];\n    this.tags = [];\n    this.seriesByTagUsed = false;\n    this.error = null;\n\n    if (this.target.textEditor) {\n      return;\n    }\n\n    const parser = new Parser(this.target.target);\n    const astNode = parser.getAst();\n\n    if (astNode === null) {\n      this.checkOtherSegmentsIndex = 0;\n      return;\n    }\n\n    if (astNode.type === 'error') {\n      this.error = astNode.message + ' at position: ' + astNode.pos;\n      this.target.textEditor = true;\n      return;\n    }\n\n    try {\n      this.parseTargetRecursive(astNode, null);\n    } catch (err) {\n      if (err instanceof Error) {\n        console.error('error parsing target:', err.message);\n        this.error = err.message;\n      }\n\n      this.target.textEditor = true;\n    }\n\n    this.checkOtherSegmentsIndex = this.segments.length - 1;\n  }\n\n  getSegmentPathUpTo(index) {\n    const arr = this.segments.slice(0, index);\n    return reduce(arr, (result, segment) => {\n      return result ? result + '.' + segment.value : segment.value;\n    }, '');\n  }\n\n  parseTargetRecursive(astNode, func) {\n    if (astNode === null) {\n      return null;\n    }\n\n    switch (astNode.type) {\n      case 'function':\n        const innerFunc = this.datasource.createFuncInstance(astNode.name, {\n          withDefaultParams: false\n        });\n        each(astNode.params, param => {\n          this.parseTargetRecursive(param, innerFunc);\n        });\n        innerFunc.updateText();\n        this.functions.push(innerFunc); // extract tags from seriesByTag function and hide function\n\n        if (innerFunc.def.name === 'seriesByTag' && !this.seriesByTagUsed) {\n          this.seriesByTagUsed = true;\n          innerFunc.hidden = true;\n          this.tags = this.splitSeriesByTagParams(innerFunc);\n        }\n\n        break;\n\n      case 'series-ref':\n        if (this.segments.length > 0 || this.getSeriesByTagFuncIndex() >= 0) {\n          this.addFunctionParameter(func, astNode.value);\n        } else {\n          this.segments.push(astNode);\n        }\n\n        break;\n\n      case 'bool':\n      case 'string':\n      case 'number':\n        this.addFunctionParameter(func, astNode.value);\n        break;\n\n      case 'metric':\n        if (this.segments.length || this.tags.length) {\n          this.addFunctionParameter(func, join(map(astNode.segments, 'value'), '.'));\n        } else {\n          this.segments = astNode.segments;\n        }\n\n        break;\n    }\n  }\n\n  updateSegmentValue(segment, index) {\n    this.segments[index].value = segment.value;\n  }\n\n  addSelectMetricSegment() {\n    this.segments.push({\n      value: 'select metric'\n    });\n  }\n\n  addFunction(newFunc) {\n    this.functions.push(newFunc);\n  }\n\n  addFunctionParameter(func, value) {\n    if (func.params.length >= func.def.params.length && !get(last(func.def.params), 'multiple', false)) {\n      throw {\n        message: 'too many parameters for function ' + func.def.name\n      };\n    }\n\n    func.params.push(value);\n  }\n\n  removeFunction(func) {\n    this.functions = without(this.functions, func);\n  }\n\n  moveFunction(func, offset) {\n    const index = this.functions.indexOf(func);\n    arrayMove(this.functions, index, index + offset);\n  }\n\n  updateModelTarget(targets) {\n    const wrapFunction = (target, func) => {\n      return func.render(target, value => {\n        return this.templateSrv.replace(value, this.scopedVars);\n      });\n    };\n\n    if (!this.target.textEditor) {\n      const metricPath = this.getSegmentPathUpTo(this.segments.length).replace(/\\.?select metric$/, '');\n      this.target.target = reduce(this.functions, wrapFunction, metricPath);\n    }\n\n    this.updateRenderedTarget(this.target, targets); // loop through other queries and update targetFull as needed\n\n    for (const target of targets || []) {\n      if (target.refId !== this.target.refId) {\n        this.updateRenderedTarget(target, targets);\n      }\n    } // clean-up added param\n\n\n    this.functions.forEach(func => func.added = false);\n  }\n\n  updateRenderedTarget(target, targets) {\n    // render nested query\n    const targetsByRefId = keyBy(targets, 'refId'); // no references to self\n\n    delete targetsByRefId[target.refId];\n    const nestedSeriesRefRegex = /\\#([A-Z])/g;\n    let targetWithNestedQueries = target.target; // Use ref count to track circular references\n\n    function countTargetRefs(targetsByRefId, refId) {\n      let refCount = 0;\n      each(targetsByRefId, (t, id) => {\n        if (id !== refId) {\n          const match = nestedSeriesRefRegex.exec(t.target);\n          const count = match && match.length ? match.length - 1 : 0;\n          refCount += count;\n        }\n      });\n      targetsByRefId[refId].refCount = refCount;\n    }\n\n    each(targetsByRefId, (t, id) => {\n      countTargetRefs(targetsByRefId, id);\n    }); // Keep interpolating until there are no query references\n    // The reason for the loop is that the referenced query might contain another reference to another query\n\n    while (targetWithNestedQueries.match(nestedSeriesRefRegex)) {\n      const updated = targetWithNestedQueries.replace(nestedSeriesRefRegex, (match, g1) => {\n        const t = targetsByRefId[g1];\n\n        if (!t) {\n          return match;\n        } // no circular references\n\n\n        if (t.refCount === 0) {\n          delete targetsByRefId[g1];\n        }\n\n        t.refCount--;\n        return t.target;\n      });\n\n      if (updated === targetWithNestedQueries) {\n        break;\n      }\n\n      targetWithNestedQueries = updated;\n    }\n\n    delete target.targetFull;\n\n    if (target.target !== targetWithNestedQueries) {\n      target.targetFull = targetWithNestedQueries;\n    }\n  }\n\n  splitSeriesByTagParams(func) {\n    const tagPattern = /([^\\!=~]+)(\\!?=~?)(.*)/;\n    return flatten(map(func.params, param => {\n      const matches = tagPattern.exec(param);\n\n      if (matches) {\n        const tag = matches.slice(1);\n\n        if (tag.length === 3) {\n          return {\n            key: tag[0],\n            operator: tag[1],\n            value: tag[2]\n          };\n        }\n      }\n\n      return [];\n    }));\n  }\n\n  getSeriesByTagFuncIndex() {\n    return findIndex(this.functions, func => func.def.name === 'seriesByTag');\n  }\n\n  getSeriesByTagFunc() {\n    const seriesByTagFuncIndex = this.getSeriesByTagFuncIndex();\n\n    if (seriesByTagFuncIndex >= 0) {\n      return this.functions[seriesByTagFuncIndex];\n    } else {\n      return undefined;\n    }\n  }\n\n  addTag(tag) {\n    const newTagParam = renderTagString(tag);\n    this.getSeriesByTagFunc().params.push(newTagParam);\n    this.tags.push(tag);\n  }\n\n  removeTag(index) {\n    this.getSeriesByTagFunc().params.splice(index, 1);\n    this.tags.splice(index, 1);\n  }\n\n  updateTag(tag, tagIndex) {\n    this.error = null;\n\n    if (tag.key === this.removeTagValue) {\n      this.removeTag(tagIndex);\n\n      if (this.tags.length === 0) {\n        this.removeFunction(this.getSeriesByTagFunc());\n        this.checkOtherSegmentsIndex = 0;\n        this.seriesByTagUsed = false;\n      }\n\n      return;\n    }\n\n    this.getSeriesByTagFunc().params[tagIndex] = renderTagString(tag);\n    this.tags[tagIndex] = tag;\n  }\n\n  renderTagExpressions(excludeIndex = -1) {\n    return compact(map(this.tags, (tagExpr, index) => {\n      // Don't render tag that we want to lookup\n      if (index !== excludeIndex) {\n        return tagExpr.key + tagExpr.operator + tagExpr.value;\n      } else {\n        return undefined;\n      }\n    }));\n  }\n\n}\nGraphiteQuery.$inject = [\"datasource\", \"target\", \"templateSrv\", \"scopedVars\"];\n\nfunction renderTagString(tag) {\n  return tag.key + tag.operator + tag.value;\n}","map":{"version":3,"names":["compact","each","findIndex","flatten","get","join","keyBy","last","map","reduce","without","arrayMove","Parser","GraphiteQuery","constructor","datasource","target","templateSrv","scopedVars","parseTarget","removeTagValue","functions","segments","tags","seriesByTagUsed","error","textEditor","parser","astNode","getAst","checkOtherSegmentsIndex","type","message","pos","parseTargetRecursive","err","Error","console","length","getSegmentPathUpTo","index","arr","slice","result","segment","value","func","innerFunc","createFuncInstance","name","withDefaultParams","params","param","updateText","push","def","hidden","splitSeriesByTagParams","getSeriesByTagFuncIndex","addFunctionParameter","updateSegmentValue","addSelectMetricSegment","addFunction","newFunc","removeFunction","moveFunction","offset","indexOf","updateModelTarget","targets","wrapFunction","render","replace","metricPath","updateRenderedTarget","refId","forEach","added","targetsByRefId","nestedSeriesRefRegex","targetWithNestedQueries","countTargetRefs","refCount","t","id","match","exec","count","updated","g1","targetFull","tagPattern","matches","tag","key","operator","getSeriesByTagFunc","seriesByTagFuncIndex","undefined","addTag","newTagParam","renderTagString","removeTag","splice","updateTag","tagIndex","renderTagExpressions","excludeIndex","tagExpr"],"sources":["/home/soula/grafana/public/app/plugins/datasource/graphite/graphite_query.ts"],"sourcesContent":["import { compact, each, findIndex, flatten, get, join, keyBy, last, map, reduce, without } from 'lodash';\n\nimport { ScopedVars } from '@grafana/data';\nimport { TemplateSrv } from '@grafana/runtime';\nimport { arrayMove } from 'app/core/utils/arrayMove';\n\nimport { GraphiteDatasource } from './datasource';\nimport { FuncInstance } from './gfunc';\nimport { Parser } from './parser';\nimport { GraphiteSegment } from './types';\n\nexport type GraphiteTagOperator = '=' | '=~' | '!=' | '!=~';\n\nexport type GraphiteTag = {\n  key: string;\n  operator: GraphiteTagOperator;\n  value: string;\n};\n\nexport type GraphiteTarget = {\n  refId: string | number;\n  target: string;\n  /**\n   * Contains full query after interpolating sub-queries (e.g. \"function(#A)\" referencing query with refId=A)\n   */\n  targetFull: string;\n  textEditor: boolean;\n  paused: boolean;\n};\n\nexport default class GraphiteQuery {\n  datasource: GraphiteDatasource;\n  target: GraphiteTarget;\n  functions: FuncInstance[] = [];\n  segments: GraphiteSegment[] = [];\n  tags: GraphiteTag[] = [];\n  error: any;\n  seriesByTagUsed = false;\n  checkOtherSegmentsIndex = 0;\n  removeTagValue: string;\n  templateSrv: any;\n  scopedVars: any;\n\n  /** @ngInject */\n  constructor(datasource: any, target: any, templateSrv?: TemplateSrv, scopedVars?: ScopedVars) {\n    this.datasource = datasource;\n    this.target = target;\n    this.templateSrv = templateSrv;\n    this.scopedVars = scopedVars;\n    this.parseTarget();\n\n    this.removeTagValue = '-- remove tag --';\n  }\n\n  parseTarget() {\n    this.functions = [];\n    this.segments = [];\n    this.tags = [];\n    this.seriesByTagUsed = false;\n    this.error = null;\n\n    if (this.target.textEditor) {\n      return;\n    }\n\n    const parser = new Parser(this.target.target);\n    const astNode = parser.getAst();\n    if (astNode === null) {\n      this.checkOtherSegmentsIndex = 0;\n      return;\n    }\n\n    if (astNode.type === 'error') {\n      this.error = astNode.message + ' at position: ' + astNode.pos;\n      this.target.textEditor = true;\n      return;\n    }\n\n    try {\n      this.parseTargetRecursive(astNode, null);\n    } catch (err) {\n      if (err instanceof Error) {\n        console.error('error parsing target:', err.message);\n        this.error = err.message;\n      }\n      this.target.textEditor = true;\n    }\n\n    this.checkOtherSegmentsIndex = this.segments.length - 1;\n  }\n\n  getSegmentPathUpTo(index: number) {\n    const arr = this.segments.slice(0, index);\n\n    return reduce(\n      arr,\n      (result, segment) => {\n        return result ? result + '.' + segment.value : segment.value;\n      },\n      ''\n    );\n  }\n\n  parseTargetRecursive(astNode: any, func: any): any {\n    if (astNode === null) {\n      return null;\n    }\n\n    switch (astNode.type) {\n      case 'function':\n        const innerFunc = this.datasource.createFuncInstance(astNode.name, {\n          withDefaultParams: false,\n        });\n        each(astNode.params, (param) => {\n          this.parseTargetRecursive(param, innerFunc);\n        });\n\n        innerFunc.updateText();\n        this.functions.push(innerFunc);\n\n        // extract tags from seriesByTag function and hide function\n        if (innerFunc.def.name === 'seriesByTag' && !this.seriesByTagUsed) {\n          this.seriesByTagUsed = true;\n          innerFunc.hidden = true;\n          this.tags = this.splitSeriesByTagParams(innerFunc);\n        }\n\n        break;\n      case 'series-ref':\n        if (this.segments.length > 0 || this.getSeriesByTagFuncIndex() >= 0) {\n          this.addFunctionParameter(func, astNode.value);\n        } else {\n          this.segments.push(astNode);\n        }\n        break;\n      case 'bool':\n      case 'string':\n      case 'number':\n        this.addFunctionParameter(func, astNode.value);\n        break;\n      case 'metric':\n        if (this.segments.length || this.tags.length) {\n          this.addFunctionParameter(func, join(map(astNode.segments, 'value'), '.'));\n        } else {\n          this.segments = astNode.segments;\n        }\n        break;\n    }\n  }\n\n  updateSegmentValue(segment: any, index: number) {\n    this.segments[index].value = segment.value;\n  }\n\n  addSelectMetricSegment() {\n    this.segments.push({ value: 'select metric' });\n  }\n\n  addFunction(newFunc: any) {\n    this.functions.push(newFunc);\n  }\n\n  addFunctionParameter(func: any, value: string) {\n    if (func.params.length >= func.def.params.length && !get(last(func.def.params), 'multiple', false)) {\n      throw { message: 'too many parameters for function ' + func.def.name };\n    }\n    func.params.push(value);\n  }\n\n  removeFunction(func: any) {\n    this.functions = without(this.functions, func);\n  }\n\n  moveFunction(func: any, offset: number) {\n    const index = this.functions.indexOf(func);\n    arrayMove(this.functions, index, index + offset);\n  }\n\n  updateModelTarget(targets: any) {\n    const wrapFunction = (target: string, func: any) => {\n      return func.render(target, (value: string) => {\n        return this.templateSrv.replace(value, this.scopedVars);\n      });\n    };\n\n    if (!this.target.textEditor) {\n      const metricPath = this.getSegmentPathUpTo(this.segments.length).replace(/\\.?select metric$/, '');\n      this.target.target = reduce(this.functions, wrapFunction, metricPath);\n    }\n\n    this.updateRenderedTarget(this.target, targets);\n\n    // loop through other queries and update targetFull as needed\n    for (const target of targets || []) {\n      if (target.refId !== this.target.refId) {\n        this.updateRenderedTarget(target, targets);\n      }\n    }\n\n    // clean-up added param\n    this.functions.forEach((func) => (func.added = false));\n  }\n\n  updateRenderedTarget(target: { refId: string | number; target: any; targetFull: any }, targets: any) {\n    // render nested query\n    const targetsByRefId = keyBy(targets, 'refId');\n\n    // no references to self\n    delete targetsByRefId[target.refId];\n\n    const nestedSeriesRefRegex = /\\#([A-Z])/g;\n    let targetWithNestedQueries = target.target;\n\n    // Use ref count to track circular references\n    function countTargetRefs(targetsByRefId: any, refId: string) {\n      let refCount = 0;\n      each(targetsByRefId, (t, id) => {\n        if (id !== refId) {\n          const match = nestedSeriesRefRegex.exec(t.target);\n          const count = match && match.length ? match.length - 1 : 0;\n          refCount += count;\n        }\n      });\n      targetsByRefId[refId].refCount = refCount;\n    }\n    each(targetsByRefId, (t, id) => {\n      countTargetRefs(targetsByRefId, id);\n    });\n\n    // Keep interpolating until there are no query references\n    // The reason for the loop is that the referenced query might contain another reference to another query\n    while (targetWithNestedQueries.match(nestedSeriesRefRegex)) {\n      const updated = targetWithNestedQueries.replace(nestedSeriesRefRegex, (match: string, g1: string) => {\n        const t = targetsByRefId[g1];\n        if (!t) {\n          return match;\n        }\n\n        // no circular references\n        if (t.refCount === 0) {\n          delete targetsByRefId[g1];\n        }\n        t.refCount--;\n\n        return t.target;\n      });\n\n      if (updated === targetWithNestedQueries) {\n        break;\n      }\n\n      targetWithNestedQueries = updated;\n    }\n\n    delete target.targetFull;\n    if (target.target !== targetWithNestedQueries) {\n      target.targetFull = targetWithNestedQueries;\n    }\n  }\n\n  splitSeriesByTagParams(func: { params: any }) {\n    const tagPattern = /([^\\!=~]+)(\\!?=~?)(.*)/;\n    return flatten(\n      map(func.params, (param: string) => {\n        const matches = tagPattern.exec(param);\n        if (matches) {\n          const tag = matches.slice(1);\n          if (tag.length === 3) {\n            return {\n              key: tag[0],\n              operator: tag[1] as GraphiteTagOperator,\n              value: tag[2],\n            };\n          }\n        }\n        return [];\n      })\n    );\n  }\n\n  getSeriesByTagFuncIndex() {\n    return findIndex(this.functions, (func) => func.def.name === 'seriesByTag');\n  }\n\n  getSeriesByTagFunc() {\n    const seriesByTagFuncIndex = this.getSeriesByTagFuncIndex();\n    if (seriesByTagFuncIndex >= 0) {\n      return this.functions[seriesByTagFuncIndex];\n    } else {\n      return undefined;\n    }\n  }\n\n  addTag(tag: { key: any; operator: GraphiteTagOperator; value: string }) {\n    const newTagParam = renderTagString(tag);\n    this.getSeriesByTagFunc()!.params.push(newTagParam);\n    this.tags.push(tag);\n  }\n\n  removeTag(index: number) {\n    this.getSeriesByTagFunc()!.params.splice(index, 1);\n    this.tags.splice(index, 1);\n  }\n\n  updateTag(tag: { key: string; operator: GraphiteTagOperator; value: string }, tagIndex: number) {\n    this.error = null;\n\n    if (tag.key === this.removeTagValue) {\n      this.removeTag(tagIndex);\n      if (this.tags.length === 0) {\n        this.removeFunction(this.getSeriesByTagFunc());\n        this.checkOtherSegmentsIndex = 0;\n        this.seriesByTagUsed = false;\n      }\n      return;\n    }\n\n    this.getSeriesByTagFunc()!.params[tagIndex] = renderTagString(tag);\n    this.tags[tagIndex] = tag;\n  }\n\n  renderTagExpressions(excludeIndex = -1) {\n    return compact(\n      map(this.tags, (tagExpr, index) => {\n        // Don't render tag that we want to lookup\n        if (index !== excludeIndex) {\n          return tagExpr.key + tagExpr.operator + tagExpr.value;\n        } else {\n          return undefined;\n        }\n      })\n    );\n  }\n}\n\nfunction renderTagString(tag: { key: any; operator?: any; value?: any }) {\n  return tag.key + tag.operator + tag.value;\n}\n"],"mappings":";;AAAA,SAASA,OAAT,EAAkBC,IAAlB,EAAwBC,SAAxB,EAAmCC,OAAnC,EAA4CC,GAA5C,EAAiDC,IAAjD,EAAuDC,KAAvD,EAA8DC,IAA9D,EAAoEC,GAApE,EAAyEC,MAAzE,EAAiFC,OAAjF,QAAgG,QAAhG;AAIA,SAASC,SAAT,QAA0B,0BAA1B;AAIA,SAASC,MAAT,QAAuB,UAAvB;AAsBA,eAAe,MAAMC,aAAN,CAAoB;EAajC;EACAC,WAAW,CAACC,UAAD,EAAkBC,MAAlB,EAA+BC,WAA/B,EAA0DC,UAA1D,EAAmF;IAAA;;IAAA;;IAAA,mCAXlE,EAWkE;;IAAA,kCAVhE,EAUgE;;IAAA,8BATxE,EASwE;;IAAA;;IAAA,yCAP5E,KAO4E;;IAAA,iDANpE,CAMoE;;IAAA;;IAAA;;IAAA;;IAC5F,KAAKH,UAAL,GAAkBA,UAAlB;IACA,KAAKC,MAAL,GAAcA,MAAd;IACA,KAAKC,WAAL,GAAmBA,WAAnB;IACA,KAAKC,UAAL,GAAkBA,UAAlB;IACA,KAAKC,WAAL;IAEA,KAAKC,cAAL,GAAsB,kBAAtB;EACD;;EAEDD,WAAW,GAAG;IACZ,KAAKE,SAAL,GAAiB,EAAjB;IACA,KAAKC,QAAL,GAAgB,EAAhB;IACA,KAAKC,IAAL,GAAY,EAAZ;IACA,KAAKC,eAAL,GAAuB,KAAvB;IACA,KAAKC,KAAL,GAAa,IAAb;;IAEA,IAAI,KAAKT,MAAL,CAAYU,UAAhB,EAA4B;MAC1B;IACD;;IAED,MAAMC,MAAM,GAAG,IAAIf,MAAJ,CAAW,KAAKI,MAAL,CAAYA,MAAvB,CAAf;IACA,MAAMY,OAAO,GAAGD,MAAM,CAACE,MAAP,EAAhB;;IACA,IAAID,OAAO,KAAK,IAAhB,EAAsB;MACpB,KAAKE,uBAAL,GAA+B,CAA/B;MACA;IACD;;IAED,IAAIF,OAAO,CAACG,IAAR,KAAiB,OAArB,EAA8B;MAC5B,KAAKN,KAAL,GAAaG,OAAO,CAACI,OAAR,GAAkB,gBAAlB,GAAqCJ,OAAO,CAACK,GAA1D;MACA,KAAKjB,MAAL,CAAYU,UAAZ,GAAyB,IAAzB;MACA;IACD;;IAED,IAAI;MACF,KAAKQ,oBAAL,CAA0BN,OAA1B,EAAmC,IAAnC;IACD,CAFD,CAEE,OAAOO,GAAP,EAAY;MACZ,IAAIA,GAAG,YAAYC,KAAnB,EAA0B;QACxBC,OAAO,CAACZ,KAAR,CAAc,uBAAd,EAAuCU,GAAG,CAACH,OAA3C;QACA,KAAKP,KAAL,GAAaU,GAAG,CAACH,OAAjB;MACD;;MACD,KAAKhB,MAAL,CAAYU,UAAZ,GAAyB,IAAzB;IACD;;IAED,KAAKI,uBAAL,GAA+B,KAAKR,QAAL,CAAcgB,MAAd,GAAuB,CAAtD;EACD;;EAEDC,kBAAkB,CAACC,KAAD,EAAgB;IAChC,MAAMC,GAAG,GAAG,KAAKnB,QAAL,CAAcoB,KAAd,CAAoB,CAApB,EAAuBF,KAAvB,CAAZ;IAEA,OAAO/B,MAAM,CACXgC,GADW,EAEX,CAACE,MAAD,EAASC,OAAT,KAAqB;MACnB,OAAOD,MAAM,GAAGA,MAAM,GAAG,GAAT,GAAeC,OAAO,CAACC,KAA1B,GAAkCD,OAAO,CAACC,KAAvD;IACD,CAJU,EAKX,EALW,CAAb;EAOD;;EAEDX,oBAAoB,CAACN,OAAD,EAAekB,IAAf,EAA+B;IACjD,IAAIlB,OAAO,KAAK,IAAhB,EAAsB;MACpB,OAAO,IAAP;IACD;;IAED,QAAQA,OAAO,CAACG,IAAhB;MACE,KAAK,UAAL;QACE,MAAMgB,SAAS,GAAG,KAAKhC,UAAL,CAAgBiC,kBAAhB,CAAmCpB,OAAO,CAACqB,IAA3C,EAAiD;UACjEC,iBAAiB,EAAE;QAD8C,CAAjD,CAAlB;QAGAjD,IAAI,CAAC2B,OAAO,CAACuB,MAAT,EAAkBC,KAAD,IAAW;UAC9B,KAAKlB,oBAAL,CAA0BkB,KAA1B,EAAiCL,SAAjC;QACD,CAFG,CAAJ;QAIAA,SAAS,CAACM,UAAV;QACA,KAAKhC,SAAL,CAAeiC,IAAf,CAAoBP,SAApB,EATF,CAWE;;QACA,IAAIA,SAAS,CAACQ,GAAV,CAAcN,IAAd,KAAuB,aAAvB,IAAwC,CAAC,KAAKzB,eAAlD,EAAmE;UACjE,KAAKA,eAAL,GAAuB,IAAvB;UACAuB,SAAS,CAACS,MAAV,GAAmB,IAAnB;UACA,KAAKjC,IAAL,GAAY,KAAKkC,sBAAL,CAA4BV,SAA5B,CAAZ;QACD;;QAED;;MACF,KAAK,YAAL;QACE,IAAI,KAAKzB,QAAL,CAAcgB,MAAd,GAAuB,CAAvB,IAA4B,KAAKoB,uBAAL,MAAkC,CAAlE,EAAqE;UACnE,KAAKC,oBAAL,CAA0Bb,IAA1B,EAAgClB,OAAO,CAACiB,KAAxC;QACD,CAFD,MAEO;UACL,KAAKvB,QAAL,CAAcgC,IAAd,CAAmB1B,OAAnB;QACD;;QACD;;MACF,KAAK,MAAL;MACA,KAAK,QAAL;MACA,KAAK,QAAL;QACE,KAAK+B,oBAAL,CAA0Bb,IAA1B,EAAgClB,OAAO,CAACiB,KAAxC;QACA;;MACF,KAAK,QAAL;QACE,IAAI,KAAKvB,QAAL,CAAcgB,MAAd,IAAwB,KAAKf,IAAL,CAAUe,MAAtC,EAA8C;UAC5C,KAAKqB,oBAAL,CAA0Bb,IAA1B,EAAgCzC,IAAI,CAACG,GAAG,CAACoB,OAAO,CAACN,QAAT,EAAmB,OAAnB,CAAJ,EAAiC,GAAjC,CAApC;QACD,CAFD,MAEO;UACL,KAAKA,QAAL,GAAgBM,OAAO,CAACN,QAAxB;QACD;;QACD;IAtCJ;EAwCD;;EAEDsC,kBAAkB,CAAChB,OAAD,EAAeJ,KAAf,EAA8B;IAC9C,KAAKlB,QAAL,CAAckB,KAAd,EAAqBK,KAArB,GAA6BD,OAAO,CAACC,KAArC;EACD;;EAEDgB,sBAAsB,GAAG;IACvB,KAAKvC,QAAL,CAAcgC,IAAd,CAAmB;MAAET,KAAK,EAAE;IAAT,CAAnB;EACD;;EAEDiB,WAAW,CAACC,OAAD,EAAe;IACxB,KAAK1C,SAAL,CAAeiC,IAAf,CAAoBS,OAApB;EACD;;EAEDJ,oBAAoB,CAACb,IAAD,EAAYD,KAAZ,EAA2B;IAC7C,IAAIC,IAAI,CAACK,MAAL,CAAYb,MAAZ,IAAsBQ,IAAI,CAACS,GAAL,CAASJ,MAAT,CAAgBb,MAAtC,IAAgD,CAAClC,GAAG,CAACG,IAAI,CAACuC,IAAI,CAACS,GAAL,CAASJ,MAAV,CAAL,EAAwB,UAAxB,EAAoC,KAApC,CAAxD,EAAoG;MAClG,MAAM;QAAEnB,OAAO,EAAE,sCAAsCc,IAAI,CAACS,GAAL,CAASN;MAA1D,CAAN;IACD;;IACDH,IAAI,CAACK,MAAL,CAAYG,IAAZ,CAAiBT,KAAjB;EACD;;EAEDmB,cAAc,CAAClB,IAAD,EAAY;IACxB,KAAKzB,SAAL,GAAiBX,OAAO,CAAC,KAAKW,SAAN,EAAiByB,IAAjB,CAAxB;EACD;;EAEDmB,YAAY,CAACnB,IAAD,EAAYoB,MAAZ,EAA4B;IACtC,MAAM1B,KAAK,GAAG,KAAKnB,SAAL,CAAe8C,OAAf,CAAuBrB,IAAvB,CAAd;IACAnC,SAAS,CAAC,KAAKU,SAAN,EAAiBmB,KAAjB,EAAwBA,KAAK,GAAG0B,MAAhC,CAAT;EACD;;EAEDE,iBAAiB,CAACC,OAAD,EAAe;IAC9B,MAAMC,YAAY,GAAG,CAACtD,MAAD,EAAiB8B,IAAjB,KAA+B;MAClD,OAAOA,IAAI,CAACyB,MAAL,CAAYvD,MAAZ,EAAqB6B,KAAD,IAAmB;QAC5C,OAAO,KAAK5B,WAAL,CAAiBuD,OAAjB,CAAyB3B,KAAzB,EAAgC,KAAK3B,UAArC,CAAP;MACD,CAFM,CAAP;IAGD,CAJD;;IAMA,IAAI,CAAC,KAAKF,MAAL,CAAYU,UAAjB,EAA6B;MAC3B,MAAM+C,UAAU,GAAG,KAAKlC,kBAAL,CAAwB,KAAKjB,QAAL,CAAcgB,MAAtC,EAA8CkC,OAA9C,CAAsD,mBAAtD,EAA2E,EAA3E,CAAnB;MACA,KAAKxD,MAAL,CAAYA,MAAZ,GAAqBP,MAAM,CAAC,KAAKY,SAAN,EAAiBiD,YAAjB,EAA+BG,UAA/B,CAA3B;IACD;;IAED,KAAKC,oBAAL,CAA0B,KAAK1D,MAA/B,EAAuCqD,OAAvC,EAZ8B,CAc9B;;IACA,KAAK,MAAMrD,MAAX,IAAqBqD,OAAO,IAAI,EAAhC,EAAoC;MAClC,IAAIrD,MAAM,CAAC2D,KAAP,KAAiB,KAAK3D,MAAL,CAAY2D,KAAjC,EAAwC;QACtC,KAAKD,oBAAL,CAA0B1D,MAA1B,EAAkCqD,OAAlC;MACD;IACF,CAnB6B,CAqB9B;;;IACA,KAAKhD,SAAL,CAAeuD,OAAf,CAAwB9B,IAAD,IAAWA,IAAI,CAAC+B,KAAL,GAAa,KAA/C;EACD;;EAEDH,oBAAoB,CAAC1D,MAAD,EAAmEqD,OAAnE,EAAiF;IACnG;IACA,MAAMS,cAAc,GAAGxE,KAAK,CAAC+D,OAAD,EAAU,OAAV,CAA5B,CAFmG,CAInG;;IACA,OAAOS,cAAc,CAAC9D,MAAM,CAAC2D,KAAR,CAArB;IAEA,MAAMI,oBAAoB,GAAG,YAA7B;IACA,IAAIC,uBAAuB,GAAGhE,MAAM,CAACA,MAArC,CARmG,CAUnG;;IACA,SAASiE,eAAT,CAAyBH,cAAzB,EAA8CH,KAA9C,EAA6D;MAC3D,IAAIO,QAAQ,GAAG,CAAf;MACAjF,IAAI,CAAC6E,cAAD,EAAiB,CAACK,CAAD,EAAIC,EAAJ,KAAW;QAC9B,IAAIA,EAAE,KAAKT,KAAX,EAAkB;UAChB,MAAMU,KAAK,GAAGN,oBAAoB,CAACO,IAArB,CAA0BH,CAAC,CAACnE,MAA5B,CAAd;UACA,MAAMuE,KAAK,GAAGF,KAAK,IAAIA,KAAK,CAAC/C,MAAf,GAAwB+C,KAAK,CAAC/C,MAAN,GAAe,CAAvC,GAA2C,CAAzD;UACA4C,QAAQ,IAAIK,KAAZ;QACD;MACF,CANG,CAAJ;MAOAT,cAAc,CAACH,KAAD,CAAd,CAAsBO,QAAtB,GAAiCA,QAAjC;IACD;;IACDjF,IAAI,CAAC6E,cAAD,EAAiB,CAACK,CAAD,EAAIC,EAAJ,KAAW;MAC9BH,eAAe,CAACH,cAAD,EAAiBM,EAAjB,CAAf;IACD,CAFG,CAAJ,CAtBmG,CA0BnG;IACA;;IACA,OAAOJ,uBAAuB,CAACK,KAAxB,CAA8BN,oBAA9B,CAAP,EAA4D;MAC1D,MAAMS,OAAO,GAAGR,uBAAuB,CAACR,OAAxB,CAAgCO,oBAAhC,EAAsD,CAACM,KAAD,EAAgBI,EAAhB,KAA+B;QACnG,MAAMN,CAAC,GAAGL,cAAc,CAACW,EAAD,CAAxB;;QACA,IAAI,CAACN,CAAL,EAAQ;UACN,OAAOE,KAAP;QACD,CAJkG,CAMnG;;;QACA,IAAIF,CAAC,CAACD,QAAF,KAAe,CAAnB,EAAsB;UACpB,OAAOJ,cAAc,CAACW,EAAD,CAArB;QACD;;QACDN,CAAC,CAACD,QAAF;QAEA,OAAOC,CAAC,CAACnE,MAAT;MACD,CAbe,CAAhB;;MAeA,IAAIwE,OAAO,KAAKR,uBAAhB,EAAyC;QACvC;MACD;;MAEDA,uBAAuB,GAAGQ,OAA1B;IACD;;IAED,OAAOxE,MAAM,CAAC0E,UAAd;;IACA,IAAI1E,MAAM,CAACA,MAAP,KAAkBgE,uBAAtB,EAA+C;MAC7ChE,MAAM,CAAC0E,UAAP,GAAoBV,uBAApB;IACD;EACF;;EAEDvB,sBAAsB,CAACX,IAAD,EAAwB;IAC5C,MAAM6C,UAAU,GAAG,wBAAnB;IACA,OAAOxF,OAAO,CACZK,GAAG,CAACsC,IAAI,CAACK,MAAN,EAAeC,KAAD,IAAmB;MAClC,MAAMwC,OAAO,GAAGD,UAAU,CAACL,IAAX,CAAgBlC,KAAhB,CAAhB;;MACA,IAAIwC,OAAJ,EAAa;QACX,MAAMC,GAAG,GAAGD,OAAO,CAAClD,KAAR,CAAc,CAAd,CAAZ;;QACA,IAAImD,GAAG,CAACvD,MAAJ,KAAe,CAAnB,EAAsB;UACpB,OAAO;YACLwD,GAAG,EAAED,GAAG,CAAC,CAAD,CADH;YAELE,QAAQ,EAAEF,GAAG,CAAC,CAAD,CAFR;YAGLhD,KAAK,EAAEgD,GAAG,CAAC,CAAD;UAHL,CAAP;QAKD;MACF;;MACD,OAAO,EAAP;IACD,CAbE,CADS,CAAd;EAgBD;;EAEDnC,uBAAuB,GAAG;IACxB,OAAOxD,SAAS,CAAC,KAAKmB,SAAN,EAAkByB,IAAD,IAAUA,IAAI,CAACS,GAAL,CAASN,IAAT,KAAkB,aAA7C,CAAhB;EACD;;EAED+C,kBAAkB,GAAG;IACnB,MAAMC,oBAAoB,GAAG,KAAKvC,uBAAL,EAA7B;;IACA,IAAIuC,oBAAoB,IAAI,CAA5B,EAA+B;MAC7B,OAAO,KAAK5E,SAAL,CAAe4E,oBAAf,CAAP;IACD,CAFD,MAEO;MACL,OAAOC,SAAP;IACD;EACF;;EAEDC,MAAM,CAACN,GAAD,EAAkE;IACtE,MAAMO,WAAW,GAAGC,eAAe,CAACR,GAAD,CAAnC;IACA,KAAKG,kBAAL,GAA2B7C,MAA3B,CAAkCG,IAAlC,CAAuC8C,WAAvC;IACA,KAAK7E,IAAL,CAAU+B,IAAV,CAAeuC,GAAf;EACD;;EAEDS,SAAS,CAAC9D,KAAD,EAAgB;IACvB,KAAKwD,kBAAL,GAA2B7C,MAA3B,CAAkCoD,MAAlC,CAAyC/D,KAAzC,EAAgD,CAAhD;IACA,KAAKjB,IAAL,CAAUgF,MAAV,CAAiB/D,KAAjB,EAAwB,CAAxB;EACD;;EAEDgE,SAAS,CAACX,GAAD,EAAqEY,QAArE,EAAuF;IAC9F,KAAKhF,KAAL,GAAa,IAAb;;IAEA,IAAIoE,GAAG,CAACC,GAAJ,KAAY,KAAK1E,cAArB,EAAqC;MACnC,KAAKkF,SAAL,CAAeG,QAAf;;MACA,IAAI,KAAKlF,IAAL,CAAUe,MAAV,KAAqB,CAAzB,EAA4B;QAC1B,KAAK0B,cAAL,CAAoB,KAAKgC,kBAAL,EAApB;QACA,KAAKlE,uBAAL,GAA+B,CAA/B;QACA,KAAKN,eAAL,GAAuB,KAAvB;MACD;;MACD;IACD;;IAED,KAAKwE,kBAAL,GAA2B7C,MAA3B,CAAkCsD,QAAlC,IAA8CJ,eAAe,CAACR,GAAD,CAA7D;IACA,KAAKtE,IAAL,CAAUkF,QAAV,IAAsBZ,GAAtB;EACD;;EAEDa,oBAAoB,CAACC,YAAY,GAAG,CAAC,CAAjB,EAAoB;IACtC,OAAO3G,OAAO,CACZQ,GAAG,CAAC,KAAKe,IAAN,EAAY,CAACqF,OAAD,EAAUpE,KAAV,KAAoB;MACjC;MACA,IAAIA,KAAK,KAAKmE,YAAd,EAA4B;QAC1B,OAAOC,OAAO,CAACd,GAAR,GAAcc,OAAO,CAACb,QAAtB,GAAiCa,OAAO,CAAC/D,KAAhD;MACD,CAFD,MAEO;QACL,OAAOqD,SAAP;MACD;IACF,CAPE,CADS,CAAd;EAUD;;AA9SgC;;;AAiTnC,SAASG,eAAT,CAAyBR,GAAzB,EAAyE;EACvE,OAAOA,GAAG,CAACC,GAAJ,GAAUD,GAAG,CAACE,QAAd,GAAyBF,GAAG,CAAChD,KAApC;AACD"},"metadata":{},"sourceType":"module"}