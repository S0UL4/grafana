{"ast":null,"code":"import { from, of } from 'rxjs';\nimport { map, mergeMap } from 'rxjs/operators';\nimport { FieldType, getFieldDisplayName, isDataFrame } from '@grafana/data';\nimport { getProcessedDataFrames } from 'app/features/query/state/runRequest';\nimport { validateVariableSelectionState } from '../state/actions';\nimport { toKeyedAction } from '../state/keyedVariablesReducer';\nimport { toKeyedVariableIdentifier, toVariablePayload } from '../utils';\nimport { updateVariableOptions } from './reducer';\nexport function toMetricFindValues() {\n  return source => source.pipe(map(panelData => {\n    const frames = panelData.series;\n\n    if (!frames || !frames.length) {\n      return [];\n    }\n\n    if (areMetricFindValues(frames)) {\n      return frames;\n    }\n\n    const processedDataFrames = getProcessedDataFrames(frames);\n    const metrics = [];\n    let valueIndex = -1;\n    let textIndex = -1;\n    let stringIndex = -1;\n    let expandableIndex = -1;\n\n    for (const frame of processedDataFrames) {\n      for (let index = 0; index < frame.fields.length; index++) {\n        const field = frame.fields[index];\n        const fieldName = getFieldDisplayName(field, frame, frames).toLowerCase();\n\n        if (field.type === FieldType.string && stringIndex === -1) {\n          stringIndex = index;\n        }\n\n        if (fieldName === 'text' && field.type === FieldType.string && textIndex === -1) {\n          textIndex = index;\n        }\n\n        if (fieldName === 'value' && field.type === FieldType.string && valueIndex === -1) {\n          valueIndex = index;\n        }\n\n        if (fieldName === 'expandable' && (field.type === FieldType.boolean || field.type === FieldType.number) && expandableIndex === -1) {\n          expandableIndex = index;\n        }\n      }\n    }\n\n    if (stringIndex === -1) {\n      throw new Error(\"Couldn't find any field of type string in the results.\");\n    }\n\n    for (const frame of frames) {\n      for (let index = 0; index < frame.length; index++) {\n        const expandable = expandableIndex !== -1 ? frame.fields[expandableIndex].values.get(index) : undefined;\n        const string = frame.fields[stringIndex].values.get(index);\n        const text = textIndex !== -1 ? frame.fields[textIndex].values.get(index) : null;\n        const value = valueIndex !== -1 ? frame.fields[valueIndex].values.get(index) : null;\n\n        if (valueIndex === -1 && textIndex === -1) {\n          metrics.push({\n            text: string,\n            value: string,\n            expandable\n          });\n          continue;\n        }\n\n        if (valueIndex === -1 && textIndex !== -1) {\n          metrics.push({\n            text,\n            value: text,\n            expandable\n          });\n          continue;\n        }\n\n        if (valueIndex !== -1 && textIndex === -1) {\n          metrics.push({\n            text: value,\n            value,\n            expandable\n          });\n          continue;\n        }\n\n        metrics.push({\n          text,\n          value,\n          expandable\n        });\n      }\n    }\n\n    return metrics;\n  }));\n}\nexport function updateOptionsState(args) {\n  return source => source.pipe(map(results => {\n    const {\n      variable,\n      dispatch,\n      getTemplatedRegexFunc\n    } = args;\n\n    if (!variable.rootStateKey) {\n      console.error('updateOptionsState: variable.rootStateKey is not defined');\n      return;\n    }\n\n    const templatedRegex = getTemplatedRegexFunc(variable);\n    const payload = toVariablePayload(variable, {\n      results,\n      templatedRegex\n    });\n    dispatch(toKeyedAction(variable.rootStateKey, updateVariableOptions(payload)));\n  }));\n}\nexport function validateVariableSelection(args) {\n  return source => source.pipe(mergeMap(() => {\n    const {\n      dispatch,\n      variable,\n      searchFilter\n    } = args; // If we are searching options there is no need to validate selection state\n    // This condition was added to as validateVariableSelectionState will update the current value of the variable\n    // So after search and selection the current value is already update so no setValue, refresh and URL update is performed\n    // The if statement below fixes https://github.com/grafana/grafana/issues/25671\n\n    if (!searchFilter) {\n      return from(dispatch(validateVariableSelectionState(toKeyedVariableIdentifier(variable))));\n    }\n\n    return of();\n  }));\n}\nexport function areMetricFindValues(data) {\n  if (!data) {\n    return false;\n  }\n\n  if (!data.length) {\n    return true;\n  }\n\n  const firstValue = data[0];\n\n  if (isDataFrame(firstValue)) {\n    return false;\n  }\n\n  for (const firstValueKey in firstValue) {\n    if (!firstValue.hasOwnProperty(firstValueKey)) {\n      continue;\n    }\n\n    if (firstValue[firstValueKey] !== null && typeof firstValue[firstValueKey] !== 'string' && typeof firstValue[firstValueKey] !== 'number') {\n      continue;\n    }\n\n    const key = firstValueKey.toLowerCase();\n\n    if (key === 'text' || key === 'value') {\n      return true;\n    }\n  }\n\n  return false;\n}","map":{"version":3,"names":["from","of","map","mergeMap","FieldType","getFieldDisplayName","isDataFrame","getProcessedDataFrames","validateVariableSelectionState","toKeyedAction","toKeyedVariableIdentifier","toVariablePayload","updateVariableOptions","toMetricFindValues","source","pipe","panelData","frames","series","length","areMetricFindValues","processedDataFrames","metrics","valueIndex","textIndex","stringIndex","expandableIndex","frame","index","fields","field","fieldName","toLowerCase","type","string","boolean","number","Error","expandable","values","get","undefined","text","value","push","updateOptionsState","args","results","variable","dispatch","getTemplatedRegexFunc","rootStateKey","console","error","templatedRegex","payload","validateVariableSelection","searchFilter","data","firstValue","firstValueKey","hasOwnProperty","key"],"sources":["/home/soula/grafana/public/app/features/variables/query/operators.ts"],"sourcesContent":["import { from, of, OperatorFunction } from 'rxjs';\nimport { map, mergeMap } from 'rxjs/operators';\n\nimport { FieldType, getFieldDisplayName, isDataFrame, MetricFindValue, PanelData } from '@grafana/data';\nimport { getProcessedDataFrames } from 'app/features/query/state/runRequest';\n\nimport { ThunkDispatch } from '../../../types';\nimport { validateVariableSelectionState } from '../state/actions';\nimport { toKeyedAction } from '../state/keyedVariablesReducer';\nimport { QueryVariableModel } from '../types';\nimport { getTemplatedRegex, toKeyedVariableIdentifier, toVariablePayload } from '../utils';\n\nimport { updateVariableOptions } from './reducer';\n\nexport function toMetricFindValues(): OperatorFunction<PanelData, MetricFindValue[]> {\n  return (source) =>\n    source.pipe(\n      map((panelData) => {\n        const frames = panelData.series;\n        if (!frames || !frames.length) {\n          return [];\n        }\n\n        if (areMetricFindValues(frames)) {\n          return frames;\n        }\n\n        const processedDataFrames = getProcessedDataFrames(frames);\n        const metrics: MetricFindValue[] = [];\n\n        let valueIndex = -1;\n        let textIndex = -1;\n        let stringIndex = -1;\n        let expandableIndex = -1;\n\n        for (const frame of processedDataFrames) {\n          for (let index = 0; index < frame.fields.length; index++) {\n            const field = frame.fields[index];\n            const fieldName = getFieldDisplayName(field, frame, frames).toLowerCase();\n\n            if (field.type === FieldType.string && stringIndex === -1) {\n              stringIndex = index;\n            }\n\n            if (fieldName === 'text' && field.type === FieldType.string && textIndex === -1) {\n              textIndex = index;\n            }\n\n            if (fieldName === 'value' && field.type === FieldType.string && valueIndex === -1) {\n              valueIndex = index;\n            }\n\n            if (\n              fieldName === 'expandable' &&\n              (field.type === FieldType.boolean || field.type === FieldType.number) &&\n              expandableIndex === -1\n            ) {\n              expandableIndex = index;\n            }\n          }\n        }\n\n        if (stringIndex === -1) {\n          throw new Error(\"Couldn't find any field of type string in the results.\");\n        }\n\n        for (const frame of frames) {\n          for (let index = 0; index < frame.length; index++) {\n            const expandable = expandableIndex !== -1 ? frame.fields[expandableIndex].values.get(index) : undefined;\n            const string = frame.fields[stringIndex].values.get(index);\n            const text = textIndex !== -1 ? frame.fields[textIndex].values.get(index) : null;\n            const value = valueIndex !== -1 ? frame.fields[valueIndex].values.get(index) : null;\n\n            if (valueIndex === -1 && textIndex === -1) {\n              metrics.push({ text: string, value: string, expandable });\n              continue;\n            }\n\n            if (valueIndex === -1 && textIndex !== -1) {\n              metrics.push({ text, value: text, expandable });\n              continue;\n            }\n\n            if (valueIndex !== -1 && textIndex === -1) {\n              metrics.push({ text: value, value, expandable });\n              continue;\n            }\n\n            metrics.push({ text, value, expandable });\n          }\n        }\n\n        return metrics;\n      })\n    );\n}\n\nexport function updateOptionsState(args: {\n  variable: QueryVariableModel;\n  dispatch: ThunkDispatch;\n  getTemplatedRegexFunc: typeof getTemplatedRegex;\n}): OperatorFunction<MetricFindValue[], void> {\n  return (source) =>\n    source.pipe(\n      map((results) => {\n        const { variable, dispatch, getTemplatedRegexFunc } = args;\n        if (!variable.rootStateKey) {\n          console.error('updateOptionsState: variable.rootStateKey is not defined');\n          return;\n        }\n        const templatedRegex = getTemplatedRegexFunc(variable);\n        const payload = toVariablePayload(variable, { results, templatedRegex });\n        dispatch(toKeyedAction(variable.rootStateKey, updateVariableOptions(payload)));\n      })\n    );\n}\n\nexport function validateVariableSelection(args: {\n  variable: QueryVariableModel;\n  dispatch: ThunkDispatch;\n  searchFilter?: string;\n}): OperatorFunction<void, void> {\n  return (source) =>\n    source.pipe(\n      mergeMap(() => {\n        const { dispatch, variable, searchFilter } = args;\n\n        // If we are searching options there is no need to validate selection state\n        // This condition was added to as validateVariableSelectionState will update the current value of the variable\n        // So after search and selection the current value is already update so no setValue, refresh and URL update is performed\n        // The if statement below fixes https://github.com/grafana/grafana/issues/25671\n        if (!searchFilter) {\n          return from(dispatch(validateVariableSelectionState(toKeyedVariableIdentifier(variable))));\n        }\n\n        return of<void>();\n      })\n    );\n}\n\nexport function areMetricFindValues(data: any[]): data is MetricFindValue[] {\n  if (!data) {\n    return false;\n  }\n\n  if (!data.length) {\n    return true;\n  }\n\n  const firstValue: any = data[0];\n\n  if (isDataFrame(firstValue)) {\n    return false;\n  }\n\n  for (const firstValueKey in firstValue) {\n    if (!firstValue.hasOwnProperty(firstValueKey)) {\n      continue;\n    }\n\n    if (\n      firstValue[firstValueKey] !== null &&\n      typeof firstValue[firstValueKey] !== 'string' &&\n      typeof firstValue[firstValueKey] !== 'number'\n    ) {\n      continue;\n    }\n\n    const key = firstValueKey.toLowerCase();\n\n    if (key === 'text' || key === 'value') {\n      return true;\n    }\n  }\n\n  return false;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}