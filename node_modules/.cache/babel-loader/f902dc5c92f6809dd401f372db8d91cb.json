{"ast":null,"code":"import { LinkedToken } from './LinkedToken';\nexport function linkedTokenBuilder(monaco, language, model, position, tokenTypes) {\n  var _model$getValue;\n\n  let current = null;\n  let previous = null;\n  const tokensPerLine = monaco.editor.tokenize((_model$getValue = model.getValue()) !== null && _model$getValue !== void 0 ? _model$getValue : '', language.id);\n\n  for (let lineIndex = 0; lineIndex < tokensPerLine.length; lineIndex++) {\n    const tokens = tokensPerLine[lineIndex]; // In case position is first column in new line, add empty whitespace token so that links are not broken\n\n    if (!tokens.length && previous) {\n      const token = {\n        offset: 0,\n        type: tokenTypes.Whitespace,\n        language: language.id,\n        _tokenBrand: undefined\n      };\n      tokens.push(token);\n    }\n\n    for (let columnIndex = 0; columnIndex < tokens.length; columnIndex++) {\n      const token = tokens[columnIndex];\n      let endColumn = tokens.length > columnIndex + 1 ? tokens[columnIndex + 1].offset + 1 : model.getLineLength(lineIndex + 1) + 1;\n      const range = {\n        startLineNumber: lineIndex + 1,\n        startColumn: token.offset === 0 ? 0 : token.offset + 1,\n        endLineNumber: lineIndex + 1,\n        endColumn\n      };\n      const value = model.getValueInRange(range);\n      const newToken = new LinkedToken(token.type, value, range, previous, null, tokenTypes);\n\n      if (monaco.Range.containsPosition(range, position)) {\n        current = newToken;\n      }\n\n      if (previous) {\n        previous.next = newToken;\n      }\n\n      previous = newToken;\n    }\n  }\n\n  return current;\n}","map":{"version":3,"names":["LinkedToken","linkedTokenBuilder","monaco","language","model","position","tokenTypes","current","previous","tokensPerLine","editor","tokenize","getValue","id","lineIndex","length","tokens","token","offset","type","Whitespace","_tokenBrand","undefined","push","columnIndex","endColumn","getLineLength","range","startLineNumber","startColumn","endLineNumber","value","getValueInRange","newToken","Range","containsPosition","next"],"sources":["/home/soula/grafana/public/app/plugins/datasource/cloudwatch/monarch/linkedTokenBuilder.ts"],"sourcesContent":["import type { monacoTypes } from '@grafana/ui';\n\nimport { LinkedToken } from './LinkedToken';\nimport { LanguageDefinition } from './register';\nimport { Monaco, TokenTypes } from './types';\n\nexport function linkedTokenBuilder(\n  monaco: Monaco,\n  language: LanguageDefinition,\n  model: monacoTypes.editor.ITextModel,\n  position: monacoTypes.IPosition,\n  tokenTypes: TokenTypes\n) {\n  let current: LinkedToken | null = null;\n  let previous: LinkedToken | null = null;\n  const tokensPerLine = monaco.editor.tokenize(model.getValue() ?? '', language.id);\n\n  for (let lineIndex = 0; lineIndex < tokensPerLine.length; lineIndex++) {\n    const tokens = tokensPerLine[lineIndex];\n    // In case position is first column in new line, add empty whitespace token so that links are not broken\n    if (!tokens.length && previous) {\n      const token: monacoTypes.Token = {\n        offset: 0,\n        type: tokenTypes.Whitespace,\n        language: language.id,\n        _tokenBrand: undefined,\n      };\n      tokens.push(token);\n    }\n\n    for (let columnIndex = 0; columnIndex < tokens.length; columnIndex++) {\n      const token = tokens[columnIndex];\n      let endColumn =\n        tokens.length > columnIndex + 1 ? tokens[columnIndex + 1].offset + 1 : model.getLineLength(lineIndex + 1) + 1;\n\n      const range: monacoTypes.IRange = {\n        startLineNumber: lineIndex + 1,\n        startColumn: token.offset === 0 ? 0 : token.offset + 1,\n        endLineNumber: lineIndex + 1,\n        endColumn,\n      };\n\n      const value = model.getValueInRange(range);\n      const newToken: LinkedToken = new LinkedToken(token.type, value, range, previous, null, tokenTypes);\n\n      if (monaco.Range.containsPosition(range, position)) {\n        current = newToken;\n      }\n\n      if (previous) {\n        previous.next = newToken;\n      }\n      previous = newToken;\n    }\n  }\n\n  return current;\n}\n"],"mappings":"AAEA,SAASA,WAAT,QAA4B,eAA5B;AAIA,OAAO,SAASC,kBAAT,CACLC,MADK,EAELC,QAFK,EAGLC,KAHK,EAILC,QAJK,EAKLC,UALK,EAML;EAAA;;EACA,IAAIC,OAA2B,GAAG,IAAlC;EACA,IAAIC,QAA4B,GAAG,IAAnC;EACA,MAAMC,aAAa,GAAGP,MAAM,CAACQ,MAAP,CAAcC,QAAd,oBAAuBP,KAAK,CAACQ,QAAN,EAAvB,6DAA2C,EAA3C,EAA+CT,QAAQ,CAACU,EAAxD,CAAtB;;EAEA,KAAK,IAAIC,SAAS,GAAG,CAArB,EAAwBA,SAAS,GAAGL,aAAa,CAACM,MAAlD,EAA0DD,SAAS,EAAnE,EAAuE;IACrE,MAAME,MAAM,GAAGP,aAAa,CAACK,SAAD,CAA5B,CADqE,CAErE;;IACA,IAAI,CAACE,MAAM,CAACD,MAAR,IAAkBP,QAAtB,EAAgC;MAC9B,MAAMS,KAAwB,GAAG;QAC/BC,MAAM,EAAE,CADuB;QAE/BC,IAAI,EAAEb,UAAU,CAACc,UAFc;QAG/BjB,QAAQ,EAAEA,QAAQ,CAACU,EAHY;QAI/BQ,WAAW,EAAEC;MAJkB,CAAjC;MAMAN,MAAM,CAACO,IAAP,CAAYN,KAAZ;IACD;;IAED,KAAK,IAAIO,WAAW,GAAG,CAAvB,EAA0BA,WAAW,GAAGR,MAAM,CAACD,MAA/C,EAAuDS,WAAW,EAAlE,EAAsE;MACpE,MAAMP,KAAK,GAAGD,MAAM,CAACQ,WAAD,CAApB;MACA,IAAIC,SAAS,GACXT,MAAM,CAACD,MAAP,GAAgBS,WAAW,GAAG,CAA9B,GAAkCR,MAAM,CAACQ,WAAW,GAAG,CAAf,CAAN,CAAwBN,MAAxB,GAAiC,CAAnE,GAAuEd,KAAK,CAACsB,aAAN,CAAoBZ,SAAS,GAAG,CAAhC,IAAqC,CAD9G;MAGA,MAAMa,KAAyB,GAAG;QAChCC,eAAe,EAAEd,SAAS,GAAG,CADG;QAEhCe,WAAW,EAAEZ,KAAK,CAACC,MAAN,KAAiB,CAAjB,GAAqB,CAArB,GAAyBD,KAAK,CAACC,MAAN,GAAe,CAFrB;QAGhCY,aAAa,EAAEhB,SAAS,GAAG,CAHK;QAIhCW;MAJgC,CAAlC;MAOA,MAAMM,KAAK,GAAG3B,KAAK,CAAC4B,eAAN,CAAsBL,KAAtB,CAAd;MACA,MAAMM,QAAqB,GAAG,IAAIjC,WAAJ,CAAgBiB,KAAK,CAACE,IAAtB,EAA4BY,KAA5B,EAAmCJ,KAAnC,EAA0CnB,QAA1C,EAAoD,IAApD,EAA0DF,UAA1D,CAA9B;;MAEA,IAAIJ,MAAM,CAACgC,KAAP,CAAaC,gBAAb,CAA8BR,KAA9B,EAAqCtB,QAArC,CAAJ,EAAoD;QAClDE,OAAO,GAAG0B,QAAV;MACD;;MAED,IAAIzB,QAAJ,EAAc;QACZA,QAAQ,CAAC4B,IAAT,GAAgBH,QAAhB;MACD;;MACDzB,QAAQ,GAAGyB,QAAX;IACD;EACF;;EAED,OAAO1B,OAAP;AACD"},"metadata":{},"sourceType":"module"}