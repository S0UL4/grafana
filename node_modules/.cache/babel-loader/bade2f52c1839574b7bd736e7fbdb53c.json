{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { Subject } from 'rxjs';\nimport { filter } from 'rxjs/operators';\nexport class ResponseQueue {\n  // internal stream for requests that are to be executed\n  // external stream with responses from fetch\n  constructor(fetchQueue, fetch) {\n    _defineProperty(this, \"queue\", new Subject());\n\n    _defineProperty(this, \"responses\", new Subject());\n\n    _defineProperty(this, \"add\", (id, options) => {\n      this.queue.next({\n        id,\n        options\n      });\n    });\n\n    _defineProperty(this, \"getResponses\", id => this.responses.asObservable().pipe(filter(entry => entry.id === id)));\n\n    // This will create an implicit live subscription for as long as this class lives.\n    // But as FetchQueue is used by the singleton backendSrv that also lives for as long as Grafana app lives\n    // I think this ok. We could add some disposable pattern later if the need arises.\n    this.queue.subscribe(entry => {\n      const {\n        id,\n        options\n      } = entry; // Let the fetchQueue know that this id has started data fetching.\n\n      fetchQueue.setInProgress(id);\n      this.responses.next({\n        id,\n        observable: fetch(options)\n      });\n    });\n  }\n\n}","map":{"version":3,"names":["Subject","filter","ResponseQueue","constructor","fetchQueue","fetch","id","options","queue","next","responses","asObservable","pipe","entry","subscribe","setInProgress","observable"],"sources":["/home/soula/grafana/public/app/core/services/ResponseQueue.ts"],"sourcesContent":["import { Observable, Subject } from 'rxjs';\nimport { filter } from 'rxjs/operators';\n\nimport { BackendSrvRequest, FetchResponse } from '@grafana/runtime';\n\nimport { FetchQueue } from './FetchQueue';\n\ninterface FetchWorkEntry {\n  id: string;\n  options: BackendSrvRequest;\n}\n\ninterface FetchResponsesEntry<T> {\n  id: string;\n  observable: Observable<FetchResponse<T>>;\n}\n\nexport class ResponseQueue {\n  private queue: Subject<FetchWorkEntry> = new Subject<FetchWorkEntry>(); // internal stream for requests that are to be executed\n  private responses: Subject<FetchResponsesEntry<any>> = new Subject<FetchResponsesEntry<any>>(); // external stream with responses from fetch\n\n  constructor(fetchQueue: FetchQueue, fetch: <T>(options: BackendSrvRequest) => Observable<FetchResponse<T>>) {\n    // This will create an implicit live subscription for as long as this class lives.\n    // But as FetchQueue is used by the singleton backendSrv that also lives for as long as Grafana app lives\n    // I think this ok. We could add some disposable pattern later if the need arises.\n    this.queue.subscribe((entry) => {\n      const { id, options } = entry;\n\n      // Let the fetchQueue know that this id has started data fetching.\n      fetchQueue.setInProgress(id);\n\n      this.responses.next({ id, observable: fetch(options) });\n    });\n  }\n\n  add = (id: string, options: BackendSrvRequest): void => {\n    this.queue.next({ id, options });\n  };\n\n  getResponses = <T>(id: string): Observable<FetchResponsesEntry<T>> =>\n    this.responses.asObservable().pipe(filter((entry) => entry.id === id));\n}\n"],"mappings":";;AAAA,SAAqBA,OAArB,QAAoC,MAApC;AACA,SAASC,MAAT,QAAuB,gBAAvB;AAgBA,OAAO,MAAMC,aAAN,CAAoB;EAC+C;EACwB;EAEhGC,WAAW,CAACC,UAAD,EAAyBC,KAAzB,EAAiG;IAAA,+BAHnE,IAAIL,OAAJ,EAGmE;;IAAA,mCAFrD,IAAIA,OAAJ,EAEqD;;IAAA,6BActG,CAACM,EAAD,EAAaC,OAAb,KAAkD;MACtD,KAAKC,KAAL,CAAWC,IAAX,CAAgB;QAAEH,EAAF;QAAMC;MAAN,CAAhB;IACD,CAhB2G;;IAAA,sCAkBzFD,EAAJ,IACb,KAAKI,SAAL,CAAeC,YAAf,GAA8BC,IAA9B,CAAmCX,MAAM,CAAEY,KAAD,IAAWA,KAAK,CAACP,EAAN,KAAaA,EAAzB,CAAzC,CAnB0G;;IAC1G;IACA;IACA;IACA,KAAKE,KAAL,CAAWM,SAAX,CAAsBD,KAAD,IAAW;MAC9B,MAAM;QAAEP,EAAF;QAAMC;MAAN,IAAkBM,KAAxB,CAD8B,CAG9B;;MACAT,UAAU,CAACW,aAAX,CAAyBT,EAAzB;MAEA,KAAKI,SAAL,CAAeD,IAAf,CAAoB;QAAEH,EAAF;QAAMU,UAAU,EAAEX,KAAK,CAACE,OAAD;MAAvB,CAApB;IACD,CAPD;EAQD;;AAhBwB"},"metadata":{},"sourceType":"module"}