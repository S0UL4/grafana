{"ast":null,"code":"import { findIndex, isObject, map } from 'lodash';\nimport TableModel, { mergeTablesIntoModel } from 'app/core/table_model';\nimport TimeSeries from 'app/core/time_series2';\nimport flatten from 'app/core/utils/flatten';\nconst transformers = {};\nexport const timeSeriesFormatFilterer = data => {\n  if (!Array.isArray(data)) {\n    return data.datapoints ? [data] : [];\n  }\n\n  return data.reduce((acc, series) => {\n    if (!series.datapoints) {\n      return acc;\n    }\n\n    return acc.concat(series);\n  }, []);\n};\nexport const tableDataFormatFilterer = data => {\n  if (!Array.isArray(data)) {\n    return data.columns ? [data] : [];\n  }\n\n  return data.reduce((acc, series) => {\n    if (!series.columns) {\n      return acc;\n    }\n\n    return acc.concat(series);\n  }, []);\n};\ntransformers['timeseries_to_rows'] = {\n  description: 'Time series to rows',\n  getColumns: () => {\n    return [];\n  },\n  transform: (data, panel, model) => {\n    model.columns = [{\n      text: 'Time',\n      type: 'date'\n    }, {\n      text: 'Metric'\n    }, {\n      text: 'Value'\n    }];\n    const filteredData = timeSeriesFormatFilterer(data);\n\n    for (let i = 0; i < filteredData.length; i++) {\n      const series = filteredData[i];\n\n      for (let y = 0; y < series.datapoints.length; y++) {\n        const dp = series.datapoints[y];\n        model.rows.push([dp[1], series.target, dp[0]]);\n      }\n    }\n  }\n};\ntransformers['timeseries_to_columns'] = {\n  description: 'Time series to columns',\n  getColumns: () => {\n    return [];\n  },\n  transform: (data, panel, model) => {\n    model.columns.push({\n      text: 'Time',\n      type: 'date'\n    }); // group by time\n\n    const points = {};\n    const filteredData = timeSeriesFormatFilterer(data);\n\n    for (let i = 0; i < filteredData.length; i++) {\n      const series = filteredData[i];\n      model.columns.push({\n        text: series.target\n      });\n\n      for (let y = 0; y < series.datapoints.length; y++) {\n        const dp = series.datapoints[y];\n        const timeKey = dp[1].toString();\n\n        if (!points[timeKey]) {\n          points[timeKey] = {\n            time: dp[1]\n          };\n          points[timeKey][i] = dp[0];\n        } else {\n          points[timeKey][i] = dp[0];\n        }\n      }\n    }\n\n    for (const time in points) {\n      const point = points[time];\n      const values = [point.time];\n\n      for (let i = 0; i < filteredData.length; i++) {\n        const value = point[i];\n        values.push(value);\n      }\n\n      model.rows.push(values);\n    }\n  }\n};\ntransformers['timeseries_aggregations'] = {\n  description: 'Time series aggregations',\n  getColumns: () => {\n    return [{\n      text: 'Avg',\n      value: 'avg'\n    }, {\n      text: 'Min',\n      value: 'min'\n    }, {\n      text: 'Max',\n      value: 'max'\n    }, {\n      text: 'Total',\n      value: 'total'\n    }, {\n      text: 'Current',\n      value: 'current'\n    }, {\n      text: 'Count',\n      value: 'count'\n    }];\n  },\n  transform: (data, panel, model) => {\n    let i, y;\n    model.columns.push({\n      text: 'Metric'\n    });\n\n    for (i = 0; i < panel.columns.length; i++) {\n      model.columns.push({\n        text: panel.columns[i].text\n      });\n    }\n\n    const filteredData = timeSeriesFormatFilterer(data);\n\n    for (i = 0; i < filteredData.length; i++) {\n      const series = new TimeSeries({\n        datapoints: filteredData[i].datapoints,\n        alias: filteredData[i].target\n      });\n      series.getFlotPairs('connected');\n      const cells = [series.alias];\n\n      for (y = 0; y < panel.columns.length; y++) {\n        cells.push(series.stats[panel.columns[y].value]);\n      }\n\n      model.rows.push(cells);\n    }\n  }\n};\ntransformers['annotations'] = {\n  description: 'Annotations',\n  getColumns: () => {\n    return [];\n  },\n  transform: (data, panel, model) => {\n    model.columns.push({\n      text: 'Time',\n      type: 'date'\n    });\n    model.columns.push({\n      text: 'Title'\n    });\n    model.columns.push({\n      text: 'Text'\n    });\n    model.columns.push({\n      text: 'Tags'\n    });\n\n    if (!data || !data.annotations || data.annotations.length === 0) {\n      return;\n    }\n\n    for (let i = 0; i < data.annotations.length; i++) {\n      const evt = data.annotations[i];\n      model.rows.push([evt.time, evt.title, evt.text, evt.tags]);\n    }\n  }\n};\ntransformers['table'] = {\n  description: 'Table',\n  getColumns: data => {\n    if (!data || data.length === 0) {\n      return [];\n    } // Single query returns data columns as is\n\n\n    if (data.length === 1) {\n      return [...data[0].columns];\n    }\n\n    const filteredData = tableDataFormatFilterer(data); // Track column indexes: name -> index\n\n    const columnNames = {}; // Union of all columns\n\n    const columns = filteredData.reduce((acc, series) => {\n      series.columns.forEach(col => {\n        const {\n          text\n        } = col;\n\n        if (columnNames[text] === undefined) {\n          columnNames[text] = acc.length;\n          acc.push(col);\n        }\n      });\n      return acc;\n    }, []);\n    return columns;\n  },\n  transform: (data, panel, model) => {\n    if (!data || data.length === 0) {\n      return;\n    }\n\n    const filteredData = tableDataFormatFilterer(data);\n    const noTableIndex = findIndex(filteredData, d => 'columns' in d && 'rows' in d);\n\n    if (noTableIndex < 0) {\n      throw {\n        message: `Result of query #${String.fromCharCode(65 + noTableIndex)} is not in table format, try using another transform.`\n      };\n    }\n\n    mergeTablesIntoModel(model, ...filteredData);\n  }\n};\ntransformers['json'] = {\n  description: 'JSON Data',\n  getColumns: data => {\n    if (!data || data.length === 0) {\n      return [];\n    }\n\n    const names = {};\n\n    for (let i = 0; i < data.length; i++) {\n      const series = data[i];\n\n      if (series.type !== 'docs') {\n        continue;\n      } // only look at 100 docs\n\n\n      const maxDocs = Math.min(series.datapoints.length, 100);\n\n      for (let y = 0; y < maxDocs; y++) {\n        const doc = series.datapoints[y];\n        const flattened = flatten(doc, {});\n\n        for (const propName in flattened) {\n          names[propName] = true;\n        }\n      }\n    }\n\n    return map(names, (value, key) => {\n      return {\n        text: key,\n        value: key\n      };\n    });\n  },\n  transform: (data, panel, model) => {\n    let i, y, z;\n\n    for (const column of panel.columns) {\n      const tableCol = {\n        text: column.text\n      }; // if filterable data then set columns to filterable\n\n      if (data.length > 0 && data[0].filterable) {\n        tableCol.filterable = true;\n      }\n\n      model.columns.push(tableCol);\n    }\n\n    if (model.columns.length === 0) {\n      model.columns.push({\n        text: 'JSON'\n      });\n    }\n\n    for (i = 0; i < data.length; i++) {\n      const series = data[i];\n\n      for (y = 0; y < series.datapoints.length; y++) {\n        const dp = series.datapoints[y];\n        const values = [];\n\n        if (isObject(dp) && panel.columns.length > 0) {\n          const flattened = flatten(dp);\n\n          for (z = 0; z < panel.columns.length; z++) {\n            values.push(flattened[panel.columns[z].value]);\n          }\n        } else {\n          values.push(JSON.stringify(dp));\n        }\n\n        model.rows.push(values);\n      }\n    }\n  }\n};\n\nfunction transformDataToTable(data, panel) {\n  const model = new TableModel();\n\n  if (!data || data.length === 0) {\n    return model;\n  }\n\n  const transformer = transformers[panel.transform];\n\n  if (!transformer) {\n    throw {\n      message: 'Transformer ' + panel.transform + ' not found'\n    };\n  }\n\n  transformer.transform(data, panel, model);\n  return model;\n}\n\nexport { transformers, transformDataToTable };","map":{"version":3,"names":["findIndex","isObject","map","TableModel","mergeTablesIntoModel","TimeSeries","flatten","transformers","timeSeriesFormatFilterer","data","Array","isArray","datapoints","reduce","acc","series","concat","tableDataFormatFilterer","columns","description","getColumns","transform","panel","model","text","type","filteredData","i","length","y","dp","rows","push","target","points","timeKey","toString","time","point","values","value","alias","getFlotPairs","cells","stats","annotations","evt","title","tags","columnNames","forEach","col","undefined","noTableIndex","d","message","String","fromCharCode","names","maxDocs","Math","min","doc","flattened","propName","key","z","column","tableCol","filterable","JSON","stringify","transformDataToTable","transformer"],"sources":["/home/soula/grafana/public/app/plugins/panel/table-old/transformers.ts"],"sourcesContent":["import { findIndex, isObject, map } from 'lodash';\n\nimport { Column, TableData } from '@grafana/data';\nimport TableModel, { mergeTablesIntoModel } from 'app/core/table_model';\nimport TimeSeries from 'app/core/time_series2';\nimport flatten from 'app/core/utils/flatten';\n\nimport { TableTransform } from './types';\n\nconst transformers: { [key: string]: TableTransform } = {};\nexport const timeSeriesFormatFilterer = (data: any): any[] => {\n  if (!Array.isArray(data)) {\n    return data.datapoints ? [data] : [];\n  }\n\n  return data.reduce((acc, series) => {\n    if (!series.datapoints) {\n      return acc;\n    }\n\n    return acc.concat(series);\n  }, []);\n};\n\nexport const tableDataFormatFilterer = (data: any): any[] => {\n  if (!Array.isArray(data)) {\n    return data.columns ? [data] : [];\n  }\n\n  return data.reduce((acc, series) => {\n    if (!series.columns) {\n      return acc;\n    }\n\n    return acc.concat(series);\n  }, []);\n};\n\ntransformers['timeseries_to_rows'] = {\n  description: 'Time series to rows',\n  getColumns: () => {\n    return [];\n  },\n  transform: (data, panel, model) => {\n    model.columns = [{ text: 'Time', type: 'date' }, { text: 'Metric' }, { text: 'Value' }];\n    const filteredData = timeSeriesFormatFilterer(data);\n\n    for (let i = 0; i < filteredData.length; i++) {\n      const series = filteredData[i];\n      for (let y = 0; y < series.datapoints.length; y++) {\n        const dp = series.datapoints[y];\n        model.rows.push([dp[1], series.target, dp[0]]);\n      }\n    }\n  },\n};\n\ntransformers['timeseries_to_columns'] = {\n  description: 'Time series to columns',\n  getColumns: () => {\n    return [];\n  },\n  transform: (data, panel, model) => {\n    model.columns.push({ text: 'Time', type: 'date' });\n\n    // group by time\n    const points: any = {};\n    const filteredData = timeSeriesFormatFilterer(data);\n\n    for (let i = 0; i < filteredData.length; i++) {\n      const series = filteredData[i];\n      model.columns.push({ text: series.target });\n\n      for (let y = 0; y < series.datapoints.length; y++) {\n        const dp = series.datapoints[y];\n        const timeKey = dp[1].toString();\n\n        if (!points[timeKey]) {\n          points[timeKey] = { time: dp[1] };\n          points[timeKey][i] = dp[0];\n        } else {\n          points[timeKey][i] = dp[0];\n        }\n      }\n    }\n\n    for (const time in points) {\n      const point = points[time];\n      const values = [point.time];\n\n      for (let i = 0; i < filteredData.length; i++) {\n        const value = point[i];\n        values.push(value);\n      }\n\n      model.rows.push(values);\n    }\n  },\n};\n\ntransformers['timeseries_aggregations'] = {\n  description: 'Time series aggregations',\n  getColumns: () => {\n    return [\n      { text: 'Avg', value: 'avg' },\n      { text: 'Min', value: 'min' },\n      { text: 'Max', value: 'max' },\n      { text: 'Total', value: 'total' },\n      { text: 'Current', value: 'current' },\n      { text: 'Count', value: 'count' },\n    ];\n  },\n  transform: (data, panel, model) => {\n    let i, y;\n    model.columns.push({ text: 'Metric' });\n\n    for (i = 0; i < panel.columns.length; i++) {\n      model.columns.push({ text: panel.columns[i].text });\n    }\n\n    const filteredData = timeSeriesFormatFilterer(data);\n\n    for (i = 0; i < filteredData.length; i++) {\n      const series = new TimeSeries({\n        datapoints: filteredData[i].datapoints,\n        alias: filteredData[i].target,\n      });\n\n      series.getFlotPairs('connected');\n      const cells = [series.alias];\n\n      for (y = 0; y < panel.columns.length; y++) {\n        cells.push(series.stats[panel.columns[y].value]);\n      }\n\n      model.rows.push(cells);\n    }\n  },\n};\n\ntransformers['annotations'] = {\n  description: 'Annotations',\n  getColumns: () => {\n    return [];\n  },\n  transform: (data, panel, model) => {\n    model.columns.push({ text: 'Time', type: 'date' });\n    model.columns.push({ text: 'Title' });\n    model.columns.push({ text: 'Text' });\n    model.columns.push({ text: 'Tags' });\n\n    if (!data || !data.annotations || data.annotations.length === 0) {\n      return;\n    }\n\n    for (let i = 0; i < data.annotations.length; i++) {\n      const evt = data.annotations[i];\n      model.rows.push([evt.time, evt.title, evt.text, evt.tags]);\n    }\n  },\n};\n\ntransformers['table'] = {\n  description: 'Table',\n  getColumns: (data) => {\n    if (!data || data.length === 0) {\n      return [];\n    }\n\n    // Single query returns data columns as is\n    if (data.length === 1) {\n      return [...data[0].columns];\n    }\n\n    const filteredData = tableDataFormatFilterer(data);\n\n    // Track column indexes: name -> index\n    const columnNames: any = {};\n\n    // Union of all columns\n    const columns = filteredData.reduce((acc: Column[], series: TableData) => {\n      series.columns.forEach((col) => {\n        const { text } = col;\n        if (columnNames[text] === undefined) {\n          columnNames[text] = acc.length;\n          acc.push(col);\n        }\n      });\n      return acc;\n    }, []);\n\n    return columns;\n  },\n  transform: (data: any[], panel, model) => {\n    if (!data || data.length === 0) {\n      return;\n    }\n    const filteredData = tableDataFormatFilterer(data);\n    const noTableIndex = findIndex(filteredData, (d) => 'columns' in d && 'rows' in d);\n    if (noTableIndex < 0) {\n      throw {\n        message: `Result of query #${String.fromCharCode(\n          65 + noTableIndex\n        )} is not in table format, try using another transform.`,\n      };\n    }\n\n    mergeTablesIntoModel(model, ...filteredData);\n  },\n};\n\ntransformers['json'] = {\n  description: 'JSON Data',\n  getColumns: (data) => {\n    if (!data || data.length === 0) {\n      return [];\n    }\n\n    const names: any = {};\n    for (let i = 0; i < data.length; i++) {\n      const series = data[i];\n      if (series.type !== 'docs') {\n        continue;\n      }\n\n      // only look at 100 docs\n      const maxDocs = Math.min(series.datapoints.length, 100);\n      for (let y = 0; y < maxDocs; y++) {\n        const doc = series.datapoints[y];\n        const flattened = flatten(doc, {});\n        for (const propName in flattened) {\n          names[propName] = true;\n        }\n      }\n    }\n\n    return map(names, (value, key) => {\n      return { text: key, value: key };\n    });\n  },\n  transform: (data, panel, model) => {\n    let i, y, z;\n\n    for (const column of panel.columns) {\n      const tableCol: any = { text: column.text };\n\n      // if filterable data then set columns to filterable\n      if (data.length > 0 && data[0].filterable) {\n        tableCol.filterable = true;\n      }\n\n      model.columns.push(tableCol);\n    }\n\n    if (model.columns.length === 0) {\n      model.columns.push({ text: 'JSON' });\n    }\n\n    for (i = 0; i < data.length; i++) {\n      const series = data[i];\n\n      for (y = 0; y < series.datapoints.length; y++) {\n        const dp = series.datapoints[y];\n        const values = [];\n\n        if (isObject(dp) && panel.columns.length > 0) {\n          const flattened = flatten(dp);\n          for (z = 0; z < panel.columns.length; z++) {\n            values.push(flattened[panel.columns[z].value]);\n          }\n        } else {\n          values.push(JSON.stringify(dp));\n        }\n\n        model.rows.push(values);\n      }\n    }\n  },\n};\n\nfunction transformDataToTable(data: any, panel: any) {\n  const model = new TableModel();\n\n  if (!data || data.length === 0) {\n    return model;\n  }\n\n  const transformer = transformers[panel.transform];\n  if (!transformer) {\n    throw { message: 'Transformer ' + panel.transform + ' not found' };\n  }\n\n  transformer.transform(data, panel, model);\n  return model;\n}\n\nexport { transformers, transformDataToTable };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}