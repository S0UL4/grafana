{"ast":null,"code":"/**\n * Mapping of log level abbreviation to canonical log level.\n * Supported levels are reduce to limit color variation.\n */\nexport let LogLevel; // Used for meta information such as common labels or returned log rows in logs view in Explore\n\n(function (LogLevel) {\n  LogLevel[\"emerg\"] = \"critical\";\n  LogLevel[\"fatal\"] = \"critical\";\n  LogLevel[\"alert\"] = \"critical\";\n  LogLevel[\"crit\"] = \"critical\";\n  LogLevel[\"critical\"] = \"critical\";\n  LogLevel[\"warn\"] = \"warning\";\n  LogLevel[\"warning\"] = \"warning\";\n  LogLevel[\"err\"] = \"error\";\n  LogLevel[\"eror\"] = \"error\";\n  LogLevel[\"error\"] = \"error\";\n  LogLevel[\"info\"] = \"info\";\n  LogLevel[\"information\"] = \"info\";\n  LogLevel[\"informational\"] = \"info\";\n  LogLevel[\"notice\"] = \"info\";\n  LogLevel[\"dbug\"] = \"debug\";\n  LogLevel[\"debug\"] = \"debug\";\n  LogLevel[\"trace\"] = \"trace\";\n  LogLevel[\"unknown\"] = \"unknown\";\n})(LogLevel || (LogLevel = {}));\n\nexport let LogsMetaKind;\n\n(function (LogsMetaKind) {\n  LogsMetaKind[LogsMetaKind[\"Number\"] = 0] = \"Number\";\n  LogsMetaKind[LogsMetaKind[\"String\"] = 1] = \"String\";\n  LogsMetaKind[LogsMetaKind[\"LabelsMap\"] = 2] = \"LabelsMap\";\n  LogsMetaKind[LogsMetaKind[\"Error\"] = 3] = \"Error\";\n})(LogsMetaKind || (LogsMetaKind = {}));\n\nexport let LogsSortOrder;\n\n(function (LogsSortOrder) {\n  LogsSortOrder[\"Descending\"] = \"Descending\";\n  LogsSortOrder[\"Ascending\"] = \"Ascending\";\n})(LogsSortOrder || (LogsSortOrder = {}));\n\nexport let LogsDedupStrategy;\n\n(function (LogsDedupStrategy) {\n  LogsDedupStrategy[\"none\"] = \"none\";\n  LogsDedupStrategy[\"exact\"] = \"exact\";\n  LogsDedupStrategy[\"numbers\"] = \"numbers\";\n  LogsDedupStrategy[\"signature\"] = \"signature\";\n})(LogsDedupStrategy || (LogsDedupStrategy = {}));\n\nexport let LogsDedupDescription;\n/**\n * Data sources that allow showing context rows around the provided LowRowModel should implement this method.\n * This will enable \"context\" button in Logs Panel.\n */\n\n(function (LogsDedupDescription) {\n  LogsDedupDescription[\"none\"] = \"No de-duplication\";\n  LogsDedupDescription[\"exact\"] = \"De-duplication of successive lines that are identical, ignoring ISO datetimes.\";\n  LogsDedupDescription[\"numbers\"] = \"De-duplication of successive lines that are identical when ignoring numbers, e.g., IP addresses, latencies.\";\n  LogsDedupDescription[\"signature\"] = \"De-duplication of successive lines that have identical punctuation and whitespace.\";\n})(LogsDedupDescription || (LogsDedupDescription = {}));\n\nexport const hasLogsContextSupport = datasource => {\n  if (!datasource) {\n    return false;\n  }\n\n  const withLogsSupport = datasource;\n  return withLogsSupport.getLogRowContext !== undefined && withLogsSupport.showContextToggle !== undefined;\n};","map":{"version":3,"names":["LogLevel","LogsMetaKind","LogsSortOrder","LogsDedupStrategy","LogsDedupDescription","hasLogsContextSupport","datasource","withLogsSupport","getLogRowContext","undefined","showContextToggle"],"sources":["/home/soula/grafana/packages/grafana-data/src/types/logs.ts"],"sourcesContent":["import { Labels } from './data';\nimport { DataFrame } from './dataFrame';\nimport { DataQueryResponse } from './datasource';\nimport { DataQuery } from './query';\nimport { AbsoluteTimeRange } from './time';\n\n/**\n * Mapping of log level abbreviation to canonical log level.\n * Supported levels are reduce to limit color variation.\n */\nexport enum LogLevel {\n  emerg = 'critical',\n  fatal = 'critical',\n  alert = 'critical',\n  crit = 'critical',\n  critical = 'critical',\n  warn = 'warning',\n  warning = 'warning',\n  err = 'error',\n  eror = 'error',\n  error = 'error',\n  info = 'info',\n  information = 'info',\n  informational = 'info',\n  notice = 'info',\n  dbug = 'debug',\n  debug = 'debug',\n  trace = 'trace',\n  unknown = 'unknown',\n}\n\n// Used for meta information such as common labels or returned log rows in logs view in Explore\nexport enum LogsMetaKind {\n  Number,\n  String,\n  LabelsMap,\n  Error,\n}\n\nexport enum LogsSortOrder {\n  Descending = 'Descending',\n  Ascending = 'Ascending',\n}\n\nexport interface LogsMetaItem {\n  label: string;\n  value: string | number | Labels;\n  kind: LogsMetaKind;\n}\n\nexport interface LogRowModel {\n  // Index of the field from which the entry has been created so that we do not show it later in log row details.\n  entryFieldIndex: number;\n\n  // Index of the row in the dataframe. As log rows can be stitched from multiple dataFrames, this does not have to be\n  // the same as rows final index when rendered.\n  rowIndex: number;\n\n  // Full DataFrame from which we parsed this log.\n  // TODO: refactor this so we do not need to pass whole dataframes in addition to also parsed data.\n  dataFrame: DataFrame;\n  duplicates?: number;\n\n  // Actual log line\n  entry: string;\n  hasAnsi: boolean;\n  hasUnescapedContent: boolean;\n  labels: Labels;\n  logLevel: LogLevel;\n  raw: string;\n  searchWords?: string[];\n  timeFromNow: string;\n  timeEpochMs: number;\n  // timeEpochNs stores time with nanosecond-level precision,\n  // as millisecond-level precision is usually not enough for proper sorting of logs\n  timeEpochNs: string;\n  timeLocal: string;\n  timeUtc: string;\n  uid: string;\n  uniqueLabels?: Labels;\n}\n\nexport interface LogsModel {\n  hasUniqueLabels: boolean;\n  meta?: LogsMetaItem[];\n  rows: LogRowModel[];\n  series?: DataFrame[];\n  // visibleRange is time range for histogram created from log results\n  visibleRange?: AbsoluteTimeRange;\n  queries?: DataQuery[];\n}\n\nexport interface LogSearchMatch {\n  start: number;\n  length: number;\n  text: string;\n}\n\nexport interface LogLabelStatsModel {\n  active?: boolean;\n  count: number;\n  proportion: number;\n  value: string;\n}\n\nexport enum LogsDedupStrategy {\n  none = 'none',\n  exact = 'exact',\n  numbers = 'numbers',\n  signature = 'signature',\n}\n\nexport interface LogsParser {\n  /**\n   * Value-agnostic matcher for a field label.\n   * Used to filter rows, and first capture group contains the value.\n   */\n  buildMatcher: (label: string) => RegExp;\n\n  /**\n   * Returns all parsable substrings from a line, used for highlighting\n   */\n  getFields: (line: string) => string[];\n\n  /**\n   * Gets the label name from a parsable substring of a line\n   */\n  getLabelFromField: (field: string) => string;\n\n  /**\n   * Gets the label value from a parsable substring of a line\n   */\n  getValueFromField: (field: string) => string;\n  /**\n   * Function to verify if this is a valid parser for the given line.\n   * The parser accepts the line if it returns true.\n   */\n  test: (line: string) => boolean;\n}\n\nexport enum LogsDedupDescription {\n  none = 'No de-duplication',\n  exact = 'De-duplication of successive lines that are identical, ignoring ISO datetimes.',\n  numbers = 'De-duplication of successive lines that are identical when ignoring numbers, e.g., IP addresses, latencies.',\n  signature = 'De-duplication of successive lines that have identical punctuation and whitespace.',\n}\n\n/**\n * Data sources that allow showing context rows around the provided LowRowModel should implement this method.\n * This will enable \"context\" button in Logs Panel.\n */\nexport interface DataSourceWithLogsContextSupport {\n  /**\n   * Retrieve context for a given log row\n   */\n  getLogRowContext: <TContextQueryOptions extends {}>(\n    row: LogRowModel,\n    options?: TContextQueryOptions\n  ) => Promise<DataQueryResponse>;\n\n  /**\n   * This method can be used to show \"context\" button based on runtime conditions (for example row model data or plugin settings, etc.)\n   */\n  showContextToggle(row?: LogRowModel): boolean;\n}\n\nexport const hasLogsContextSupport = (datasource: any): datasource is DataSourceWithLogsContextSupport => {\n  if (!datasource) {\n    return false;\n  }\n\n  const withLogsSupport = datasource as DataSourceWithLogsContextSupport;\n\n  return withLogsSupport.getLogRowContext !== undefined && withLogsSupport.showContextToggle !== undefined;\n};\n"],"mappings":"AAMA;AACA;AACA;AACA;AACA,WAAYA,QAAZ,C,CAqBA;;WArBYA,Q;EAAAA,Q;EAAAA,Q;EAAAA,Q;EAAAA,Q;EAAAA,Q;EAAAA,Q;EAAAA,Q;EAAAA,Q;EAAAA,Q;EAAAA,Q;EAAAA,Q;EAAAA,Q;EAAAA,Q;EAAAA,Q;EAAAA,Q;EAAAA,Q;EAAAA,Q;EAAAA,Q;GAAAA,Q,KAAAA,Q;;AAsBZ,WAAYC,YAAZ;;WAAYA,Y;EAAAA,Y,CAAAA,Y;EAAAA,Y,CAAAA,Y;EAAAA,Y,CAAAA,Y;EAAAA,Y,CAAAA,Y;GAAAA,Y,KAAAA,Y;;AAOZ,WAAYC,aAAZ;;WAAYA,a;EAAAA,a;EAAAA,a;GAAAA,a,KAAAA,a;;AAkEZ,WAAYC,iBAAZ;;WAAYA,iB;EAAAA,iB;EAAAA,iB;EAAAA,iB;EAAAA,iB;GAAAA,iB,KAAAA,iB;;AAmCZ,WAAYC,oBAAZ;AAOA;AACA;AACA;AACA;;WAVYA,oB;EAAAA,oB;EAAAA,oB;EAAAA,oB;EAAAA,oB;GAAAA,oB,KAAAA,oB;;AA0BZ,OAAO,MAAMC,qBAAqB,GAAIC,UAAD,IAAqE;EACxG,IAAI,CAACA,UAAL,EAAiB;IACf,OAAO,KAAP;EACD;;EAED,MAAMC,eAAe,GAAGD,UAAxB;EAEA,OAAOC,eAAe,CAACC,gBAAhB,KAAqCC,SAArC,IAAkDF,eAAe,CAACG,iBAAhB,KAAsCD,SAA/F;AACD,CARM"},"metadata":{},"sourceType":"module"}