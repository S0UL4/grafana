{"ast":null,"code":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { css } from '@emotion/css';\nimport * as React from 'react';\nimport { useStyles2 } from '@grafana/ui';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\n\nconst getStyles = () => {\n  return {\n    BreakableText: css`\n      label: BreakableText;\n      display: inline-block;\n      white-space: pre;\n    `\n  };\n};\n\nconst WORD_RX = /\\W*\\w+\\W*/g;\n// TODO typescript doesn't understand text or null as react nodes\n// https://github.com/Microsoft/TypeScript/issues/21699\nexport default function BreakableText(props)\n/* React.ReactNode /* React.ReactElement | React.ReactElement[] \\*\\/ */\n{\n  const {\n    className,\n    text,\n    wordRegexp = WORD_RX\n  } = props;\n  const styles = useStyles2(getStyles);\n\n  if (!text) {\n    return typeof text === 'string' ? text : null;\n  }\n\n  const spans = [];\n  wordRegexp.exec(''); // if the given text has no words, set the first match to the entire text\n\n  let match = wordRegexp.exec(text) || [text];\n\n  while (match) {\n    spans.push( /*#__PURE__*/_jsx(\"span\", {\n      className: className || styles.BreakableText,\n      children: match[0]\n    }, `${text}-${spans.length}`));\n    match = wordRegexp.exec(text);\n  }\n\n  return spans;\n}\nBreakableText.defaultProps = {\n  wordRegexp: WORD_RX\n};","map":{"version":3,"names":["css","React","useStyles2","getStyles","BreakableText","WORD_RX","props","className","text","wordRegexp","styles","spans","exec","match","push","length","defaultProps"],"sources":["/home/soula/grafana/packages/jaeger-ui-components/src/common/BreakableText.tsx"],"sourcesContent":["// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { css } from '@emotion/css';\nimport * as React from 'react';\n\nimport { useStyles2 } from '@grafana/ui';\n\nconst getStyles = () => {\n  return {\n    BreakableText: css`\n      label: BreakableText;\n      display: inline-block;\n      white-space: pre;\n    `,\n  };\n};\n\nconst WORD_RX = /\\W*\\w+\\W*/g;\n\ntype Props = {\n  text: string;\n  className?: string;\n  wordRegexp?: RegExp;\n};\n\n// TODO typescript doesn't understand text or null as react nodes\n// https://github.com/Microsoft/TypeScript/issues/21699\nexport default function BreakableText(\n  props: Props\n): any /* React.ReactNode /* React.ReactElement | React.ReactElement[] \\*\\/ */ {\n  const { className, text, wordRegexp = WORD_RX } = props;\n  const styles = useStyles2(getStyles);\n  if (!text) {\n    return typeof text === 'string' ? text : null;\n  }\n  const spans = [];\n  wordRegexp.exec('');\n  // if the given text has no words, set the first match to the entire text\n  let match: RegExpExecArray | string[] | null = wordRegexp.exec(text) || [text];\n  while (match) {\n    spans.push(\n      <span key={`${text}-${spans.length}`} className={className || styles.BreakableText}>\n        {match[0]}\n      </span>\n    );\n    match = wordRegexp.exec(text);\n  }\n  return spans;\n}\n\nBreakableText.defaultProps = {\n  wordRegexp: WORD_RX,\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,SAASA,GAAT,QAAoB,cAApB;AACA,OAAO,KAAKC,KAAZ,MAAuB,OAAvB;AAEA,SAASC,UAAT,QAA2B,aAA3B;;;AAEA,MAAMC,SAAS,GAAG,MAAM;EACtB,OAAO;IACLC,aAAa,EAAEJ,GAAI;AACvB;AACA;AACA;AACA;EALS,CAAP;AAOD,CARD;;AAUA,MAAMK,OAAO,GAAG,YAAhB;AAQA;AACA;AACA,eAAe,SAASD,aAAT,CACbE,KADa;AAER;AAAwE;EAC7E,MAAM;IAAEC,SAAF;IAAaC,IAAb;IAAmBC,UAAU,GAAGJ;EAAhC,IAA4CC,KAAlD;EACA,MAAMI,MAAM,GAAGR,UAAU,CAACC,SAAD,CAAzB;;EACA,IAAI,CAACK,IAAL,EAAW;IACT,OAAO,OAAOA,IAAP,KAAgB,QAAhB,GAA2BA,IAA3B,GAAkC,IAAzC;EACD;;EACD,MAAMG,KAAK,GAAG,EAAd;EACAF,UAAU,CAACG,IAAX,CAAgB,EAAhB,EAP6E,CAQ7E;;EACA,IAAIC,KAAwC,GAAGJ,UAAU,CAACG,IAAX,CAAgBJ,IAAhB,KAAyB,CAACA,IAAD,CAAxE;;EACA,OAAOK,KAAP,EAAc;IACZF,KAAK,CAACG,IAAN,eACE;MAAsC,SAAS,EAAEP,SAAS,IAAIG,MAAM,CAACN,aAArE;MAAA,UACGS,KAAK,CAAC,CAAD;IADR,GAAY,GAAEL,IAAK,IAAGG,KAAK,CAACI,MAAO,EAAnC,CADF;IAKAF,KAAK,GAAGJ,UAAU,CAACG,IAAX,CAAgBJ,IAAhB,CAAR;EACD;;EACD,OAAOG,KAAP;AACD;AAEDP,aAAa,CAACY,YAAd,GAA6B;EAC3BP,UAAU,EAAEJ;AADe,CAA7B"},"metadata":{},"sourceType":"module"}