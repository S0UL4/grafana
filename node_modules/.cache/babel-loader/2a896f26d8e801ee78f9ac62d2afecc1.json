{"ast":null,"code":"import { css, cx } from '@emotion/css';\nimport React, { useEffect, useMemo, useState } from 'react';\nimport { Button, Segment, useStyles2 } from '@grafana/ui';\nimport { actions } from '../state/actions';\nimport { useDispatch } from '../state/context';\nimport { mapFuncDefsToSelectables } from './helpers';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport function AddGraphiteFunction({\n  funcDefs\n}) {\n  const dispatch = useDispatch();\n  const [value, setValue] = useState(undefined);\n  const styles = useStyles2(getStyles);\n  const options = useMemo(() => mapFuncDefsToSelectables(funcDefs), [funcDefs]); // Note: actions.addFunction will add a component that will have a dropdown or input in auto-focus\n  // (the first param of the function). This auto-focus will cause onBlur() on AddGraphiteFunction's\n  // Segment component and trigger onChange once again. (why? we call onChange if the user dismissed\n  // the dropdown, see: SegmentSelect.onCloseMenu for more details). To avoid it we need to wait for\n  // the Segment to disappear first (hence useEffect) and then dispatch the action that will add new\n  // components.\n\n  useEffect(() => {\n    if ((value === null || value === void 0 ? void 0 : value.value) !== undefined) {\n      dispatch(actions.addFunction({\n        name: value.value\n      }));\n      setValue(undefined);\n    }\n  }, [value, dispatch]);\n  return /*#__PURE__*/_jsx(Segment, {\n    Component: /*#__PURE__*/_jsx(Button, {\n      icon: \"plus\",\n      variant: \"secondary\",\n      className: cx(styles.button),\n      \"aria-label\": \"Add new function\"\n    }),\n    options: options,\n    onChange: setValue,\n    inputMinWidth: 150\n  });\n}\n\nfunction getStyles(theme) {\n  return {\n    button: css`\n      margin-right: ${theme.spacing(0.5)};\n    `\n  };\n}","map":{"version":3,"names":["css","cx","React","useEffect","useMemo","useState","Button","Segment","useStyles2","actions","useDispatch","mapFuncDefsToSelectables","AddGraphiteFunction","funcDefs","dispatch","value","setValue","undefined","styles","getStyles","options","addFunction","name","button","theme","spacing"],"sources":["/home/soula/grafana/public/app/plugins/datasource/graphite/components/AddGraphiteFunction.tsx"],"sourcesContent":["import { css, cx } from '@emotion/css';\nimport React, { useEffect, useMemo, useState } from 'react';\n\nimport { GrafanaTheme2, SelectableValue } from '@grafana/data';\nimport { Button, Segment, useStyles2 } from '@grafana/ui';\n\nimport { FuncDefs } from '../gfunc';\nimport { actions } from '../state/actions';\nimport { useDispatch } from '../state/context';\n\nimport { mapFuncDefsToSelectables } from './helpers';\n\ntype Props = {\n  funcDefs: FuncDefs;\n};\n\nexport function AddGraphiteFunction({ funcDefs }: Props) {\n  const dispatch = useDispatch();\n  const [value, setValue] = useState<SelectableValue<string> | undefined>(undefined);\n  const styles = useStyles2(getStyles);\n\n  const options = useMemo(() => mapFuncDefsToSelectables(funcDefs), [funcDefs]);\n\n  // Note: actions.addFunction will add a component that will have a dropdown or input in auto-focus\n  // (the first param of the function). This auto-focus will cause onBlur() on AddGraphiteFunction's\n  // Segment component and trigger onChange once again. (why? we call onChange if the user dismissed\n  // the dropdown, see: SegmentSelect.onCloseMenu for more details). To avoid it we need to wait for\n  // the Segment to disappear first (hence useEffect) and then dispatch the action that will add new\n  // components.\n  useEffect(() => {\n    if (value?.value !== undefined) {\n      dispatch(actions.addFunction({ name: value.value }));\n      setValue(undefined);\n    }\n  }, [value, dispatch]);\n\n  return (\n    <Segment\n      Component={<Button icon=\"plus\" variant=\"secondary\" className={cx(styles.button)} aria-label=\"Add new function\" />}\n      options={options}\n      onChange={setValue}\n      inputMinWidth={150}\n    />\n  );\n}\n\nfunction getStyles(theme: GrafanaTheme2) {\n  return {\n    button: css`\n      margin-right: ${theme.spacing(0.5)};\n    `,\n  };\n}\n"],"mappings":"AAAA,SAASA,GAAT,EAAcC,EAAd,QAAwB,cAAxB;AACA,OAAOC,KAAP,IAAgBC,SAAhB,EAA2BC,OAA3B,EAAoCC,QAApC,QAAoD,OAApD;AAGA,SAASC,MAAT,EAAiBC,OAAjB,EAA0BC,UAA1B,QAA4C,aAA5C;AAGA,SAASC,OAAT,QAAwB,kBAAxB;AACA,SAASC,WAAT,QAA4B,kBAA5B;AAEA,SAASC,wBAAT,QAAyC,WAAzC;;AAMA,OAAO,SAASC,mBAAT,CAA6B;EAAEC;AAAF,CAA7B,EAAkD;EACvD,MAAMC,QAAQ,GAAGJ,WAAW,EAA5B;EACA,MAAM,CAACK,KAAD,EAAQC,QAAR,IAAoBX,QAAQ,CAAsCY,SAAtC,CAAlC;EACA,MAAMC,MAAM,GAAGV,UAAU,CAACW,SAAD,CAAzB;EAEA,MAAMC,OAAO,GAAGhB,OAAO,CAAC,MAAMO,wBAAwB,CAACE,QAAD,CAA/B,EAA2C,CAACA,QAAD,CAA3C,CAAvB,CALuD,CAOvD;EACA;EACA;EACA;EACA;EACA;;EACAV,SAAS,CAAC,MAAM;IACd,IAAI,CAAAY,KAAK,SAAL,IAAAA,KAAK,WAAL,YAAAA,KAAK,CAAEA,KAAP,MAAiBE,SAArB,EAAgC;MAC9BH,QAAQ,CAACL,OAAO,CAACY,WAAR,CAAoB;QAAEC,IAAI,EAAEP,KAAK,CAACA;MAAd,CAApB,CAAD,CAAR;MACAC,QAAQ,CAACC,SAAD,CAAR;IACD;EACF,CALQ,EAKN,CAACF,KAAD,EAAQD,QAAR,CALM,CAAT;EAOA,oBACE,KAAC,OAAD;IACE,SAAS,eAAE,KAAC,MAAD;MAAQ,IAAI,EAAC,MAAb;MAAoB,OAAO,EAAC,WAA5B;MAAwC,SAAS,EAAEb,EAAE,CAACiB,MAAM,CAACK,MAAR,CAArD;MAAsE,cAAW;IAAjF,EADb;IAEE,OAAO,EAAEH,OAFX;IAGE,QAAQ,EAAEJ,QAHZ;IAIE,aAAa,EAAE;EAJjB,EADF;AAQD;;AAED,SAASG,SAAT,CAAmBK,KAAnB,EAAyC;EACvC,OAAO;IACLD,MAAM,EAAEvB,GAAI;AAChB,sBAAsBwB,KAAK,CAACC,OAAN,CAAc,GAAd,CAAmB;AACzC;EAHS,CAAP;AAKD"},"metadata":{},"sourceType":"module"}