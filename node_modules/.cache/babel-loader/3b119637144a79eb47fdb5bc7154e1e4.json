{"ast":null,"code":"import { size } from 'lodash';\nimport { Observable } from 'rxjs';\nimport { dateTimeFormat, dateTimeFormatTimeAgo, FieldCache, FieldColorModeId, FieldType, findCommonLabels, findUniqueLabels, getLogLevel, getLogLevelFromKey, LoadingState, LogLevel, LogsDedupStrategy, LogsMetaKind, MutableDataFrame, rangeUtil, sortInAscendingOrder, textUtil, toDataFrame, toUtc } from '@grafana/data';\nimport { SIPrefix } from '@grafana/data/src/valueFormats/symbolFormatters';\nimport { BarAlignment, GraphDrawStyle, StackingMode } from '@grafana/schema';\nimport { ansicolor, colors } from '@grafana/ui';\nimport { getThemeColor } from 'app/core/utils/colors';\nexport const LIMIT_LABEL = 'Line limit';\nexport const COMMON_LABELS = 'Common labels';\nexport const LogLevelColor = {\n  [LogLevel.critical]: colors[7],\n  [LogLevel.warning]: colors[1],\n  [LogLevel.error]: colors[4],\n  [LogLevel.info]: colors[0],\n  [LogLevel.debug]: colors[5],\n  [LogLevel.trace]: colors[2],\n  [LogLevel.unknown]: getThemeColor('#8e8e8e', '#dde4ed')\n};\nconst MILLISECOND = 1;\nconst SECOND = 1000 * MILLISECOND;\nconst MINUTE = 60 * SECOND;\nconst HOUR = 60 * MINUTE;\nconst DAY = 24 * HOUR;\nconst isoDateRegexp = /\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-6]\\d[,\\.]\\d+([+-][0-2]\\d:[0-5]\\d|Z)/g;\n\nfunction isDuplicateRow(row, other, strategy) {\n  switch (strategy) {\n    case LogsDedupStrategy.exact:\n      // Exact still strips dates\n      return row.entry.replace(isoDateRegexp, '') === other.entry.replace(isoDateRegexp, '');\n\n    case LogsDedupStrategy.numbers:\n      return row.entry.replace(/\\d/g, '') === other.entry.replace(/\\d/g, '');\n\n    case LogsDedupStrategy.signature:\n      return row.entry.replace(/\\w/g, '') === other.entry.replace(/\\w/g, '');\n\n    default:\n      return false;\n  }\n}\n\nexport function dedupLogRows(rows, strategy) {\n  if (strategy === LogsDedupStrategy.none) {\n    return rows;\n  }\n\n  return rows.reduce((result, row, index) => {\n    const rowCopy = Object.assign({}, row);\n    const previous = result[result.length - 1];\n\n    if (index > 0 && isDuplicateRow(row, previous, strategy)) {\n      previous.duplicates++;\n    } else {\n      rowCopy.duplicates = 0;\n      result.push(rowCopy);\n    }\n\n    return result;\n  }, []);\n}\nexport function filterLogLevels(logRows, hiddenLogLevels) {\n  if (hiddenLogLevels.size === 0) {\n    return logRows;\n  }\n\n  return logRows.filter(row => {\n    return !hiddenLogLevels.has(row.logLevel);\n  });\n}\nexport function makeDataFramesForLogs(sortedRows, bucketSize) {\n  // currently interval is rangeMs / resolution, which is too low for showing series as bars.\n  // Should be solved higher up the chain when executing queries & interval calculated and not here but this is a temporary fix.\n  // Graph time series by log level\n  const seriesByLevel = {};\n  const seriesList = [];\n\n  for (const row of sortedRows) {\n    let series = seriesByLevel[row.logLevel];\n\n    if (!series) {\n      seriesByLevel[row.logLevel] = series = {\n        lastTs: null,\n        datapoints: [],\n        target: row.logLevel,\n        color: LogLevelColor[row.logLevel]\n      };\n      seriesList.push(series);\n    } // align time to bucket size - used Math.floor for calculation as time of the bucket\n    // must be in the past (before Date.now()) to be displayed on the graph\n\n\n    const time = Math.floor(row.timeEpochMs / bucketSize) * bucketSize; // Entry for time\n\n    if (time === series.lastTs) {\n      series.datapoints[series.datapoints.length - 1][0]++;\n    } else {\n      series.datapoints.push([1, time]);\n      series.lastTs = time;\n    } // add zero to other levels to aid stacking so each level series has same number of points\n\n\n    for (const other of seriesList) {\n      if (other !== series && other.lastTs !== time) {\n        other.datapoints.push([0, time]);\n        other.lastTs = time;\n      }\n    }\n  }\n\n  return seriesList.map((series, i) => {\n    series.datapoints.sort((a, b) => a[1] - b[1]);\n    const data = toDataFrame(series);\n    const fieldCache = new FieldCache(data);\n    const valueField = fieldCache.getFirstFieldOfType(FieldType.number);\n    data.fields[valueField.index].config.min = 0;\n    data.fields[valueField.index].config.decimals = 0;\n    data.fields[valueField.index].config.color = {\n      mode: FieldColorModeId.Fixed,\n      fixedColor: series.color\n    };\n    data.fields[valueField.index].config.custom = {\n      drawStyle: GraphDrawStyle.Bars,\n      barAlignment: BarAlignment.Center,\n      barWidthFactor: 0.9,\n      barMaxWidth: 5,\n      lineColor: series.color,\n      pointColor: series.color,\n      fillColor: series.color,\n      lineWidth: 0,\n      fillOpacity: 100,\n      stacking: {\n        mode: StackingMode.Normal,\n        group: 'A'\n      }\n    };\n    return data;\n  });\n}\n\nfunction isLogsData(series) {\n  return series.fields.some(f => f.type === FieldType.time) && series.fields.some(f => f.type === FieldType.string);\n}\n/**\n * Convert dataFrame into LogsModel which consists of creating separate array of log rows and metrics series. Metrics\n * series can be either already included in the dataFrame or will be computed from the log rows.\n * @param dataFrame\n * @param intervalMs In case there are no metrics series, we use this for computing it from log rows.\n */\n\n\nexport function dataFrameToLogsModel(dataFrame, intervalMs, absoluteRange, queries) {\n  const {\n    logSeries\n  } = separateLogsAndMetrics(dataFrame);\n  const logsModel = logSeriesToLogsModel(logSeries);\n\n  if (logsModel) {\n    // Create histogram metrics from logs using the interval as bucket size for the line count\n    if (intervalMs && logsModel.rows.length > 0) {\n      const sortedRows = logsModel.rows.sort(sortInAscendingOrder);\n      const {\n        visibleRange,\n        bucketSize,\n        visibleRangeMs,\n        requestedRangeMs\n      } = getSeriesProperties(sortedRows, intervalMs, absoluteRange);\n      logsModel.visibleRange = visibleRange;\n      logsModel.series = makeDataFramesForLogs(sortedRows, bucketSize);\n\n      if (logsModel.meta) {\n        logsModel.meta = adjustMetaInfo(logsModel, visibleRangeMs, requestedRangeMs);\n      }\n    } else {\n      logsModel.series = [];\n    }\n\n    logsModel.queries = queries;\n    return logsModel;\n  }\n\n  return {\n    hasUniqueLabels: false,\n    rows: [],\n    meta: [],\n    series: [],\n    queries\n  };\n}\n/**\n * Returns a clamped time range and interval based on the visible logs and the given range.\n *\n * @param sortedRows Log rows from the query response\n * @param intervalMs Dynamic data interval based on available pixel width\n * @param absoluteRange Requested time range\n * @param pxPerBar Default: 20, buckets will be rendered as bars, assuming 10px per histogram bar plus some free space around it\n */\n\nexport function getSeriesProperties(sortedRows, intervalMs, absoluteRange, pxPerBar = 20, minimumBucketSize = 1000) {\n  let visibleRange = absoluteRange;\n  let resolutionIntervalMs = intervalMs;\n  let bucketSize = Math.max(resolutionIntervalMs * pxPerBar, minimumBucketSize);\n  let visibleRangeMs;\n  let requestedRangeMs; // Clamp time range to visible logs otherwise big parts of the graph might look empty\n\n  if (absoluteRange) {\n    const earliestTsLogs = sortedRows[0].timeEpochMs;\n    requestedRangeMs = absoluteRange.to - absoluteRange.from;\n    visibleRangeMs = absoluteRange.to - earliestTsLogs;\n\n    if (visibleRangeMs > 0) {\n      // Adjust interval bucket size for potentially shorter visible range\n      const clampingFactor = visibleRangeMs / requestedRangeMs;\n      resolutionIntervalMs *= clampingFactor; // Minimum bucketsize of 1s for nicer graphing\n\n      bucketSize = Math.max(Math.ceil(resolutionIntervalMs * pxPerBar), minimumBucketSize); // makeSeriesForLogs() aligns dataspoints with time buckets, so we do the same here to not cut off data\n\n      const adjustedEarliest = Math.floor(earliestTsLogs / bucketSize) * bucketSize;\n      visibleRange = {\n        from: adjustedEarliest,\n        to: absoluteRange.to\n      };\n    } else {\n      // We use visibleRangeMs to calculate range coverage of received logs. However, some data sources are rounding up range in requests. This means that received logs\n      // can (in edge cases) be outside of the requested range and visibleRangeMs < 0. In that case, we want to change visibleRangeMs to be 1 so we can calculate coverage.\n      visibleRangeMs = 1;\n    }\n  }\n\n  return {\n    bucketSize,\n    visibleRange,\n    visibleRangeMs,\n    requestedRangeMs\n  };\n}\n\nfunction separateLogsAndMetrics(dataFrames) {\n  const metricSeries = [];\n  const logSeries = [];\n\n  for (const dataFrame of dataFrames) {\n    // We want to show meta stats even if no result was returned. That's why we are pushing also data frames with no fields.\n    if (isLogsData(dataFrame) || !dataFrame.fields.length) {\n      logSeries.push(dataFrame);\n      continue;\n    }\n\n    if (dataFrame.length > 0) {\n      metricSeries.push(dataFrame);\n    }\n  }\n\n  return {\n    logSeries,\n    metricSeries\n  };\n}\n\nfunction getAllLabels(fields) {\n  // there are two types of dataframes we handle:\n  // 1. labels are in a separate field (more efficient when labels change by every log-row)\n  // 2. labels are in in the string-field's `.labels` attribute\n  const {\n    stringField,\n    labelsField\n  } = fields;\n\n  if (labelsField !== undefined) {\n    return labelsField.values.toArray();\n  } else {\n    var _stringField$labels;\n\n    return [(_stringField$labels = stringField.labels) !== null && _stringField$labels !== void 0 ? _stringField$labels : {}];\n  }\n}\n\nfunction getLabelsForFrameRow(fields, index) {\n  // there are two types of dataframes we handle.\n  // either labels-on-the-string-field, or labels-in-the-labels-field\n  const {\n    stringField,\n    labelsField\n  } = fields;\n\n  if (labelsField !== undefined) {\n    return labelsField.values.get(index);\n  } else {\n    var _stringField$labels2;\n\n    return (_stringField$labels2 = stringField.labels) !== null && _stringField$labels2 !== void 0 ? _stringField$labels2 : {};\n  }\n}\n/**\n * Converts dataFrames into LogsModel. This involves merging them into one list, sorting them and computing metadata\n * like common labels.\n */\n\n\nexport function logSeriesToLogsModel(logSeries) {\n  if (logSeries.length === 0) {\n    return undefined;\n  }\n\n  const allLabels = []; // Find the fields we care about and collect all labels\n\n  let allSeries = []; // We are sometimes passing data frames with no fields because we want to calculate correct meta stats.\n  // Therefore we need to filter out series with no fields. These series are used only for meta stats calculation.\n\n  const seriesWithFields = logSeries.filter(series => series.fields.length);\n\n  if (seriesWithFields.length) {\n    seriesWithFields.forEach(series => {\n      var _series$meta, _series$meta$custom;\n\n      const fieldCache = new FieldCache(series);\n      const stringField = fieldCache.getFirstFieldOfType(FieldType.string);\n      const timeField = fieldCache.getFirstFieldOfType(FieldType.time); // NOTE: this is experimental, please do not use in your code.\n      // we will get this custom-frame-type into the \"real\" frame-type list soon,\n      // but the name might change, so please do not use it until then.\n\n      const labelsField = ((_series$meta = series.meta) === null || _series$meta === void 0 ? void 0 : (_series$meta$custom = _series$meta.custom) === null || _series$meta$custom === void 0 ? void 0 : _series$meta$custom.frameType) === 'LabeledTimeValues' ? fieldCache.getFieldByName('labels') : undefined;\n\n      if (stringField !== undefined && timeField !== undefined) {\n        const info = {\n          series,\n          timeField,\n          labelsField,\n          timeNanosecondField: fieldCache.getFieldByName('tsNs'),\n          stringField,\n          logLevelField: fieldCache.getFieldByName('level'),\n          idField: getIdField(fieldCache)\n        };\n        allSeries.push(info);\n        const labels = getAllLabels(info);\n\n        if (labels.length > 0) {\n          allLabels.push(labels);\n        }\n      }\n    });\n  }\n\n  const flatAllLabels = allLabels.flat();\n  const commonLabels = flatAllLabels.length > 0 ? findCommonLabels(flatAllLabels) : {};\n  const rows = [];\n  let hasUniqueLabels = false;\n\n  for (const info of allSeries) {\n    const {\n      timeField,\n      timeNanosecondField,\n      stringField,\n      logLevelField,\n      idField,\n      series\n    } = info;\n\n    for (let j = 0; j < series.length; j++) {\n      var _stringField$values$g;\n\n      const ts = timeField.values.get(j);\n      const time = toUtc(ts);\n      const tsNs = timeNanosecondField ? timeNanosecondField.values.get(j) : undefined;\n      const timeEpochNs = tsNs ? tsNs : time.valueOf() + '000000'; // In edge cases, this can be undefined. If undefined, we want to replace it with empty string.\n\n      const messageValue = (_stringField$values$g = stringField.values.get(j)) !== null && _stringField$values$g !== void 0 ? _stringField$values$g : ''; // This should be string but sometimes isn't (eg elastic) because the dataFrame is not strongly typed.\n\n      const message = typeof messageValue === 'string' ? messageValue : JSON.stringify(messageValue);\n      const hasAnsi = textUtil.hasAnsiCodes(message);\n      const hasUnescapedContent = !!message.match(/\\\\n|\\\\t|\\\\r/);\n      const searchWords = series.meta && series.meta.searchWords ? series.meta.searchWords : [];\n      const entry = hasAnsi ? ansicolor.strip(message) : message;\n      const labels = getLabelsForFrameRow(info, j);\n      const uniqueLabels = findUniqueLabels(labels, commonLabels);\n\n      if (Object.keys(uniqueLabels).length > 0) {\n        hasUniqueLabels = true;\n      }\n\n      let logLevel = LogLevel.unknown;\n      const logLevelKey = logLevelField && logLevelField.values.get(j) || labels && labels['level'];\n\n      if (logLevelKey) {\n        logLevel = getLogLevelFromKey(logLevelKey);\n      } else {\n        logLevel = getLogLevel(entry);\n      }\n\n      rows.push({\n        entryFieldIndex: stringField.index,\n        rowIndex: j,\n        dataFrame: series,\n        logLevel,\n        timeFromNow: dateTimeFormatTimeAgo(ts),\n        timeEpochMs: time.valueOf(),\n        timeEpochNs,\n        timeLocal: dateTimeFormat(ts, {\n          timeZone: 'browser'\n        }),\n        timeUtc: dateTimeFormat(ts, {\n          timeZone: 'utc'\n        }),\n        uniqueLabels,\n        hasAnsi,\n        hasUnescapedContent,\n        searchWords,\n        entry,\n        raw: message,\n        labels: labels || {},\n        uid: idField ? idField.values.get(j) : j.toString()\n      });\n    }\n  } // Meta data to display in status\n\n\n  const meta = [];\n\n  if (size(commonLabels) > 0) {\n    meta.push({\n      label: COMMON_LABELS,\n      value: commonLabels,\n      kind: LogsMetaKind.LabelsMap\n    });\n  }\n\n  const limits = logSeries.filter(series => series.meta && series.meta.limit);\n  const limitValue = Object.values(limits.reduce((acc, elem) => {\n    acc[elem.refId] = elem.meta.limit;\n    return acc;\n  }, {})).reduce((acc, elem) => acc += elem, 0);\n\n  if (limitValue > 0) {\n    meta.push({\n      label: LIMIT_LABEL,\n      value: limitValue,\n      kind: LogsMetaKind.Number\n    });\n  }\n\n  let totalBytes = 0;\n  const queriesVisited = {}; // To add just 1 error message\n\n  let errorMetaAdded = false;\n\n  for (const series of logSeries) {\n    var _series$meta2, _series$meta2$custom, _series$meta3, _series$meta3$custom;\n\n    const totalBytesKey = (_series$meta2 = series.meta) === null || _series$meta2 === void 0 ? void 0 : (_series$meta2$custom = _series$meta2.custom) === null || _series$meta2$custom === void 0 ? void 0 : _series$meta2$custom.lokiQueryStatKey;\n    const {\n      refId\n    } = series; // Stats are per query, keeping track by refId\n\n    if (!errorMetaAdded && (_series$meta3 = series.meta) !== null && _series$meta3 !== void 0 && (_series$meta3$custom = _series$meta3.custom) !== null && _series$meta3$custom !== void 0 && _series$meta3$custom.error) {\n      var _series$meta4;\n\n      meta.push({\n        label: '',\n        value: (_series$meta4 = series.meta) === null || _series$meta4 === void 0 ? void 0 : _series$meta4.custom.error,\n        kind: LogsMetaKind.Error\n      });\n      errorMetaAdded = true;\n    }\n\n    if (refId && !queriesVisited[refId]) {\n      var _series$meta5;\n\n      if (totalBytesKey && (_series$meta5 = series.meta) !== null && _series$meta5 !== void 0 && _series$meta5.stats) {\n        const byteStat = series.meta.stats.find(stat => stat.displayName === totalBytesKey);\n\n        if (byteStat) {\n          totalBytes += byteStat.value;\n        }\n      }\n\n      queriesVisited[refId] = true;\n    }\n  }\n\n  if (totalBytes > 0) {\n    const {\n      text,\n      suffix\n    } = SIPrefix('B')(totalBytes);\n    meta.push({\n      label: 'Total bytes processed',\n      value: `${text} ${suffix}`,\n      kind: LogsMetaKind.String\n    });\n  }\n\n  return {\n    hasUniqueLabels,\n    meta,\n    rows\n  };\n}\n\nfunction getIdField(fieldCache) {\n  const idFieldNames = ['id'];\n\n  for (const fieldName of idFieldNames) {\n    const idField = fieldCache.getFieldByName(fieldName);\n\n    if (idField) {\n      return idField;\n    }\n  }\n\n  return undefined;\n} // Used to add additional information to Line limit meta info\n\n\nfunction adjustMetaInfo(logsModel, visibleRangeMs, requestedRangeMs) {\n  var _logsModelMeta$limitI;\n\n  let logsModelMeta = [...logsModel.meta];\n  const limitIndex = logsModelMeta.findIndex(meta => meta.label === LIMIT_LABEL);\n  const limit = limitIndex >= 0 && ((_logsModelMeta$limitI = logsModelMeta[limitIndex]) === null || _logsModelMeta$limitI === void 0 ? void 0 : _logsModelMeta$limitI.value);\n\n  if (limit && limit > 0) {\n    let metaLimitValue;\n\n    if (limit === logsModel.rows.length && visibleRangeMs && requestedRangeMs) {\n      const coverage = (visibleRangeMs / requestedRangeMs * 100).toFixed(2);\n      metaLimitValue = `${limit} reached, received logs cover ${coverage}% (${rangeUtil.msRangeToTimeString(visibleRangeMs)}) of your selected time range (${rangeUtil.msRangeToTimeString(requestedRangeMs)})`;\n    } else {\n      metaLimitValue = `${limit} (${logsModel.rows.length} returned)`;\n    }\n\n    logsModelMeta[limitIndex] = {\n      label: LIMIT_LABEL,\n      value: metaLimitValue,\n      kind: LogsMetaKind.String\n    };\n  }\n\n  return logsModelMeta;\n}\n/**\n * Returns field configuration used to render logs volume bars\n */\n\n\nfunction getLogVolumeFieldConfig(level, oneLevelDetected) {\n  const name = oneLevelDetected && level === LogLevel.unknown ? 'logs' : level;\n  const color = LogLevelColor[level];\n  return {\n    displayNameFromDS: name,\n    color: {\n      mode: FieldColorModeId.Fixed,\n      fixedColor: color\n    },\n    custom: {\n      drawStyle: GraphDrawStyle.Bars,\n      barAlignment: BarAlignment.Center,\n      lineColor: color,\n      pointColor: color,\n      fillColor: color,\n      lineWidth: 1,\n      fillOpacity: 100,\n      stacking: {\n        mode: StackingMode.Normal,\n        group: 'A'\n      }\n    }\n  };\n}\n/**\n * Take multiple data frames, sum up values and group by level.\n * Return a list of data frames, each representing single level.\n */\n\n\nexport function aggregateRawLogsVolume(rawLogsVolume, extractLevel) {\n  const logsVolumeByLevelMap = {};\n  rawLogsVolume.forEach(dataFrame => {\n    const level = extractLevel(dataFrame);\n\n    if (!logsVolumeByLevelMap[level]) {\n      logsVolumeByLevelMap[level] = [];\n    }\n\n    logsVolumeByLevelMap[level].push(dataFrame);\n  });\n  return Object.keys(logsVolumeByLevelMap).map(level => {\n    return aggregateFields(logsVolumeByLevelMap[level], getLogVolumeFieldConfig(level, Object.keys(logsVolumeByLevelMap).length === 1));\n  });\n}\n/**\n * Aggregate multiple data frames into a single data frame by adding values.\n * Multiple data frames for the same level are passed here to get a single\n * data frame for a given level. Aggregation by level happens in aggregateRawLogsVolume()\n */\n\nfunction aggregateFields(dataFrames, config) {\n  const aggregatedDataFrame = new MutableDataFrame();\n\n  if (!dataFrames.length) {\n    return aggregatedDataFrame;\n  }\n\n  const totalLength = dataFrames[0].length;\n  const timeField = new FieldCache(dataFrames[0]).getFirstFieldOfType(FieldType.time);\n\n  if (!timeField) {\n    return aggregatedDataFrame;\n  }\n\n  aggregatedDataFrame.addField({\n    name: 'Time',\n    type: FieldType.time\n  }, totalLength);\n  aggregatedDataFrame.addField({\n    name: 'Value',\n    type: FieldType.number,\n    config\n  }, totalLength);\n  dataFrames.forEach(dataFrame => {\n    dataFrame.fields.forEach(field => {\n      if (field.type === FieldType.number) {\n        for (let pointIndex = 0; pointIndex < totalLength; pointIndex++) {\n          const currentValue = aggregatedDataFrame.get(pointIndex).Value;\n          const valueToAdd = field.values.get(pointIndex);\n          const totalValue = currentValue === null && valueToAdd === null ? null : (currentValue || 0) + (valueToAdd || 0);\n          aggregatedDataFrame.set(pointIndex, {\n            Value: totalValue,\n            Time: timeField.values.get(pointIndex)\n          });\n        }\n      }\n    });\n  });\n  return aggregatedDataFrame;\n}\n\n/**\n * Creates an observable, which makes requests to get logs volume and aggregates results.\n */\nexport function queryLogsVolume(datasource, logsVolumeRequest, options) {\n  const timespan = options.range.to.valueOf() - options.range.from.valueOf();\n  const intervalInfo = getIntervalInfo(logsVolumeRequest.scopedVars, timespan);\n  logsVolumeRequest.interval = intervalInfo.interval;\n  logsVolumeRequest.scopedVars.__interval = {\n    value: intervalInfo.interval,\n    text: intervalInfo.interval\n  };\n\n  if (intervalInfo.intervalMs !== undefined) {\n    logsVolumeRequest.intervalMs = intervalInfo.intervalMs;\n    logsVolumeRequest.scopedVars.__interval_ms = {\n      value: intervalInfo.intervalMs,\n      text: intervalInfo.intervalMs\n    };\n  }\n\n  return new Observable(observer => {\n    let rawLogsVolume = [];\n    observer.next({\n      state: LoadingState.Loading,\n      error: undefined,\n      data: []\n    });\n    const subscription = datasource.query(logsVolumeRequest).subscribe({\n      complete: () => {\n        const aggregatedLogsVolume = aggregateRawLogsVolume(rawLogsVolume, options.extractLevel);\n\n        if (aggregatedLogsVolume[0]) {\n          aggregatedLogsVolume[0].meta = {\n            custom: {\n              targets: options.targets,\n              absoluteRange: {\n                from: options.range.from.valueOf(),\n                to: options.range.to.valueOf()\n              }\n            }\n          };\n        }\n\n        observer.next({\n          state: LoadingState.Done,\n          error: undefined,\n          data: aggregatedLogsVolume\n        });\n        observer.complete();\n      },\n      next: dataQueryResponse => {\n        const {\n          error\n        } = dataQueryResponse;\n\n        if (error !== undefined) {\n          observer.next({\n            state: LoadingState.Error,\n            error,\n            data: []\n          });\n          observer.error(error);\n        } else {\n          rawLogsVolume = rawLogsVolume.concat(dataQueryResponse.data.map(toDataFrame));\n        }\n      },\n      error: error => {\n        observer.next({\n          state: LoadingState.Error,\n          error: error,\n          data: []\n        });\n        observer.error(error);\n      }\n    });\n    return () => {\n      subscription === null || subscription === void 0 ? void 0 : subscription.unsubscribe();\n    };\n  });\n}\n\nfunction getIntervalInfo(scopedVars, timespanMs) {\n  if (scopedVars.__interval) {\n    let intervalMs = scopedVars.__interval_ms.value;\n    let interval = ''; // below 5 seconds we force the resolution to be per 1ms as interval in scopedVars is not less than 10ms\n\n    if (timespanMs < SECOND * 5) {\n      intervalMs = MILLISECOND;\n      interval = '1ms';\n    } else if (intervalMs > HOUR) {\n      intervalMs = DAY;\n      interval = '1d';\n    } else if (intervalMs > MINUTE) {\n      intervalMs = HOUR;\n      interval = '1h';\n    } else if (intervalMs > SECOND) {\n      intervalMs = MINUTE;\n      interval = '1m';\n    } else {\n      intervalMs = SECOND;\n      interval = '1s';\n    }\n\n    return {\n      interval,\n      intervalMs\n    };\n  } else {\n    return {\n      interval: '$__interval'\n    };\n  }\n}","map":{"version":3,"names":["size","Observable","dateTimeFormat","dateTimeFormatTimeAgo","FieldCache","FieldColorModeId","FieldType","findCommonLabels","findUniqueLabels","getLogLevel","getLogLevelFromKey","LoadingState","LogLevel","LogsDedupStrategy","LogsMetaKind","MutableDataFrame","rangeUtil","sortInAscendingOrder","textUtil","toDataFrame","toUtc","SIPrefix","BarAlignment","GraphDrawStyle","StackingMode","ansicolor","colors","getThemeColor","LIMIT_LABEL","COMMON_LABELS","LogLevelColor","critical","warning","error","info","debug","trace","unknown","MILLISECOND","SECOND","MINUTE","HOUR","DAY","isoDateRegexp","isDuplicateRow","row","other","strategy","exact","entry","replace","numbers","signature","dedupLogRows","rows","none","reduce","result","index","rowCopy","previous","length","duplicates","push","filterLogLevels","logRows","hiddenLogLevels","filter","has","logLevel","makeDataFramesForLogs","sortedRows","bucketSize","seriesByLevel","seriesList","series","lastTs","datapoints","target","color","time","Math","floor","timeEpochMs","map","i","sort","a","b","data","fieldCache","valueField","getFirstFieldOfType","number","fields","config","min","decimals","mode","Fixed","fixedColor","custom","drawStyle","Bars","barAlignment","Center","barWidthFactor","barMaxWidth","lineColor","pointColor","fillColor","lineWidth","fillOpacity","stacking","Normal","group","isLogsData","some","f","type","string","dataFrameToLogsModel","dataFrame","intervalMs","absoluteRange","queries","logSeries","separateLogsAndMetrics","logsModel","logSeriesToLogsModel","visibleRange","visibleRangeMs","requestedRangeMs","getSeriesProperties","meta","adjustMetaInfo","hasUniqueLabels","pxPerBar","minimumBucketSize","resolutionIntervalMs","max","earliestTsLogs","to","from","clampingFactor","ceil","adjustedEarliest","dataFrames","metricSeries","getAllLabels","stringField","labelsField","undefined","values","toArray","labels","getLabelsForFrameRow","get","allLabels","allSeries","seriesWithFields","forEach","timeField","frameType","getFieldByName","timeNanosecondField","logLevelField","idField","getIdField","flatAllLabels","flat","commonLabels","j","ts","tsNs","timeEpochNs","valueOf","messageValue","message","JSON","stringify","hasAnsi","hasAnsiCodes","hasUnescapedContent","match","searchWords","strip","uniqueLabels","Object","keys","logLevelKey","entryFieldIndex","rowIndex","timeFromNow","timeLocal","timeZone","timeUtc","raw","uid","toString","label","value","kind","LabelsMap","limits","limit","limitValue","acc","elem","refId","Number","totalBytes","queriesVisited","errorMetaAdded","totalBytesKey","lokiQueryStatKey","Error","stats","byteStat","find","stat","displayName","text","suffix","String","idFieldNames","fieldName","logsModelMeta","limitIndex","findIndex","metaLimitValue","coverage","toFixed","msRangeToTimeString","getLogVolumeFieldConfig","level","oneLevelDetected","name","displayNameFromDS","aggregateRawLogsVolume","rawLogsVolume","extractLevel","logsVolumeByLevelMap","aggregateFields","aggregatedDataFrame","totalLength","addField","field","pointIndex","currentValue","Value","valueToAdd","totalValue","set","Time","queryLogsVolume","datasource","logsVolumeRequest","options","timespan","range","intervalInfo","getIntervalInfo","scopedVars","interval","__interval","__interval_ms","observer","next","state","Loading","subscription","query","subscribe","complete","aggregatedLogsVolume","targets","Done","dataQueryResponse","concat","unsubscribe","timespanMs"],"sources":["/home/soula/grafana/public/app/core/logs_model.ts"],"sourcesContent":["import { size } from 'lodash';\nimport { Observable } from 'rxjs';\n\nimport {\n  AbsoluteTimeRange,\n  DataFrame,\n  DataQuery,\n  DataQueryRequest,\n  DataQueryResponse,\n  DataSourceApi,\n  dateTimeFormat,\n  dateTimeFormatTimeAgo,\n  FieldCache,\n  FieldColorModeId,\n  FieldConfig,\n  FieldType,\n  FieldWithIndex,\n  findCommonLabels,\n  findUniqueLabels,\n  getLogLevel,\n  getLogLevelFromKey,\n  Labels,\n  LoadingState,\n  LogLevel,\n  LogRowModel,\n  LogsDedupStrategy,\n  LogsMetaItem,\n  LogsMetaKind,\n  LogsModel,\n  MutableDataFrame,\n  rangeUtil,\n  ScopedVars,\n  sortInAscendingOrder,\n  textUtil,\n  TimeRange,\n  toDataFrame,\n  toUtc,\n} from '@grafana/data';\nimport { SIPrefix } from '@grafana/data/src/valueFormats/symbolFormatters';\nimport { BarAlignment, GraphDrawStyle, StackingMode } from '@grafana/schema';\nimport { ansicolor, colors } from '@grafana/ui';\nimport { getThemeColor } from 'app/core/utils/colors';\n\nexport const LIMIT_LABEL = 'Line limit';\nexport const COMMON_LABELS = 'Common labels';\n\nexport const LogLevelColor = {\n  [LogLevel.critical]: colors[7],\n  [LogLevel.warning]: colors[1],\n  [LogLevel.error]: colors[4],\n  [LogLevel.info]: colors[0],\n  [LogLevel.debug]: colors[5],\n  [LogLevel.trace]: colors[2],\n  [LogLevel.unknown]: getThemeColor('#8e8e8e', '#dde4ed'),\n};\n\nconst MILLISECOND = 1;\nconst SECOND = 1000 * MILLISECOND;\nconst MINUTE = 60 * SECOND;\nconst HOUR = 60 * MINUTE;\nconst DAY = 24 * HOUR;\n\nconst isoDateRegexp = /\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-6]\\d[,\\.]\\d+([+-][0-2]\\d:[0-5]\\d|Z)/g;\nfunction isDuplicateRow(row: LogRowModel, other: LogRowModel, strategy?: LogsDedupStrategy): boolean {\n  switch (strategy) {\n    case LogsDedupStrategy.exact:\n      // Exact still strips dates\n      return row.entry.replace(isoDateRegexp, '') === other.entry.replace(isoDateRegexp, '');\n\n    case LogsDedupStrategy.numbers:\n      return row.entry.replace(/\\d/g, '') === other.entry.replace(/\\d/g, '');\n\n    case LogsDedupStrategy.signature:\n      return row.entry.replace(/\\w/g, '') === other.entry.replace(/\\w/g, '');\n\n    default:\n      return false;\n  }\n}\n\nexport function dedupLogRows(rows: LogRowModel[], strategy?: LogsDedupStrategy): LogRowModel[] {\n  if (strategy === LogsDedupStrategy.none) {\n    return rows;\n  }\n\n  return rows.reduce((result: LogRowModel[], row: LogRowModel, index) => {\n    const rowCopy = { ...row };\n    const previous = result[result.length - 1];\n    if (index > 0 && isDuplicateRow(row, previous, strategy)) {\n      previous.duplicates!++;\n    } else {\n      rowCopy.duplicates = 0;\n      result.push(rowCopy);\n    }\n    return result;\n  }, []);\n}\n\nexport function filterLogLevels(logRows: LogRowModel[], hiddenLogLevels: Set<LogLevel>): LogRowModel[] {\n  if (hiddenLogLevels.size === 0) {\n    return logRows;\n  }\n\n  return logRows.filter((row: LogRowModel) => {\n    return !hiddenLogLevels.has(row.logLevel);\n  });\n}\n\nexport function makeDataFramesForLogs(sortedRows: LogRowModel[], bucketSize: number): DataFrame[] {\n  // currently interval is rangeMs / resolution, which is too low for showing series as bars.\n  // Should be solved higher up the chain when executing queries & interval calculated and not here but this is a temporary fix.\n\n  // Graph time series by log level\n  const seriesByLevel: any = {};\n  const seriesList: any[] = [];\n\n  for (const row of sortedRows) {\n    let series = seriesByLevel[row.logLevel];\n\n    if (!series) {\n      seriesByLevel[row.logLevel] = series = {\n        lastTs: null,\n        datapoints: [],\n        target: row.logLevel,\n        color: LogLevelColor[row.logLevel],\n      };\n\n      seriesList.push(series);\n    }\n\n    // align time to bucket size - used Math.floor for calculation as time of the bucket\n    // must be in the past (before Date.now()) to be displayed on the graph\n    const time = Math.floor(row.timeEpochMs / bucketSize) * bucketSize;\n\n    // Entry for time\n    if (time === series.lastTs) {\n      series.datapoints[series.datapoints.length - 1][0]++;\n    } else {\n      series.datapoints.push([1, time]);\n      series.lastTs = time;\n    }\n\n    // add zero to other levels to aid stacking so each level series has same number of points\n    for (const other of seriesList) {\n      if (other !== series && other.lastTs !== time) {\n        other.datapoints.push([0, time]);\n        other.lastTs = time;\n      }\n    }\n  }\n\n  return seriesList.map((series, i) => {\n    series.datapoints.sort((a: number[], b: number[]) => a[1] - b[1]);\n\n    const data = toDataFrame(series);\n    const fieldCache = new FieldCache(data);\n\n    const valueField = fieldCache.getFirstFieldOfType(FieldType.number)!;\n\n    data.fields[valueField.index].config.min = 0;\n    data.fields[valueField.index].config.decimals = 0;\n    data.fields[valueField.index].config.color = {\n      mode: FieldColorModeId.Fixed,\n      fixedColor: series.color,\n    };\n\n    data.fields[valueField.index].config.custom = {\n      drawStyle: GraphDrawStyle.Bars,\n      barAlignment: BarAlignment.Center,\n      barWidthFactor: 0.9,\n      barMaxWidth: 5,\n      lineColor: series.color,\n      pointColor: series.color,\n      fillColor: series.color,\n      lineWidth: 0,\n      fillOpacity: 100,\n      stacking: {\n        mode: StackingMode.Normal,\n        group: 'A',\n      },\n    };\n\n    return data;\n  });\n}\n\nfunction isLogsData(series: DataFrame) {\n  return series.fields.some((f) => f.type === FieldType.time) && series.fields.some((f) => f.type === FieldType.string);\n}\n\n/**\n * Convert dataFrame into LogsModel which consists of creating separate array of log rows and metrics series. Metrics\n * series can be either already included in the dataFrame or will be computed from the log rows.\n * @param dataFrame\n * @param intervalMs In case there are no metrics series, we use this for computing it from log rows.\n */\nexport function dataFrameToLogsModel(\n  dataFrame: DataFrame[],\n  intervalMs: number | undefined,\n  absoluteRange?: AbsoluteTimeRange,\n  queries?: DataQuery[]\n): LogsModel {\n  const { logSeries } = separateLogsAndMetrics(dataFrame);\n  const logsModel = logSeriesToLogsModel(logSeries);\n\n  if (logsModel) {\n    // Create histogram metrics from logs using the interval as bucket size for the line count\n    if (intervalMs && logsModel.rows.length > 0) {\n      const sortedRows = logsModel.rows.sort(sortInAscendingOrder);\n      const { visibleRange, bucketSize, visibleRangeMs, requestedRangeMs } = getSeriesProperties(\n        sortedRows,\n        intervalMs,\n        absoluteRange\n      );\n      logsModel.visibleRange = visibleRange;\n      logsModel.series = makeDataFramesForLogs(sortedRows, bucketSize);\n\n      if (logsModel.meta) {\n        logsModel.meta = adjustMetaInfo(logsModel, visibleRangeMs, requestedRangeMs);\n      }\n    } else {\n      logsModel.series = [];\n    }\n    logsModel.queries = queries;\n    return logsModel;\n  }\n\n  return {\n    hasUniqueLabels: false,\n    rows: [],\n    meta: [],\n    series: [],\n    queries,\n  };\n}\n\n/**\n * Returns a clamped time range and interval based on the visible logs and the given range.\n *\n * @param sortedRows Log rows from the query response\n * @param intervalMs Dynamic data interval based on available pixel width\n * @param absoluteRange Requested time range\n * @param pxPerBar Default: 20, buckets will be rendered as bars, assuming 10px per histogram bar plus some free space around it\n */\nexport function getSeriesProperties(\n  sortedRows: LogRowModel[],\n  intervalMs: number,\n  absoluteRange?: AbsoluteTimeRange,\n  pxPerBar = 20,\n  minimumBucketSize = 1000\n) {\n  let visibleRange = absoluteRange;\n  let resolutionIntervalMs = intervalMs;\n  let bucketSize = Math.max(resolutionIntervalMs * pxPerBar, minimumBucketSize);\n  let visibleRangeMs;\n  let requestedRangeMs;\n  // Clamp time range to visible logs otherwise big parts of the graph might look empty\n  if (absoluteRange) {\n    const earliestTsLogs = sortedRows[0].timeEpochMs;\n\n    requestedRangeMs = absoluteRange.to - absoluteRange.from;\n    visibleRangeMs = absoluteRange.to - earliestTsLogs;\n\n    if (visibleRangeMs > 0) {\n      // Adjust interval bucket size for potentially shorter visible range\n      const clampingFactor = visibleRangeMs / requestedRangeMs;\n      resolutionIntervalMs *= clampingFactor;\n      // Minimum bucketsize of 1s for nicer graphing\n      bucketSize = Math.max(Math.ceil(resolutionIntervalMs * pxPerBar), minimumBucketSize);\n      // makeSeriesForLogs() aligns dataspoints with time buckets, so we do the same here to not cut off data\n      const adjustedEarliest = Math.floor(earliestTsLogs / bucketSize) * bucketSize;\n      visibleRange = { from: adjustedEarliest, to: absoluteRange.to };\n    } else {\n      // We use visibleRangeMs to calculate range coverage of received logs. However, some data sources are rounding up range in requests. This means that received logs\n      // can (in edge cases) be outside of the requested range and visibleRangeMs < 0. In that case, we want to change visibleRangeMs to be 1 so we can calculate coverage.\n      visibleRangeMs = 1;\n    }\n  }\n  return { bucketSize, visibleRange, visibleRangeMs, requestedRangeMs };\n}\n\nfunction separateLogsAndMetrics(dataFrames: DataFrame[]) {\n  const metricSeries: DataFrame[] = [];\n  const logSeries: DataFrame[] = [];\n\n  for (const dataFrame of dataFrames) {\n    // We want to show meta stats even if no result was returned. That's why we are pushing also data frames with no fields.\n    if (isLogsData(dataFrame) || !dataFrame.fields.length) {\n      logSeries.push(dataFrame);\n      continue;\n    }\n\n    if (dataFrame.length > 0) {\n      metricSeries.push(dataFrame);\n    }\n  }\n\n  return { logSeries, metricSeries };\n}\n\ninterface LogFields {\n  series: DataFrame;\n\n  timeField: FieldWithIndex;\n  stringField: FieldWithIndex;\n  labelsField?: FieldWithIndex;\n  timeNanosecondField?: FieldWithIndex;\n  logLevelField?: FieldWithIndex;\n  idField?: FieldWithIndex;\n}\n\nfunction getAllLabels(fields: LogFields): Labels[] {\n  // there are two types of dataframes we handle:\n  // 1. labels are in a separate field (more efficient when labels change by every log-row)\n  // 2. labels are in in the string-field's `.labels` attribute\n\n  const { stringField, labelsField } = fields;\n\n  if (labelsField !== undefined) {\n    return labelsField.values.toArray();\n  } else {\n    return [stringField.labels ?? {}];\n  }\n}\n\nfunction getLabelsForFrameRow(fields: LogFields, index: number): Labels {\n  // there are two types of dataframes we handle.\n  // either labels-on-the-string-field, or labels-in-the-labels-field\n\n  const { stringField, labelsField } = fields;\n\n  if (labelsField !== undefined) {\n    return labelsField.values.get(index);\n  } else {\n    return stringField.labels ?? {};\n  }\n}\n\n/**\n * Converts dataFrames into LogsModel. This involves merging them into one list, sorting them and computing metadata\n * like common labels.\n */\nexport function logSeriesToLogsModel(logSeries: DataFrame[]): LogsModel | undefined {\n  if (logSeries.length === 0) {\n    return undefined;\n  }\n  const allLabels: Labels[][] = [];\n\n  // Find the fields we care about and collect all labels\n  let allSeries: LogFields[] = [];\n\n  // We are sometimes passing data frames with no fields because we want to calculate correct meta stats.\n  // Therefore we need to filter out series with no fields. These series are used only for meta stats calculation.\n  const seriesWithFields = logSeries.filter((series) => series.fields.length);\n\n  if (seriesWithFields.length) {\n    seriesWithFields.forEach((series) => {\n      const fieldCache = new FieldCache(series);\n      const stringField = fieldCache.getFirstFieldOfType(FieldType.string);\n      const timeField = fieldCache.getFirstFieldOfType(FieldType.time);\n      // NOTE: this is experimental, please do not use in your code.\n      // we will get this custom-frame-type into the \"real\" frame-type list soon,\n      // but the name might change, so please do not use it until then.\n      const labelsField =\n        series.meta?.custom?.frameType === 'LabeledTimeValues' ? fieldCache.getFieldByName('labels') : undefined;\n\n      if (stringField !== undefined && timeField !== undefined) {\n        const info = {\n          series,\n          timeField,\n          labelsField,\n          timeNanosecondField: fieldCache.getFieldByName('tsNs'),\n          stringField,\n          logLevelField: fieldCache.getFieldByName('level'),\n          idField: getIdField(fieldCache),\n        };\n\n        allSeries.push(info);\n\n        const labels = getAllLabels(info);\n        if (labels.length > 0) {\n          allLabels.push(labels);\n        }\n      }\n    });\n  }\n\n  const flatAllLabels = allLabels.flat();\n  const commonLabels = flatAllLabels.length > 0 ? findCommonLabels(flatAllLabels) : {};\n\n  const rows: LogRowModel[] = [];\n  let hasUniqueLabels = false;\n\n  for (const info of allSeries) {\n    const { timeField, timeNanosecondField, stringField, logLevelField, idField, series } = info;\n\n    for (let j = 0; j < series.length; j++) {\n      const ts = timeField.values.get(j);\n      const time = toUtc(ts);\n      const tsNs = timeNanosecondField ? timeNanosecondField.values.get(j) : undefined;\n      const timeEpochNs = tsNs ? tsNs : time.valueOf() + '000000';\n\n      // In edge cases, this can be undefined. If undefined, we want to replace it with empty string.\n      const messageValue: unknown = stringField.values.get(j) ?? '';\n      // This should be string but sometimes isn't (eg elastic) because the dataFrame is not strongly typed.\n      const message: string = typeof messageValue === 'string' ? messageValue : JSON.stringify(messageValue);\n\n      const hasAnsi = textUtil.hasAnsiCodes(message);\n\n      const hasUnescapedContent = !!message.match(/\\\\n|\\\\t|\\\\r/);\n\n      const searchWords = series.meta && series.meta.searchWords ? series.meta.searchWords : [];\n      const entry = hasAnsi ? ansicolor.strip(message) : message;\n\n      const labels = getLabelsForFrameRow(info, j);\n      const uniqueLabels = findUniqueLabels(labels, commonLabels);\n      if (Object.keys(uniqueLabels).length > 0) {\n        hasUniqueLabels = true;\n      }\n\n      let logLevel = LogLevel.unknown;\n      const logLevelKey = (logLevelField && logLevelField.values.get(j)) || (labels && labels['level']);\n      if (logLevelKey) {\n        logLevel = getLogLevelFromKey(logLevelKey);\n      } else {\n        logLevel = getLogLevel(entry);\n      }\n\n      rows.push({\n        entryFieldIndex: stringField.index,\n        rowIndex: j,\n        dataFrame: series,\n        logLevel,\n        timeFromNow: dateTimeFormatTimeAgo(ts),\n        timeEpochMs: time.valueOf(),\n        timeEpochNs,\n        timeLocal: dateTimeFormat(ts, { timeZone: 'browser' }),\n        timeUtc: dateTimeFormat(ts, { timeZone: 'utc' }),\n        uniqueLabels,\n        hasAnsi,\n        hasUnescapedContent,\n        searchWords,\n        entry,\n        raw: message,\n        labels: labels || {},\n        uid: idField ? idField.values.get(j) : j.toString(),\n      });\n    }\n  }\n\n  // Meta data to display in status\n  const meta: LogsMetaItem[] = [];\n  if (size(commonLabels) > 0) {\n    meta.push({\n      label: COMMON_LABELS,\n      value: commonLabels,\n      kind: LogsMetaKind.LabelsMap,\n    });\n  }\n\n  const limits = logSeries.filter((series) => series.meta && series.meta.limit);\n  const limitValue = Object.values(\n    limits.reduce((acc: any, elem: any) => {\n      acc[elem.refId] = elem.meta.limit;\n      return acc;\n    }, {})\n  ).reduce((acc: number, elem: any) => (acc += elem), 0) as number;\n\n  if (limitValue > 0) {\n    meta.push({\n      label: LIMIT_LABEL,\n      value: limitValue,\n      kind: LogsMetaKind.Number,\n    });\n  }\n\n  let totalBytes = 0;\n  const queriesVisited: { [refId: string]: boolean } = {};\n  // To add just 1 error message\n  let errorMetaAdded = false;\n\n  for (const series of logSeries) {\n    const totalBytesKey = series.meta?.custom?.lokiQueryStatKey;\n    const { refId } = series; // Stats are per query, keeping track by refId\n\n    if (!errorMetaAdded && series.meta?.custom?.error) {\n      meta.push({\n        label: '',\n        value: series.meta?.custom.error,\n        kind: LogsMetaKind.Error,\n      });\n      errorMetaAdded = true;\n    }\n\n    if (refId && !queriesVisited[refId]) {\n      if (totalBytesKey && series.meta?.stats) {\n        const byteStat = series.meta.stats.find((stat) => stat.displayName === totalBytesKey);\n        if (byteStat) {\n          totalBytes += byteStat.value;\n        }\n      }\n\n      queriesVisited[refId] = true;\n    }\n  }\n\n  if (totalBytes > 0) {\n    const { text, suffix } = SIPrefix('B')(totalBytes);\n    meta.push({\n      label: 'Total bytes processed',\n      value: `${text} ${suffix}`,\n      kind: LogsMetaKind.String,\n    });\n  }\n\n  return {\n    hasUniqueLabels,\n    meta,\n    rows,\n  };\n}\n\nfunction getIdField(fieldCache: FieldCache): FieldWithIndex | undefined {\n  const idFieldNames = ['id'];\n  for (const fieldName of idFieldNames) {\n    const idField = fieldCache.getFieldByName(fieldName);\n    if (idField) {\n      return idField;\n    }\n  }\n  return undefined;\n}\n\n// Used to add additional information to Line limit meta info\nfunction adjustMetaInfo(logsModel: LogsModel, visibleRangeMs?: number, requestedRangeMs?: number): LogsMetaItem[] {\n  let logsModelMeta = [...logsModel.meta!];\n\n  const limitIndex = logsModelMeta.findIndex((meta) => meta.label === LIMIT_LABEL);\n  const limit = limitIndex >= 0 && logsModelMeta[limitIndex]?.value;\n\n  if (limit && limit > 0) {\n    let metaLimitValue;\n\n    if (limit === logsModel.rows.length && visibleRangeMs && requestedRangeMs) {\n      const coverage = ((visibleRangeMs / requestedRangeMs) * 100).toFixed(2);\n\n      metaLimitValue = `${limit} reached, received logs cover ${coverage}% (${rangeUtil.msRangeToTimeString(\n        visibleRangeMs\n      )}) of your selected time range (${rangeUtil.msRangeToTimeString(requestedRangeMs)})`;\n    } else {\n      metaLimitValue = `${limit} (${logsModel.rows.length} returned)`;\n    }\n\n    logsModelMeta[limitIndex] = {\n      label: LIMIT_LABEL,\n      value: metaLimitValue,\n      kind: LogsMetaKind.String,\n    };\n  }\n\n  return logsModelMeta;\n}\n\n/**\n * Returns field configuration used to render logs volume bars\n */\nfunction getLogVolumeFieldConfig(level: LogLevel, oneLevelDetected: boolean) {\n  const name = oneLevelDetected && level === LogLevel.unknown ? 'logs' : level;\n  const color = LogLevelColor[level];\n  return {\n    displayNameFromDS: name,\n    color: {\n      mode: FieldColorModeId.Fixed,\n      fixedColor: color,\n    },\n    custom: {\n      drawStyle: GraphDrawStyle.Bars,\n      barAlignment: BarAlignment.Center,\n      lineColor: color,\n      pointColor: color,\n      fillColor: color,\n      lineWidth: 1,\n      fillOpacity: 100,\n      stacking: {\n        mode: StackingMode.Normal,\n        group: 'A',\n      },\n    },\n  };\n}\n\n/**\n * Take multiple data frames, sum up values and group by level.\n * Return a list of data frames, each representing single level.\n */\nexport function aggregateRawLogsVolume(\n  rawLogsVolume: DataFrame[],\n  extractLevel: (dataFrame: DataFrame) => LogLevel\n): DataFrame[] {\n  const logsVolumeByLevelMap: Partial<Record<LogLevel, DataFrame[]>> = {};\n  rawLogsVolume.forEach((dataFrame) => {\n    const level = extractLevel(dataFrame);\n    if (!logsVolumeByLevelMap[level]) {\n      logsVolumeByLevelMap[level] = [];\n    }\n    logsVolumeByLevelMap[level]!.push(dataFrame);\n  });\n\n  return Object.keys(logsVolumeByLevelMap).map((level: string) => {\n    return aggregateFields(\n      logsVolumeByLevelMap[level as LogLevel]!,\n      getLogVolumeFieldConfig(level as LogLevel, Object.keys(logsVolumeByLevelMap).length === 1)\n    );\n  });\n}\n\n/**\n * Aggregate multiple data frames into a single data frame by adding values.\n * Multiple data frames for the same level are passed here to get a single\n * data frame for a given level. Aggregation by level happens in aggregateRawLogsVolume()\n */\nfunction aggregateFields(dataFrames: DataFrame[], config: FieldConfig): DataFrame {\n  const aggregatedDataFrame = new MutableDataFrame();\n  if (!dataFrames.length) {\n    return aggregatedDataFrame;\n  }\n\n  const totalLength = dataFrames[0].length;\n  const timeField = new FieldCache(dataFrames[0]).getFirstFieldOfType(FieldType.time);\n\n  if (!timeField) {\n    return aggregatedDataFrame;\n  }\n\n  aggregatedDataFrame.addField({ name: 'Time', type: FieldType.time }, totalLength);\n  aggregatedDataFrame.addField({ name: 'Value', type: FieldType.number, config }, totalLength);\n\n  dataFrames.forEach((dataFrame) => {\n    dataFrame.fields.forEach((field) => {\n      if (field.type === FieldType.number) {\n        for (let pointIndex = 0; pointIndex < totalLength; pointIndex++) {\n          const currentValue = aggregatedDataFrame.get(pointIndex).Value;\n          const valueToAdd = field.values.get(pointIndex);\n          const totalValue =\n            currentValue === null && valueToAdd === null ? null : (currentValue || 0) + (valueToAdd || 0);\n          aggregatedDataFrame.set(pointIndex, { Value: totalValue, Time: timeField.values.get(pointIndex) });\n        }\n      }\n    });\n  });\n\n  return aggregatedDataFrame;\n}\n\ntype LogsVolumeQueryOptions<T extends DataQuery> = {\n  extractLevel: (dataFrame: DataFrame) => LogLevel;\n  targets: T[];\n  range: TimeRange;\n};\n\n/**\n * Creates an observable, which makes requests to get logs volume and aggregates results.\n */\nexport function queryLogsVolume<T extends DataQuery>(\n  datasource: DataSourceApi<T, any, any>,\n  logsVolumeRequest: DataQueryRequest<T>,\n  options: LogsVolumeQueryOptions<T>\n): Observable<DataQueryResponse> {\n  const timespan = options.range.to.valueOf() - options.range.from.valueOf();\n  const intervalInfo = getIntervalInfo(logsVolumeRequest.scopedVars, timespan);\n  logsVolumeRequest.interval = intervalInfo.interval;\n  logsVolumeRequest.scopedVars.__interval = { value: intervalInfo.interval, text: intervalInfo.interval };\n  if (intervalInfo.intervalMs !== undefined) {\n    logsVolumeRequest.intervalMs = intervalInfo.intervalMs;\n    logsVolumeRequest.scopedVars.__interval_ms = { value: intervalInfo.intervalMs, text: intervalInfo.intervalMs };\n  }\n\n  return new Observable((observer) => {\n    let rawLogsVolume: DataFrame[] = [];\n    observer.next({\n      state: LoadingState.Loading,\n      error: undefined,\n      data: [],\n    });\n\n    const subscription = (datasource.query(logsVolumeRequest) as Observable<DataQueryResponse>).subscribe({\n      complete: () => {\n        const aggregatedLogsVolume = aggregateRawLogsVolume(rawLogsVolume, options.extractLevel);\n        if (aggregatedLogsVolume[0]) {\n          aggregatedLogsVolume[0].meta = {\n            custom: {\n              targets: options.targets,\n              absoluteRange: { from: options.range.from.valueOf(), to: options.range.to.valueOf() },\n            },\n          };\n        }\n        observer.next({\n          state: LoadingState.Done,\n          error: undefined,\n          data: aggregatedLogsVolume,\n        });\n        observer.complete();\n      },\n      next: (dataQueryResponse: DataQueryResponse) => {\n        const { error } = dataQueryResponse;\n        if (error !== undefined) {\n          observer.next({\n            state: LoadingState.Error,\n            error,\n            data: [],\n          });\n          observer.error(error);\n        } else {\n          rawLogsVolume = rawLogsVolume.concat(dataQueryResponse.data.map(toDataFrame));\n        }\n      },\n      error: (error) => {\n        observer.next({\n          state: LoadingState.Error,\n          error: error,\n          data: [],\n        });\n        observer.error(error);\n      },\n    });\n    return () => {\n      subscription?.unsubscribe();\n    };\n  });\n}\n\nfunction getIntervalInfo(scopedVars: ScopedVars, timespanMs: number): { interval: string; intervalMs?: number } {\n  if (scopedVars.__interval) {\n    let intervalMs: number = scopedVars.__interval_ms.value;\n    let interval = '';\n    // below 5 seconds we force the resolution to be per 1ms as interval in scopedVars is not less than 10ms\n    if (timespanMs < SECOND * 5) {\n      intervalMs = MILLISECOND;\n      interval = '1ms';\n    } else if (intervalMs > HOUR) {\n      intervalMs = DAY;\n      interval = '1d';\n    } else if (intervalMs > MINUTE) {\n      intervalMs = HOUR;\n      interval = '1h';\n    } else if (intervalMs > SECOND) {\n      intervalMs = MINUTE;\n      interval = '1m';\n    } else {\n      intervalMs = SECOND;\n      interval = '1s';\n    }\n\n    return { interval, intervalMs };\n  } else {\n    return { interval: '$__interval' };\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}