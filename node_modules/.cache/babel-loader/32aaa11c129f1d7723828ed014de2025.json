{"ast":null,"code":"import { cx, css } from '@emotion/css';\nimport debouncePromise from 'debounce-promise';\nimport React, { useState, useEffect } from 'react';\nimport { useAsyncFn } from 'react-use';\nimport { InlineLabel, Select, AsyncSelect, Input } from '@grafana/ui';\nimport { useShadowedState } from '../useShadowedState'; // this file is a simpler version of `grafana-ui / SegmentAsync.tsx`\n// with some changes:\n// 1. click-outside does not select the value. i think it's better to be explicit here.\n// 2. we set a min-width on the select-element to handle cases where the `value`\n//    is very short, like \"x\", and then you click on it and the select opens,\n//    and it tries to be as short as \"x\" and it does not work well.\n// NOTE: maybe these changes could be migrated into the SegmentAsync later\n\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst selectClass = css({\n  minWidth: '160px'\n});\n\n// when a custom value is written into a select-box,\n// by default the new value is prefixed with \"Create:\",\n// and that sounds confusing because here we do not create\n// anything. we change this to just be the entered string.\nconst formatCreateLabel = v => v;\n\nconst SelReload = ({\n  loadOptions,\n  allowCustomValue,\n  onChange,\n  onClose\n}) => {\n  // here we rely on the fact that writing text into the <AsyncSelect/>\n  // does not cause a re-render of the current react component.\n  // this way there is only a single render-call,\n  // so there is only a single `debouncedLoadOptions`.\n  // if we want ot make this \"re-render safe,\n  // we will have to put the debounced call into an useRef,\n  // and probably have an useEffect\n  const debouncedLoadOptions = debouncePromise(loadOptions, 1000, {\n    leading: true\n  });\n  return /*#__PURE__*/_jsx(\"div\", {\n    className: selectClass,\n    children: /*#__PURE__*/_jsx(AsyncSelect, {\n      formatCreateLabel: formatCreateLabel,\n      defaultOptions: true,\n      autoFocus: true,\n      isOpen: true,\n      onCloseMenu: onClose,\n      allowCustomValue: allowCustomValue,\n      loadOptions: debouncedLoadOptions,\n      onChange: onChange\n    })\n  });\n};\n\nconst SelSingleLoad = ({\n  loadOptions,\n  allowCustomValue,\n  onChange,\n  onClose\n}) => {\n  var _loadState$value;\n\n  const [loadState, doLoad] = useAsyncFn(loadOptions, [loadOptions]);\n  useEffect(() => {\n    doLoad('');\n  }, [doLoad, loadOptions]);\n  return /*#__PURE__*/_jsx(\"div\", {\n    className: selectClass,\n    children: /*#__PURE__*/_jsx(Select, {\n      isLoading: loadState.loading,\n      formatCreateLabel: formatCreateLabel,\n      autoFocus: true,\n      isOpen: true,\n      onCloseMenu: onClose,\n      allowCustomValue: allowCustomValue,\n      options: (_loadState$value = loadState.value) !== null && _loadState$value !== void 0 ? _loadState$value : [],\n      onChange: onChange\n    })\n  });\n};\n\nconst Sel = ({\n  loadOptions,\n  filterByLoadOptions,\n  allowCustomValue,\n  onChange,\n  onClose\n}) => {\n  // unfortunately <Segment/> and <SegmentAsync/> have somewhat different behavior,\n  // so the simplest approach was to just create two separate wrapper-components\n  return filterByLoadOptions ? /*#__PURE__*/_jsx(SelReload, {\n    loadOptions: loadOptions,\n    allowCustomValue: allowCustomValue,\n    onChange: onChange,\n    onClose: onClose\n  }) : /*#__PURE__*/_jsx(SelSingleLoad, {\n    loadOptions: loadOptions,\n    allowCustomValue: allowCustomValue,\n    onChange: onChange,\n    onClose: onClose\n  });\n};\n\nconst Inp = ({\n  initialValue,\n  onChange,\n  onClose\n}) => {\n  const [currentValue, setCurrentValue] = useShadowedState(initialValue);\n  return /*#__PURE__*/_jsx(Input, {\n    autoFocus: true,\n    type: \"text\",\n    spellCheck: false,\n    onBlur: onClose,\n    onKeyDown: e => {\n      if (e.key === 'Enter') {\n        onChange(currentValue);\n      }\n    },\n    onChange: e => {\n      setCurrentValue(e.currentTarget.value);\n    },\n    value: currentValue\n  });\n};\n\nconst defaultButtonClass = css({\n  width: 'auto',\n  cursor: 'pointer'\n});\nexport const Seg = ({\n  value,\n  buttonClassName,\n  loadOptions,\n  filterByLoadOptions,\n  allowCustomValue,\n  onChange\n}) => {\n  const [isOpen, setOpen] = useState(false);\n\n  if (!isOpen) {\n    const className = cx(defaultButtonClass, buttonClassName);\n    return /*#__PURE__*/_jsx(InlineLabel, {\n      as: \"button\",\n      className: className,\n      onClick: () => {\n        setOpen(true);\n      },\n      children: value\n    });\n  } else {\n    if (loadOptions !== undefined) {\n      return /*#__PURE__*/_jsx(Sel, {\n        loadOptions: loadOptions,\n        filterByLoadOptions: filterByLoadOptions !== null && filterByLoadOptions !== void 0 ? filterByLoadOptions : false,\n        allowCustomValue: allowCustomValue,\n        onChange: v => {\n          setOpen(false);\n          onChange(v);\n        },\n        onClose: () => {\n          setOpen(false);\n        }\n      });\n    } else {\n      return /*#__PURE__*/_jsx(Inp, {\n        initialValue: value,\n        onClose: () => {\n          setOpen(false);\n        },\n        onChange: v => {\n          setOpen(false);\n          onChange({\n            value: v,\n            label: v\n          });\n        }\n      });\n    }\n  }\n};","map":{"version":3,"names":["cx","css","debouncePromise","React","useState","useEffect","useAsyncFn","InlineLabel","Select","AsyncSelect","Input","useShadowedState","selectClass","minWidth","formatCreateLabel","v","SelReload","loadOptions","allowCustomValue","onChange","onClose","debouncedLoadOptions","leading","SelSingleLoad","loadState","doLoad","loading","value","Sel","filterByLoadOptions","Inp","initialValue","currentValue","setCurrentValue","e","key","currentTarget","defaultButtonClass","width","cursor","Seg","buttonClassName","isOpen","setOpen","className","undefined","label"],"sources":["/home/soula/grafana/public/app/plugins/datasource/influxdb/components/VisualInfluxQLEditor/Seg.tsx"],"sourcesContent":["import { cx, css } from '@emotion/css';\nimport debouncePromise from 'debounce-promise';\nimport React, { useState, useEffect } from 'react';\nimport { useAsyncFn } from 'react-use';\n\nimport { SelectableValue } from '@grafana/data';\nimport { InlineLabel, Select, AsyncSelect, Input } from '@grafana/ui';\n\nimport { useShadowedState } from '../useShadowedState';\n\n// this file is a simpler version of `grafana-ui / SegmentAsync.tsx`\n// with some changes:\n// 1. click-outside does not select the value. i think it's better to be explicit here.\n// 2. we set a min-width on the select-element to handle cases where the `value`\n//    is very short, like \"x\", and then you click on it and the select opens,\n//    and it tries to be as short as \"x\" and it does not work well.\n\n// NOTE: maybe these changes could be migrated into the SegmentAsync later\n\ntype SelVal = SelectableValue<string>;\n\n// when allowCustomValue is true, there is no way to enforce the selectableValue\n// enum-type, so i just go with `string`\n\ntype LoadOptions = (filter: string) => Promise<SelVal[]>;\n\ntype Props = {\n  value: string;\n  buttonClassName?: string;\n  loadOptions?: LoadOptions;\n  // if filterByLoadOptions is false,\n  // loadOptions is only executed once,\n  // when the select-box opens,\n  // and as you write, the list gets filtered\n  // by the select-box.\n  // if filterByLoadOptions is true,\n  // as you write the loadOptions is executed again and again,\n  // and it is relied on to filter the results.\n  filterByLoadOptions?: boolean;\n  onChange: (v: SelVal) => void;\n  allowCustomValue?: boolean;\n};\n\nconst selectClass = css({\n  minWidth: '160px',\n});\n\ntype SelProps = {\n  loadOptions: LoadOptions;\n  filterByLoadOptions?: boolean;\n  onClose: () => void;\n  onChange: (v: SelVal) => void;\n  allowCustomValue?: boolean;\n};\n\ntype SelReloadProps = {\n  loadOptions: (filter: string) => Promise<SelVal[]>;\n  onClose: () => void;\n  onChange: (v: SelVal) => void;\n  allowCustomValue?: boolean;\n};\n\n// when a custom value is written into a select-box,\n// by default the new value is prefixed with \"Create:\",\n// and that sounds confusing because here we do not create\n// anything. we change this to just be the entered string.\nconst formatCreateLabel = (v: string) => v;\n\nconst SelReload = ({ loadOptions, allowCustomValue, onChange, onClose }: SelReloadProps): JSX.Element => {\n  // here we rely on the fact that writing text into the <AsyncSelect/>\n  // does not cause a re-render of the current react component.\n  // this way there is only a single render-call,\n  // so there is only a single `debouncedLoadOptions`.\n  // if we want ot make this \"re-render safe,\n  // we will have to put the debounced call into an useRef,\n  // and probably have an useEffect\n  const debouncedLoadOptions = debouncePromise(loadOptions, 1000, { leading: true });\n  return (\n    <div className={selectClass}>\n      <AsyncSelect\n        formatCreateLabel={formatCreateLabel}\n        defaultOptions\n        autoFocus\n        isOpen\n        onCloseMenu={onClose}\n        allowCustomValue={allowCustomValue}\n        loadOptions={debouncedLoadOptions}\n        onChange={onChange}\n      />\n    </div>\n  );\n};\n\ntype SelSingleLoadProps = {\n  loadOptions: (filter: string) => Promise<SelVal[]>;\n  onClose: () => void;\n  onChange: (v: SelVal) => void;\n  allowCustomValue?: boolean;\n};\n\nconst SelSingleLoad = ({ loadOptions, allowCustomValue, onChange, onClose }: SelSingleLoadProps): JSX.Element => {\n  const [loadState, doLoad] = useAsyncFn(loadOptions, [loadOptions]);\n\n  useEffect(() => {\n    doLoad('');\n  }, [doLoad, loadOptions]);\n\n  return (\n    <div className={selectClass}>\n      <Select\n        isLoading={loadState.loading}\n        formatCreateLabel={formatCreateLabel}\n        autoFocus\n        isOpen\n        onCloseMenu={onClose}\n        allowCustomValue={allowCustomValue}\n        options={loadState.value ?? []}\n        onChange={onChange}\n      />\n    </div>\n  );\n};\n\nconst Sel = ({ loadOptions, filterByLoadOptions, allowCustomValue, onChange, onClose }: SelProps): JSX.Element => {\n  // unfortunately <Segment/> and <SegmentAsync/> have somewhat different behavior,\n  // so the simplest approach was to just create two separate wrapper-components\n  return filterByLoadOptions ? (\n    <SelReload loadOptions={loadOptions} allowCustomValue={allowCustomValue} onChange={onChange} onClose={onClose} />\n  ) : (\n    <SelSingleLoad\n      loadOptions={loadOptions}\n      allowCustomValue={allowCustomValue}\n      onChange={onChange}\n      onClose={onClose}\n    />\n  );\n};\n\ntype InpProps = {\n  initialValue: string;\n  onChange: (newVal: string) => void;\n  onClose: () => void;\n};\n\nconst Inp = ({ initialValue, onChange, onClose }: InpProps): JSX.Element => {\n  const [currentValue, setCurrentValue] = useShadowedState(initialValue);\n\n  return (\n    <Input\n      autoFocus\n      type=\"text\"\n      spellCheck={false}\n      onBlur={onClose}\n      onKeyDown={(e) => {\n        if (e.key === 'Enter') {\n          onChange(currentValue);\n        }\n      }}\n      onChange={(e) => {\n        setCurrentValue(e.currentTarget.value);\n      }}\n      value={currentValue}\n    />\n  );\n};\n\nconst defaultButtonClass = css({\n  width: 'auto',\n  cursor: 'pointer',\n});\n\nexport const Seg = ({\n  value,\n  buttonClassName,\n  loadOptions,\n  filterByLoadOptions,\n  allowCustomValue,\n  onChange,\n}: Props): JSX.Element => {\n  const [isOpen, setOpen] = useState(false);\n  if (!isOpen) {\n    const className = cx(defaultButtonClass, buttonClassName);\n    return (\n      <InlineLabel\n        as=\"button\"\n        className={className}\n        onClick={() => {\n          setOpen(true);\n        }}\n      >\n        {value}\n      </InlineLabel>\n    );\n  } else {\n    if (loadOptions !== undefined) {\n      return (\n        <Sel\n          loadOptions={loadOptions}\n          filterByLoadOptions={filterByLoadOptions ?? false}\n          allowCustomValue={allowCustomValue}\n          onChange={(v) => {\n            setOpen(false);\n            onChange(v);\n          }}\n          onClose={() => {\n            setOpen(false);\n          }}\n        />\n      );\n    } else {\n      return (\n        <Inp\n          initialValue={value}\n          onClose={() => {\n            setOpen(false);\n          }}\n          onChange={(v) => {\n            setOpen(false);\n            onChange({ value: v, label: v });\n          }}\n        />\n      );\n    }\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}