{"ast":null,"code":"import { concat, forEach, isEmpty, isEqual, isNumber, sortBy } from 'lodash';\nconst VALUE_INDEX = 0;\nconst TIME_INDEX = 1;\n/**\n * Convert histogram represented by the list of series to heatmap object.\n * @param seriesList List of time series\n */\n\nfunction histogramToHeatmap(seriesList) {\n  const heatmap = {};\n\n  for (let i = 0; i < seriesList.length; i++) {\n    const series = seriesList[i];\n    const bound = i;\n\n    if (isNaN(bound)) {\n      return heatmap;\n    }\n\n    for (const point of series.datapoints) {\n      const count = point[VALUE_INDEX];\n      const time = point[TIME_INDEX];\n\n      if (!isNumber(count)) {\n        continue;\n      }\n\n      let bucket = heatmap[time];\n\n      if (!bucket) {\n        bucket = heatmap[time] = {\n          x: time,\n          buckets: {}\n        };\n      }\n\n      bucket.buckets[bound] = {\n        y: bound,\n        count: count,\n        bounds: {\n          top: null,\n          bottom: bound\n        },\n        values: [],\n        points: []\n      };\n    }\n  }\n\n  return heatmap;\n}\n/**\n * Sort series representing histogram by label value.\n */\n\n\nfunction sortSeriesByLabel(s1, s2) {\n  let label1, label2;\n\n  try {\n    // fail if not integer. might happen with bad queries\n    label1 = parseHistogramLabel(s1.label);\n    label2 = parseHistogramLabel(s2.label);\n  } catch (err) {\n    console.error(err instanceof Error ? err.message : err);\n    return 0;\n  }\n\n  if (label1 > label2) {\n    return 1;\n  }\n\n  if (label1 < label2) {\n    return -1;\n  }\n\n  return 0;\n}\n\nfunction parseHistogramLabel(label) {\n  if (label === '+Inf' || label === 'inf') {\n    return +Infinity;\n  }\n\n  const value = Number(label);\n\n  if (isNaN(value)) {\n    throw new Error(`Error parsing histogram label: ${label} is not a number`);\n  }\n\n  return value;\n}\n/**\n * Convert buckets into linear array of \"cards\" - objects, represented heatmap elements.\n * @param  {Object} buckets\n * @returns {Object}          Array of \"card\" objects and stats\n */\n\n\nfunction convertToCards(buckets, hideZero = false) {\n  let min = 0,\n      max = 0;\n  const cards = [];\n  forEach(buckets, xBucket => {\n    forEach(xBucket.buckets, yBucket => {\n      const card = {\n        x: xBucket.x,\n        y: yBucket.y,\n        yBounds: yBucket.bounds,\n        values: yBucket.values,\n        count: yBucket.count\n      };\n\n      if (!hideZero || card.count !== 0) {\n        cards.push(card);\n      }\n\n      if (cards.length === 1) {\n        min = yBucket.count;\n        max = yBucket.count;\n      }\n\n      min = yBucket.count < min ? yBucket.count : min;\n      max = yBucket.count > max ? yBucket.count : max;\n    });\n  });\n  const cardStats = {\n    min,\n    max\n  };\n  return {\n    cards,\n    cardStats\n  };\n}\n/**\n * Special method for log scales. When series converted into buckets with log scale,\n * for simplification, 0 values are converted into 0, not into -Infinity. On the other hand, we mean\n * that all values less than series minimum, is 0 values, and we create special \"minimum\" bucket for\n * that values (actually, there're no values less than minimum, so this bucket is empty).\n *  8-16|    | ** |    |  * |  **|\n *   4-8|  * |*  *|*   |** *| *  |\n *   2-4| * *|    | ***|    |*   |\n *   1-2|*   |    |    |    |    | This bucket contains minimum series value\n * 0.5-1|____|____|____|____|____| This bucket should be displayed as 0 on graph\n *     0|____|____|____|____|____| This bucket is for 0 values (should actually be -Infinity)\n * So we should merge two bottom buckets into one (0-value bucket).\n *\n * @param  {Object} buckets  Heatmap buckets\n * @param  {Number} minValue Minimum series value\n * @returns {Object}          Transformed buckets\n */\n\n\nfunction mergeZeroBuckets(buckets, minValue) {\n  forEach(buckets, xBucket => {\n    const yBuckets = xBucket.buckets;\n    const emptyBucket = {\n      bounds: {\n        bottom: 0,\n        top: 0\n      },\n      values: [],\n      points: [],\n      count: 0\n    };\n    const nullBucket = yBuckets[0] || emptyBucket;\n    const minBucket = yBuckets[minValue] || emptyBucket;\n    const newBucket = {\n      y: 0,\n      bounds: {\n        bottom: minValue,\n        top: minBucket.bounds.top || minValue\n      },\n      values: [],\n      points: [],\n      count: 0\n    };\n    newBucket.points = nullBucket.points.concat(minBucket.points);\n    newBucket.values = nullBucket.values.concat(minBucket.values);\n    newBucket.count = newBucket.values.length;\n\n    if (newBucket.count === 0) {\n      return;\n    }\n\n    delete yBuckets[minValue];\n    yBuckets[0] = newBucket;\n  });\n  return buckets;\n}\n/**\n * Convert set of time series into heatmap buckets\n * @returns {Object}    Heatmap object:\n * {\n *   xBucketBound_1: {\n *     x: xBucketBound_1,\n *     buckets: {\n *       yBucketBound_1: {\n *         y: yBucketBound_1,\n *         bounds: {bottom, top}\n *         values: [val_1, val_2, ..., val_K],\n *         points: [[val_Y, val_X, series_name], ..., [...]],\n *         seriesStat: {seriesName_1: val_1, seriesName_2: val_2}\n *       },\n *       ...\n *       yBucketBound_M: {}\n *     },\n *     values: [val_1, val_2, ..., val_K],\n *     points: [\n *       [val_Y, val_X, series_name], (point_1)\n *       ...\n *       [...] (point_K)\n *     ]\n *   },\n *   xBucketBound_2: {},\n *   ...\n *   xBucketBound_N: {}\n * }\n */\n\n\nfunction convertToHeatMap(seriesList, yBucketSize, xBucketSize, logBase = 1) {\n  const heatmap = {};\n\n  for (const series of seriesList) {\n    const datapoints = series.datapoints;\n    const seriesName = series.label; // Slice series into X axis buckets\n    // |    | ** |    |  * |  **|\n    // |  * |*  *|*   |** *| *  |\n    // |** *|    | ***|    |*   |\n    // |____|____|____|____|____|_\n    //\n\n    forEach(datapoints, point => {\n      const bucketBound = getBucketBound(point[TIME_INDEX], xBucketSize);\n      pushToXBuckets(heatmap, point, bucketBound, seriesName);\n    });\n  } // Slice X axis buckets into Y (value) buckets\n  // |  **|     |2|,\n  // | *  | --\\ |1|,\n  // |*   | --/ |1|,\n  // |____|     |0|\n  //\n\n\n  forEach(heatmap, xBucket => {\n    if (logBase !== 1) {\n      xBucket.buckets = convertToLogScaleValueBuckets(xBucket, yBucketSize, logBase);\n    } else {\n      xBucket.buckets = convertToValueBuckets(xBucket, yBucketSize);\n    }\n  });\n  return heatmap;\n}\n\nfunction pushToXBuckets(buckets, point, bucketNum, seriesName) {\n  const value = point[VALUE_INDEX];\n\n  if (value === null || value === undefined || isNaN(value)) {\n    return;\n  } // Add series name to point for future identification\n\n\n  const pointExt = concat(point, seriesName);\n\n  if (buckets[bucketNum] && buckets[bucketNum].values) {\n    buckets[bucketNum].values.push(value);\n    buckets[bucketNum].points.push(pointExt);\n  } else {\n    buckets[bucketNum] = {\n      x: bucketNum,\n      values: [value],\n      points: [pointExt]\n    };\n  }\n}\n\nfunction pushToYBuckets(buckets, bucketNum, value, point, bounds) {\n  let count = 1; // Use the 3rd argument as scale/count\n\n  if (point.length > 3) {\n    count = parseInt(point[2], 10);\n  }\n\n  if (buckets[bucketNum]) {\n    var _buckets$bucketNum$po;\n\n    buckets[bucketNum].values.push(value);\n    (_buckets$bucketNum$po = buckets[bucketNum].points) === null || _buckets$bucketNum$po === void 0 ? void 0 : _buckets$bucketNum$po.push(point);\n    buckets[bucketNum].count += count;\n  } else {\n    buckets[bucketNum] = {\n      y: bucketNum,\n      bounds: bounds,\n      values: [value],\n      points: [point],\n      count: count\n    };\n  }\n}\n\nfunction getValueBucketBound(value, yBucketSize, logBase) {\n  if (logBase === 1) {\n    return getBucketBound(value, yBucketSize);\n  } else {\n    return getLogScaleBucketBound(value, yBucketSize, logBase);\n  }\n}\n/**\n * Find bucket for given value (for linear scale)\n */\n\n\nfunction getBucketBounds(value, bucketSize) {\n  let bottom, top;\n  bottom = Math.floor(value / bucketSize) * bucketSize;\n  top = (Math.floor(value / bucketSize) + 1) * bucketSize;\n  return {\n    bottom,\n    top\n  };\n}\n\nfunction getBucketBound(value, bucketSize) {\n  const bounds = getBucketBounds(value, bucketSize);\n  return bounds.bottom;\n}\n\nfunction convertToValueBuckets(xBucket, bucketSize) {\n  const values = xBucket.values;\n  const points = xBucket.points;\n  const buckets = {};\n  forEach(values, (val, index) => {\n    const bounds = getBucketBounds(val, bucketSize);\n    const bucketNum = bounds.bottom;\n    pushToYBuckets(buckets, bucketNum, val, points[index], bounds);\n  });\n  return buckets;\n}\n/**\n * Find bucket for given value (for log scales)\n */\n\n\nfunction getLogScaleBucketBounds(value, yBucketSplitFactor, logBase) {\n  let top, bottom;\n\n  if (value === 0) {\n    return {\n      bottom: 0,\n      top: 0\n    };\n  }\n\n  const valueLog = logp(value, logBase);\n  let pow, powTop;\n\n  if (yBucketSplitFactor === 1 || !yBucketSplitFactor) {\n    pow = Math.floor(valueLog);\n    powTop = pow + 1;\n  } else {\n    const additionalBucketSize = 1 / yBucketSplitFactor;\n    let additionalLog = valueLog - Math.floor(valueLog);\n    additionalLog = Math.floor(additionalLog / additionalBucketSize) * additionalBucketSize;\n    pow = Math.floor(valueLog) + additionalLog;\n    powTop = pow + additionalBucketSize;\n  }\n\n  bottom = Math.pow(logBase, pow);\n  top = Math.pow(logBase, powTop);\n  return {\n    bottom,\n    top\n  };\n}\n\nfunction getLogScaleBucketBound(value, yBucketSplitFactor, logBase) {\n  const bounds = getLogScaleBucketBounds(value, yBucketSplitFactor, logBase);\n  return bounds.bottom;\n}\n\nfunction convertToLogScaleValueBuckets(xBucket, yBucketSplitFactor, logBase) {\n  const values = xBucket.values;\n  const points = xBucket.points;\n  const buckets = {};\n  forEach(values, (val, index) => {\n    const bounds = getLogScaleBucketBounds(val, yBucketSplitFactor, logBase);\n    const bucketNum = bounds.bottom;\n    pushToYBuckets(buckets, bucketNum, val, points[index], bounds);\n  });\n  return buckets;\n}\n/**\n * Logarithm for custom base\n * @param value\n * @param base logarithm base\n */\n\n\nfunction logp(value, base) {\n  return Math.log(value) / Math.log(base);\n}\n/**\n * Calculate size of Y bucket from given buckets bounds.\n * @param bounds Array of Y buckets bounds\n * @param logBase Logarithm base\n */\n\n\nfunction calculateBucketSize(bounds, logBase = 1) {\n  let bucketSize = Infinity;\n\n  if (bounds.length === 0) {\n    return 0;\n  } else if (bounds.length === 1) {\n    return bounds[0];\n  } else {\n    bounds = sortBy(bounds);\n\n    for (let i = 1; i < bounds.length; i++) {\n      const distance = getDistance(bounds[i], bounds[i - 1], logBase);\n      bucketSize = distance < bucketSize ? distance : bucketSize;\n    }\n  }\n\n  return bucketSize;\n}\n/**\n * Calculate distance between two numbers in given scale (linear or logarithmic).\n * @param a\n * @param b\n * @param logBase\n */\n\n\nfunction getDistance(a, b, logBase = 1) {\n  if (logBase === 1) {\n    // Linear distance\n    return Math.abs(b - a);\n  } else {\n    // logarithmic distance\n    const ratio = Math.max(a, b) / Math.min(a, b);\n    return logp(ratio, logBase);\n  }\n}\n/**\n * Compare two heatmap data objects\n * @param objA\n * @param objB\n */\n\n\nfunction isHeatmapDataEqual(objA, objB) {\n  let isEql = !emptyXOR(objA, objB);\n  forEach(objA, (xBucket, x) => {\n    if (objB[x]) {\n      if (emptyXOR(xBucket.buckets, objB[x].buckets)) {\n        isEql = false;\n        return false;\n      }\n\n      forEach(xBucket.buckets, (yBucket, y) => {\n        if (objB[x].buckets && objB[x].buckets[y]) {\n          if (objB[x].buckets[y].values) {\n            isEql = isEqual(sortBy(yBucket.values), sortBy(objB[x].buckets[y].values));\n\n            if (!isEql) {\n              return false;\n            } else {\n              return true;\n            }\n          } else {\n            isEql = false;\n            return false;\n          }\n        } else {\n          isEql = false;\n          return false;\n        }\n      });\n\n      if (!isEql) {\n        return false;\n      } else {\n        return true;\n      }\n    } else {\n      isEql = false;\n      return false;\n    }\n  });\n  return isEql;\n}\n\nfunction emptyXOR(foo, bar) {\n  return (isEmpty(foo) || isEmpty(bar)) && !(isEmpty(foo) && isEmpty(bar));\n}\n\nexport { convertToHeatMap, histogramToHeatmap, convertToCards, mergeZeroBuckets, getValueBucketBound, isHeatmapDataEqual, calculateBucketSize, sortSeriesByLabel };","map":{"version":3,"names":["concat","forEach","isEmpty","isEqual","isNumber","sortBy","VALUE_INDEX","TIME_INDEX","histogramToHeatmap","seriesList","heatmap","i","length","series","bound","isNaN","point","datapoints","count","time","bucket","x","buckets","y","bounds","top","bottom","values","points","sortSeriesByLabel","s1","s2","label1","label2","parseHistogramLabel","label","err","console","error","Error","message","Infinity","value","Number","convertToCards","hideZero","min","max","cards","xBucket","yBucket","card","yBounds","push","cardStats","mergeZeroBuckets","minValue","yBuckets","emptyBucket","nullBucket","minBucket","newBucket","convertToHeatMap","yBucketSize","xBucketSize","logBase","seriesName","bucketBound","getBucketBound","pushToXBuckets","convertToLogScaleValueBuckets","convertToValueBuckets","bucketNum","undefined","pointExt","pushToYBuckets","parseInt","getValueBucketBound","getLogScaleBucketBound","getBucketBounds","bucketSize","Math","floor","val","index","getLogScaleBucketBounds","yBucketSplitFactor","valueLog","logp","pow","powTop","additionalBucketSize","additionalLog","base","log","calculateBucketSize","distance","getDistance","a","b","abs","ratio","isHeatmapDataEqual","objA","objB","isEql","emptyXOR","foo","bar"],"sources":["/home/soula/grafana/public/app/plugins/panel/heatmap-old/heatmap_data_converter.ts"],"sourcesContent":["import { concat, forEach, isEmpty, isEqual, isNumber, sortBy } from 'lodash';\n\nimport { TimeSeries } from 'app/core/core';\n\nimport { Bucket, HeatmapCard, HeatmapCardStats, YBucket, XBucket } from './types';\n\nconst VALUE_INDEX = 0;\nconst TIME_INDEX = 1;\n\n/**\n * Convert histogram represented by the list of series to heatmap object.\n * @param seriesList List of time series\n */\nfunction histogramToHeatmap(seriesList: TimeSeries[]) {\n  const heatmap: any = {};\n\n  for (let i = 0; i < seriesList.length; i++) {\n    const series = seriesList[i];\n    const bound = i;\n    if (isNaN(bound)) {\n      return heatmap;\n    }\n\n    for (const point of series.datapoints) {\n      const count = point[VALUE_INDEX];\n      const time = point[TIME_INDEX];\n\n      if (!isNumber(count)) {\n        continue;\n      }\n\n      let bucket = heatmap[time];\n      if (!bucket) {\n        bucket = heatmap[time] = { x: time, buckets: {} };\n      }\n\n      bucket.buckets[bound] = {\n        y: bound,\n        count: count,\n        bounds: {\n          top: null,\n          bottom: bound,\n        },\n        values: [],\n        points: [],\n      };\n    }\n  }\n\n  return heatmap;\n}\n\n/**\n * Sort series representing histogram by label value.\n */\nfunction sortSeriesByLabel(s1: { label: string }, s2: { label: string }) {\n  let label1, label2;\n\n  try {\n    // fail if not integer. might happen with bad queries\n    label1 = parseHistogramLabel(s1.label);\n    label2 = parseHistogramLabel(s2.label);\n  } catch (err) {\n    console.error(err instanceof Error ? err.message : err);\n    return 0;\n  }\n\n  if (label1 > label2) {\n    return 1;\n  }\n\n  if (label1 < label2) {\n    return -1;\n  }\n\n  return 0;\n}\n\nfunction parseHistogramLabel(label: string): number {\n  if (label === '+Inf' || label === 'inf') {\n    return +Infinity;\n  }\n  const value = Number(label);\n  if (isNaN(value)) {\n    throw new Error(`Error parsing histogram label: ${label} is not a number`);\n  }\n  return value;\n}\n\n/**\n * Convert buckets into linear array of \"cards\" - objects, represented heatmap elements.\n * @param  {Object} buckets\n * @returns {Object}          Array of \"card\" objects and stats\n */\nfunction convertToCards(buckets: any, hideZero = false): { cards: HeatmapCard[]; cardStats: HeatmapCardStats } {\n  let min = 0,\n    max = 0;\n  const cards: HeatmapCard[] = [];\n  forEach(buckets, (xBucket) => {\n    forEach(xBucket.buckets, (yBucket) => {\n      const card: HeatmapCard = {\n        x: xBucket.x,\n        y: yBucket.y,\n        yBounds: yBucket.bounds,\n        values: yBucket.values,\n        count: yBucket.count,\n      };\n      if (!hideZero || card.count !== 0) {\n        cards.push(card);\n      }\n\n      if (cards.length === 1) {\n        min = yBucket.count;\n        max = yBucket.count;\n      }\n\n      min = yBucket.count < min ? yBucket.count : min;\n      max = yBucket.count > max ? yBucket.count : max;\n    });\n  });\n\n  const cardStats = { min, max };\n  return { cards, cardStats };\n}\n\n/**\n * Special method for log scales. When series converted into buckets with log scale,\n * for simplification, 0 values are converted into 0, not into -Infinity. On the other hand, we mean\n * that all values less than series minimum, is 0 values, and we create special \"minimum\" bucket for\n * that values (actually, there're no values less than minimum, so this bucket is empty).\n *  8-16|    | ** |    |  * |  **|\n *   4-8|  * |*  *|*   |** *| *  |\n *   2-4| * *|    | ***|    |*   |\n *   1-2|*   |    |    |    |    | This bucket contains minimum series value\n * 0.5-1|____|____|____|____|____| This bucket should be displayed as 0 on graph\n *     0|____|____|____|____|____| This bucket is for 0 values (should actually be -Infinity)\n * So we should merge two bottom buckets into one (0-value bucket).\n *\n * @param  {Object} buckets  Heatmap buckets\n * @param  {Number} minValue Minimum series value\n * @returns {Object}          Transformed buckets\n */\nfunction mergeZeroBuckets(buckets: any, minValue: number) {\n  forEach(buckets, (xBucket) => {\n    const yBuckets = xBucket.buckets;\n\n    const emptyBucket: any = {\n      bounds: { bottom: 0, top: 0 },\n      values: [],\n      points: [],\n      count: 0,\n    };\n\n    const nullBucket = yBuckets[0] || emptyBucket;\n    const minBucket = yBuckets[minValue] || emptyBucket;\n\n    const newBucket: any = {\n      y: 0,\n      bounds: { bottom: minValue, top: minBucket.bounds.top || minValue },\n      values: [],\n      points: [],\n      count: 0,\n    };\n\n    newBucket.points = nullBucket.points.concat(minBucket.points);\n    newBucket.values = nullBucket.values.concat(minBucket.values);\n    newBucket.count = newBucket.values.length;\n\n    if (newBucket.count === 0) {\n      return;\n    }\n\n    delete yBuckets[minValue];\n    yBuckets[0] = newBucket;\n  });\n\n  return buckets;\n}\n\n/**\n * Convert set of time series into heatmap buckets\n * @returns {Object}    Heatmap object:\n * {\n *   xBucketBound_1: {\n *     x: xBucketBound_1,\n *     buckets: {\n *       yBucketBound_1: {\n *         y: yBucketBound_1,\n *         bounds: {bottom, top}\n *         values: [val_1, val_2, ..., val_K],\n *         points: [[val_Y, val_X, series_name], ..., [...]],\n *         seriesStat: {seriesName_1: val_1, seriesName_2: val_2}\n *       },\n *       ...\n *       yBucketBound_M: {}\n *     },\n *     values: [val_1, val_2, ..., val_K],\n *     points: [\n *       [val_Y, val_X, series_name], (point_1)\n *       ...\n *       [...] (point_K)\n *     ]\n *   },\n *   xBucketBound_2: {},\n *   ...\n *   xBucketBound_N: {}\n * }\n */\nfunction convertToHeatMap(seriesList: TimeSeries[], yBucketSize: number, xBucketSize: number, logBase = 1) {\n  const heatmap = {};\n\n  for (const series of seriesList) {\n    const datapoints = series.datapoints;\n    const seriesName = series.label;\n\n    // Slice series into X axis buckets\n    // |    | ** |    |  * |  **|\n    // |  * |*  *|*   |** *| *  |\n    // |** *|    | ***|    |*   |\n    // |____|____|____|____|____|_\n    //\n    forEach(datapoints, (point) => {\n      const bucketBound = getBucketBound(point[TIME_INDEX], xBucketSize);\n      pushToXBuckets(heatmap, point, bucketBound, seriesName);\n    });\n  }\n\n  // Slice X axis buckets into Y (value) buckets\n  // |  **|     |2|,\n  // | *  | --\\ |1|,\n  // |*   | --/ |1|,\n  // |____|     |0|\n  //\n  forEach(heatmap, (xBucket: any) => {\n    if (logBase !== 1) {\n      xBucket.buckets = convertToLogScaleValueBuckets(xBucket, yBucketSize, logBase);\n    } else {\n      xBucket.buckets = convertToValueBuckets(xBucket, yBucketSize);\n    }\n  });\n\n  return heatmap;\n}\n\nfunction pushToXBuckets(buckets: any, point: any[], bucketNum: number, seriesName: string) {\n  const value = point[VALUE_INDEX];\n  if (value === null || value === undefined || isNaN(value)) {\n    return;\n  }\n\n  // Add series name to point for future identification\n  const pointExt = concat(point, seriesName);\n\n  if (buckets[bucketNum] && buckets[bucketNum].values) {\n    buckets[bucketNum].values.push(value);\n    buckets[bucketNum].points.push(pointExt);\n  } else {\n    buckets[bucketNum] = {\n      x: bucketNum,\n      values: [value],\n      points: [pointExt],\n    };\n  }\n}\n\nfunction pushToYBuckets(\n  buckets: Bucket,\n  bucketNum: number,\n  value: any,\n  point: string[],\n  bounds: { bottom: number; top: number }\n) {\n  let count = 1;\n  // Use the 3rd argument as scale/count\n  if (point.length > 3) {\n    count = parseInt(point[2], 10);\n  }\n  if (buckets[bucketNum]) {\n    buckets[bucketNum].values.push(value);\n    buckets[bucketNum].points?.push(point);\n    buckets[bucketNum].count += count;\n  } else {\n    buckets[bucketNum] = {\n      y: bucketNum,\n      bounds: bounds,\n      values: [value],\n      points: [point],\n      count: count,\n    };\n  }\n}\n\nfunction getValueBucketBound(value: any, yBucketSize: number, logBase: number) {\n  if (logBase === 1) {\n    return getBucketBound(value, yBucketSize);\n  } else {\n    return getLogScaleBucketBound(value, yBucketSize, logBase);\n  }\n}\n\n/**\n * Find bucket for given value (for linear scale)\n */\nfunction getBucketBounds(value: number, bucketSize: number) {\n  let bottom, top;\n  bottom = Math.floor(value / bucketSize) * bucketSize;\n  top = (Math.floor(value / bucketSize) + 1) * bucketSize;\n\n  return { bottom, top };\n}\n\nfunction getBucketBound(value: number, bucketSize: number) {\n  const bounds = getBucketBounds(value, bucketSize);\n  return bounds.bottom;\n}\n\nfunction convertToValueBuckets(xBucket: { values: any; points: any }, bucketSize: number) {\n  const values = xBucket.values;\n  const points = xBucket.points;\n  const buckets = {};\n\n  forEach(values, (val, index) => {\n    const bounds = getBucketBounds(val, bucketSize);\n    const bucketNum = bounds.bottom;\n    pushToYBuckets(buckets, bucketNum, val, points[index], bounds);\n  });\n\n  return buckets;\n}\n\n/**\n * Find bucket for given value (for log scales)\n */\nfunction getLogScaleBucketBounds(value: number, yBucketSplitFactor: number, logBase: number) {\n  let top, bottom;\n  if (value === 0) {\n    return { bottom: 0, top: 0 };\n  }\n\n  const valueLog = logp(value, logBase);\n  let pow, powTop;\n  if (yBucketSplitFactor === 1 || !yBucketSplitFactor) {\n    pow = Math.floor(valueLog);\n    powTop = pow + 1;\n  } else {\n    const additionalBucketSize = 1 / yBucketSplitFactor;\n    let additionalLog = valueLog - Math.floor(valueLog);\n    additionalLog = Math.floor(additionalLog / additionalBucketSize) * additionalBucketSize;\n    pow = Math.floor(valueLog) + additionalLog;\n    powTop = pow + additionalBucketSize;\n  }\n  bottom = Math.pow(logBase, pow);\n  top = Math.pow(logBase, powTop);\n\n  return { bottom, top };\n}\n\nfunction getLogScaleBucketBound(value: number, yBucketSplitFactor: number, logBase: number) {\n  const bounds = getLogScaleBucketBounds(value, yBucketSplitFactor, logBase);\n  return bounds.bottom;\n}\n\nfunction convertToLogScaleValueBuckets(\n  xBucket: { values: any; points: any },\n  yBucketSplitFactor: number,\n  logBase: number\n) {\n  const values = xBucket.values;\n  const points = xBucket.points;\n\n  const buckets = {};\n  forEach(values, (val, index) => {\n    const bounds = getLogScaleBucketBounds(val, yBucketSplitFactor, logBase);\n    const bucketNum = bounds.bottom;\n    pushToYBuckets(buckets, bucketNum, val, points[index], bounds);\n  });\n\n  return buckets;\n}\n\n/**\n * Logarithm for custom base\n * @param value\n * @param base logarithm base\n */\nfunction logp(value: number, base: number) {\n  return Math.log(value) / Math.log(base);\n}\n\n/**\n * Calculate size of Y bucket from given buckets bounds.\n * @param bounds Array of Y buckets bounds\n * @param logBase Logarithm base\n */\nfunction calculateBucketSize(bounds: number[], logBase = 1): number {\n  let bucketSize = Infinity;\n\n  if (bounds.length === 0) {\n    return 0;\n  } else if (bounds.length === 1) {\n    return bounds[0];\n  } else {\n    bounds = sortBy(bounds);\n    for (let i = 1; i < bounds.length; i++) {\n      const distance = getDistance(bounds[i], bounds[i - 1], logBase);\n      bucketSize = distance < bucketSize ? distance : bucketSize;\n    }\n  }\n\n  return bucketSize;\n}\n\n/**\n * Calculate distance between two numbers in given scale (linear or logarithmic).\n * @param a\n * @param b\n * @param logBase\n */\nfunction getDistance(a: number, b: number, logBase = 1): number {\n  if (logBase === 1) {\n    // Linear distance\n    return Math.abs(b - a);\n  } else {\n    // logarithmic distance\n    const ratio = Math.max(a, b) / Math.min(a, b);\n    return logp(ratio, logBase);\n  }\n}\n\n/**\n * Compare two heatmap data objects\n * @param objA\n * @param objB\n */\nfunction isHeatmapDataEqual(objA: any, objB: any): boolean {\n  let isEql = !emptyXOR(objA, objB);\n\n  forEach(objA, (xBucket: XBucket, x) => {\n    if (objB[x]) {\n      if (emptyXOR(xBucket.buckets, objB[x].buckets)) {\n        isEql = false;\n        return false;\n      }\n\n      forEach(xBucket.buckets, (yBucket: YBucket, y) => {\n        if (objB[x].buckets && objB[x].buckets[y]) {\n          if (objB[x].buckets[y].values) {\n            isEql = isEqual(sortBy(yBucket.values), sortBy(objB[x].buckets[y].values));\n            if (!isEql) {\n              return false;\n            } else {\n              return true;\n            }\n          } else {\n            isEql = false;\n            return false;\n          }\n        } else {\n          isEql = false;\n          return false;\n        }\n      });\n\n      if (!isEql) {\n        return false;\n      } else {\n        return true;\n      }\n    } else {\n      isEql = false;\n      return false;\n    }\n  });\n\n  return isEql;\n}\n\nfunction emptyXOR(foo: any, bar: any): boolean {\n  return (isEmpty(foo) || isEmpty(bar)) && !(isEmpty(foo) && isEmpty(bar));\n}\n\nexport {\n  convertToHeatMap,\n  histogramToHeatmap,\n  convertToCards,\n  mergeZeroBuckets,\n  getValueBucketBound,\n  isHeatmapDataEqual,\n  calculateBucketSize,\n  sortSeriesByLabel,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}