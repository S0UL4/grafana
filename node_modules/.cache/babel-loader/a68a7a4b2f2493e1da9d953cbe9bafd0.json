{"ast":null,"code":"import React, { createContext, useCallback, useContext } from 'react';\nimport { combineReducers, useStatelessReducer, DispatchContext } from '../../hooks/useStatelessReducer';\nimport { createReducer as createBucketAggsReducer } from './BucketAggregationsEditor/state/reducer';\nimport { reducer as metricsReducer } from './MetricAggregationsEditor/state/reducer';\nimport { aliasPatternReducer, queryReducer, initQuery } from './state';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst DatasourceContext = /*#__PURE__*/createContext(undefined);\nconst QueryContext = /*#__PURE__*/createContext(undefined);\nconst RangeContext = /*#__PURE__*/createContext(undefined);\nexport const ElasticsearchProvider = ({\n  children,\n  onChange,\n  onRunQuery,\n  query,\n  datasource,\n  range\n}) => {\n  const onStateChange = useCallback(query => {\n    onChange(query);\n    onRunQuery();\n  }, [onChange, onRunQuery]);\n  const reducer = combineReducers({\n    query: queryReducer,\n    alias: aliasPatternReducer,\n    metrics: metricsReducer,\n    bucketAggs: createBucketAggsReducer(datasource.timeField)\n  });\n  const dispatch = useStatelessReducer( // timeField is part of the query model, but its value is always set to be the one from datasource settings.\n  newState => onStateChange(Object.assign({}, query, newState, {\n    timeField: datasource.timeField\n  })), query, reducer); // This initializes the query by dispatching an init action to each reducer.\n  // useStatelessReducer will then call `onChange` with the newly generated query\n\n  if (!query.metrics || !query.bucketAggs || query.query === undefined) {\n    dispatch(initQuery());\n    return null;\n  }\n\n  return /*#__PURE__*/_jsx(DatasourceContext.Provider, {\n    value: datasource,\n    children: /*#__PURE__*/_jsx(QueryContext.Provider, {\n      value: query,\n      children: /*#__PURE__*/_jsx(RangeContext.Provider, {\n        value: range,\n        children: /*#__PURE__*/_jsx(DispatchContext.Provider, {\n          value: dispatch,\n          children: children\n        })\n      })\n    })\n  });\n};\n\nconst getHook = c => () => {\n  const contextValue = useContext(c);\n\n  if (!contextValue) {\n    throw new Error('use ElasticsearchProvider first.');\n  }\n\n  return contextValue;\n};\n\nexport const useQuery = getHook(QueryContext);\nexport const useDatasource = getHook(DatasourceContext);\nexport const useRange = getHook(RangeContext);","map":{"version":3,"names":["React","createContext","useCallback","useContext","combineReducers","useStatelessReducer","DispatchContext","createReducer","createBucketAggsReducer","reducer","metricsReducer","aliasPatternReducer","queryReducer","initQuery","DatasourceContext","undefined","QueryContext","RangeContext","ElasticsearchProvider","children","onChange","onRunQuery","query","datasource","range","onStateChange","alias","metrics","bucketAggs","timeField","dispatch","newState","getHook","c","contextValue","Error","useQuery","useDatasource","useRange"],"sources":["/home/soula/grafana/public/app/plugins/datasource/elasticsearch/components/QueryEditor/ElasticsearchQueryContext.tsx"],"sourcesContent":["import React, { Context, createContext, PropsWithChildren, useCallback, useContext } from 'react';\n\nimport { TimeRange } from '@grafana/data';\n\nimport { ElasticDatasource } from '../../datasource';\nimport { combineReducers, useStatelessReducer, DispatchContext } from '../../hooks/useStatelessReducer';\nimport { ElasticsearchQuery } from '../../types';\n\nimport { createReducer as createBucketAggsReducer } from './BucketAggregationsEditor/state/reducer';\nimport { reducer as metricsReducer } from './MetricAggregationsEditor/state/reducer';\nimport { aliasPatternReducer, queryReducer, initQuery } from './state';\n\nconst DatasourceContext = createContext<ElasticDatasource | undefined>(undefined);\nconst QueryContext = createContext<ElasticsearchQuery | undefined>(undefined);\nconst RangeContext = createContext<TimeRange | undefined>(undefined);\n\ninterface Props {\n  query: ElasticsearchQuery;\n  onChange: (query: ElasticsearchQuery) => void;\n  onRunQuery: () => void;\n  datasource: ElasticDatasource;\n  range: TimeRange;\n}\n\nexport const ElasticsearchProvider = ({\n  children,\n  onChange,\n  onRunQuery,\n  query,\n  datasource,\n  range,\n}: PropsWithChildren<Props>) => {\n  const onStateChange = useCallback(\n    (query: ElasticsearchQuery) => {\n      onChange(query);\n      onRunQuery();\n    },\n    [onChange, onRunQuery]\n  );\n\n  const reducer = combineReducers<Pick<ElasticsearchQuery, 'query' | 'alias' | 'metrics' | 'bucketAggs'>>({\n    query: queryReducer,\n    alias: aliasPatternReducer,\n    metrics: metricsReducer,\n    bucketAggs: createBucketAggsReducer(datasource.timeField),\n  });\n\n  const dispatch = useStatelessReducer(\n    // timeField is part of the query model, but its value is always set to be the one from datasource settings.\n    (newState) => onStateChange({ ...query, ...newState, timeField: datasource.timeField }),\n    query,\n    reducer\n  );\n\n  // This initializes the query by dispatching an init action to each reducer.\n  // useStatelessReducer will then call `onChange` with the newly generated query\n  if (!query.metrics || !query.bucketAggs || query.query === undefined) {\n    dispatch(initQuery());\n\n    return null;\n  }\n\n  return (\n    <DatasourceContext.Provider value={datasource}>\n      <QueryContext.Provider value={query}>\n        <RangeContext.Provider value={range}>\n          <DispatchContext.Provider value={dispatch}>{children}</DispatchContext.Provider>\n        </RangeContext.Provider>\n      </QueryContext.Provider>\n    </DatasourceContext.Provider>\n  );\n};\n\ninterface GetHook {\n  <T>(context: Context<T>): () => NonNullable<T>;\n}\n\nconst getHook: GetHook = (c) => () => {\n  const contextValue = useContext(c);\n\n  if (!contextValue) {\n    throw new Error('use ElasticsearchProvider first.');\n  }\n\n  return contextValue as NonNullable<typeof contextValue>;\n};\n\nexport const useQuery = getHook(QueryContext);\nexport const useDatasource = getHook(DatasourceContext);\nexport const useRange = getHook(RangeContext);\n"],"mappings":"AAAA,OAAOA,KAAP,IAAyBC,aAAzB,EAA2DC,WAA3D,EAAwEC,UAAxE,QAA0F,OAA1F;AAKA,SAASC,eAAT,EAA0BC,mBAA1B,EAA+CC,eAA/C,QAAsE,iCAAtE;AAGA,SAASC,aAAa,IAAIC,uBAA1B,QAAyD,0CAAzD;AACA,SAASC,OAAO,IAAIC,cAApB,QAA0C,0CAA1C;AACA,SAASC,mBAAT,EAA8BC,YAA9B,EAA4CC,SAA5C,QAA6D,SAA7D;;AAEA,MAAMC,iBAAiB,gBAAGb,aAAa,CAAgCc,SAAhC,CAAvC;AACA,MAAMC,YAAY,gBAAGf,aAAa,CAAiCc,SAAjC,CAAlC;AACA,MAAME,YAAY,gBAAGhB,aAAa,CAAwBc,SAAxB,CAAlC;AAUA,OAAO,MAAMG,qBAAqB,GAAG,CAAC;EACpCC,QADoC;EAEpCC,QAFoC;EAGpCC,UAHoC;EAIpCC,KAJoC;EAKpCC,UALoC;EAMpCC;AANoC,CAAD,KAOL;EAC9B,MAAMC,aAAa,GAAGvB,WAAW,CAC9BoB,KAAD,IAA+B;IAC7BF,QAAQ,CAACE,KAAD,CAAR;IACAD,UAAU;EACX,CAJ8B,EAK/B,CAACD,QAAD,EAAWC,UAAX,CAL+B,CAAjC;EAQA,MAAMZ,OAAO,GAAGL,eAAe,CAAyE;IACtGkB,KAAK,EAAEV,YAD+F;IAEtGc,KAAK,EAAEf,mBAF+F;IAGtGgB,OAAO,EAAEjB,cAH6F;IAItGkB,UAAU,EAAEpB,uBAAuB,CAACe,UAAU,CAACM,SAAZ;EAJmE,CAAzE,CAA/B;EAOA,MAAMC,QAAQ,GAAGzB,mBAAmB,EAClC;EACC0B,QAAD,IAAcN,aAAa,mBAAMH,KAAN,EAAgBS,QAAhB;IAA0BF,SAAS,EAAEN,UAAU,CAACM;EAAhD,GAFO,EAGlCP,KAHkC,EAIlCb,OAJkC,CAApC,CAhB8B,CAuB9B;EACA;;EACA,IAAI,CAACa,KAAK,CAACK,OAAP,IAAkB,CAACL,KAAK,CAACM,UAAzB,IAAuCN,KAAK,CAACA,KAAN,KAAgBP,SAA3D,EAAsE;IACpEe,QAAQ,CAACjB,SAAS,EAAV,CAAR;IAEA,OAAO,IAAP;EACD;;EAED,oBACE,KAAC,iBAAD,CAAmB,QAAnB;IAA4B,KAAK,EAAEU,UAAnC;IAAA,uBACE,KAAC,YAAD,CAAc,QAAd;MAAuB,KAAK,EAAED,KAA9B;MAAA,uBACE,KAAC,YAAD,CAAc,QAAd;QAAuB,KAAK,EAAEE,KAA9B;QAAA,uBACE,KAAC,eAAD,CAAiB,QAAjB;UAA0B,KAAK,EAAEM,QAAjC;UAAA,UAA4CX;QAA5C;MADF;IADF;EADF,EADF;AASD,CA/CM;;AAqDP,MAAMa,OAAgB,GAAIC,CAAD,IAAO,MAAM;EACpC,MAAMC,YAAY,GAAG/B,UAAU,CAAC8B,CAAD,CAA/B;;EAEA,IAAI,CAACC,YAAL,EAAmB;IACjB,MAAM,IAAIC,KAAJ,CAAU,kCAAV,CAAN;EACD;;EAED,OAAOD,YAAP;AACD,CARD;;AAUA,OAAO,MAAME,QAAQ,GAAGJ,OAAO,CAAChB,YAAD,CAAxB;AACP,OAAO,MAAMqB,aAAa,GAAGL,OAAO,CAAClB,iBAAD,CAA7B;AACP,OAAO,MAAMwB,QAAQ,GAAGN,OAAO,CAACf,YAAD,CAAxB"},"metadata":{},"sourceType":"module"}