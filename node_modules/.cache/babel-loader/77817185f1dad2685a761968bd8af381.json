{"ast":null,"code":"var _div;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Libraries\nimport $ from 'jquery';\nimport { uniqBy } from 'lodash';\nimport React, { PureComponent } from 'react'; // Types\n\nimport { createDimension } from '@grafana/data';\nimport { TooltipDisplayMode } from '@grafana/schema';\nimport { VizTooltip } from '../VizTooltip';\nimport { GraphContextMenu } from './GraphContextMenu';\nimport { GraphTooltip } from './GraphTooltip/GraphTooltip';\nimport { graphTimeFormat, graphTickFormatter } from './utils';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\n\n/**\n * This is a react wrapper for the angular, flot based graph visualization.\n * Rather than using this component, you should use the `<PanelRender .../> with\n * timeseries panel configs.\n *\n * @deprecated\n */\nexport class Graph extends PureComponent {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"state\", {\n      isTooltipVisible: false,\n      isContextVisible: false\n    });\n\n    _defineProperty(this, \"element\", null);\n\n    _defineProperty(this, \"$element\", void 0);\n\n    _defineProperty(this, \"onPlotSelected\", (event, ranges) => {\n      const {\n        onHorizontalRegionSelected\n      } = this.props;\n\n      if (onHorizontalRegionSelected) {\n        onHorizontalRegionSelected(ranges.xaxis.from, ranges.xaxis.to);\n      }\n    });\n\n    _defineProperty(this, \"onPlotHover\", (event, pos, item) => {\n      this.setState({\n        isTooltipVisible: true,\n        activeItem: item,\n        pos\n      });\n    });\n\n    _defineProperty(this, \"onPlotClick\", (event, contextPos, item) => {\n      this.setState({\n        isContextVisible: true,\n        isTooltipVisible: false,\n        contextItem: item,\n        contextPos\n      });\n    });\n\n    _defineProperty(this, \"renderTooltip\", () => {\n      const {\n        children,\n        series,\n        timeZone\n      } = this.props;\n      const {\n        pos,\n        activeItem,\n        isTooltipVisible\n      } = this.state;\n      let tooltipElement = null;\n\n      if (!isTooltipVisible || !pos || series.length === 0) {\n        return null;\n      } // Find children that indicate tooltip to be rendered\n\n\n      React.Children.forEach(children, c => {\n        // We have already found tooltip\n        if (tooltipElement) {\n          return;\n        } // @ts-ignore\n\n\n        const childType = c && c.type && (c.type.displayName || c.type.name);\n\n        if (childType === VizTooltip.displayName) {\n          tooltipElement = c;\n        }\n      }); // If no tooltip provided, skip rendering\n\n      if (!tooltipElement) {\n        return null;\n      }\n\n      const tooltipElementProps = tooltipElement.props;\n      const tooltipMode = tooltipElementProps.mode || 'single'; // If mode is single series and user is not hovering over item, skip rendering\n\n      if (!activeItem && tooltipMode === 'single') {\n        return null;\n      } // Check if tooltip needs to be rendered with custom tooltip component, otherwise default to GraphTooltip\n\n\n      const tooltipContentRenderer = tooltipElementProps.tooltipComponent || GraphTooltip; // Indicates column(field) index in y-axis dimension\n\n      const seriesIndex = activeItem ? activeItem.series.seriesIndex : 0; // Indicates row index in active field values\n\n      const rowIndex = activeItem ? activeItem.dataIndex : undefined;\n      const activeDimensions = {\n        // Described x-axis active item\n        // When hovering over an item - let's take it's dataIndex, otherwise undefined\n        // Tooltip itself needs to figure out correct datapoint display information based on pos passed to it\n        xAxis: [seriesIndex, rowIndex],\n        // Describes y-axis active item\n        yAxis: activeItem ? [activeItem.series.seriesIndex, activeItem.dataIndex] : null\n      };\n      const tooltipContentProps = {\n        dimensions: {\n          // time/value dimension columns are index-aligned - see getGraphSeriesModel\n          xAxis: createDimension('xAxis', series.map(s => s.timeField)),\n          yAxis: createDimension('yAxis', series.map(s => s.valueField))\n        },\n        activeDimensions,\n        pos,\n        mode: tooltipElementProps.mode || TooltipDisplayMode.Single,\n        timeZone\n      };\n      const tooltipContent = /*#__PURE__*/React.createElement(tooltipContentRenderer, Object.assign({}, tooltipContentProps));\n      return /*#__PURE__*/React.cloneElement(tooltipElement, {\n        content: tooltipContent,\n        position: {\n          x: pos.pageX,\n          y: pos.pageY\n        },\n        offset: {\n          x: 10,\n          y: 10\n        }\n      });\n    });\n\n    _defineProperty(this, \"renderContextMenu\", () => {\n      const {\n        series\n      } = this.props;\n      const {\n        contextPos,\n        contextItem,\n        isContextVisible\n      } = this.state;\n\n      if (!isContextVisible || !contextPos || !contextItem || series.length === 0) {\n        return null;\n      } // Indicates column(field) index in y-axis dimension\n\n\n      const seriesIndex = contextItem ? contextItem.series.seriesIndex : 0; // Indicates row index in context field values\n\n      const rowIndex = contextItem ? contextItem.dataIndex : undefined;\n      const contextDimensions = {\n        // Described x-axis context item\n        xAxis: [seriesIndex, rowIndex],\n        // Describes y-axis context item\n        yAxis: contextItem ? [contextItem.series.seriesIndex, contextItem.dataIndex] : null\n      };\n      const dimensions = {\n        // time/value dimension columns are index-aligned - see getGraphSeriesModel\n        xAxis: createDimension('xAxis', series.map(s => s.timeField)),\n        yAxis: createDimension('yAxis', series.map(s => s.valueField))\n      };\n\n      const closeContext = () => this.setState({\n        isContextVisible: false\n      });\n\n      const getContextMenuSource = () => {\n        return {\n          datapoint: contextItem.datapoint,\n          dataIndex: contextItem.dataIndex,\n          series: contextItem.series,\n          seriesIndex: contextItem.series.seriesIndex,\n          pageX: contextPos.pageX,\n          pageY: contextPos.pageY\n        };\n      };\n\n      const contextContentProps = {\n        x: contextPos.pageX,\n        y: contextPos.pageY,\n        onClose: closeContext,\n        getContextMenuSource: getContextMenuSource,\n        timeZone: this.props.timeZone,\n        dimensions,\n        contextDimensions\n      };\n      return /*#__PURE__*/_jsx(GraphContextMenu, Object.assign({}, contextContentProps));\n    });\n\n    _defineProperty(this, \"getBarWidth\", () => {\n      const {\n        series\n      } = this.props;\n      return Math.min(...series.map(s => s.timeStep));\n    });\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    if (prevProps !== this.props) {\n      this.draw();\n    }\n  }\n\n  componentDidMount() {\n    this.draw();\n\n    if (this.element) {\n      this.$element = $(this.element);\n      this.$element.bind('plotselected', this.onPlotSelected);\n      this.$element.bind('plothover', this.onPlotHover);\n      this.$element.bind('plotclick', this.onPlotClick);\n    }\n  }\n\n  componentWillUnmount() {\n    if (this.$element) {\n      this.$element.unbind('plotselected', this.onPlotSelected);\n    }\n  }\n\n  getYAxes(series) {\n    if (series.length === 0) {\n      return [{\n        show: true,\n        min: -1,\n        max: 1\n      }];\n    }\n\n    return uniqBy(series.map(s => {\n      const index = s.yAxis ? s.yAxis.index : 1;\n      const min = s.yAxis && !isNaN(s.yAxis.min) ? s.yAxis.min : null;\n      const tickDecimals = s.yAxis && !isNaN(s.yAxis.tickDecimals) ? s.yAxis.tickDecimals : null;\n      return {\n        show: true,\n        index,\n        position: index === 1 ? 'left' : 'right',\n        min,\n        tickDecimals\n      };\n    }), yAxisConfig => yAxisConfig.index);\n  }\n\n  draw() {\n    if (this.element === null) {\n      return;\n    }\n\n    const {\n      width,\n      series,\n      timeRange,\n      showLines,\n      showBars,\n      showPoints,\n      isStacked,\n      lineWidth,\n      timeZone,\n      onHorizontalRegionSelected\n    } = this.props;\n\n    if (!width) {\n      return;\n    }\n\n    const ticks = width / 100;\n    const min = timeRange.from.valueOf();\n    const max = timeRange.to.valueOf();\n    const yaxes = this.getYAxes(series);\n    const flotOptions = {\n      legend: {\n        show: false\n      },\n      series: {\n        stack: isStacked,\n        lines: {\n          show: showLines,\n          lineWidth: lineWidth,\n          zero: false\n        },\n        points: {\n          show: showPoints,\n          fill: 1,\n          fillColor: false,\n          radius: 2\n        },\n        bars: {\n          show: showBars,\n          fill: 1,\n          // Dividig the width by 1.5 to make the bars not touch each other\n          barWidth: showBars ? this.getBarWidth() / 1.5 : 1,\n          zero: false,\n          lineWidth: lineWidth\n        },\n        shadowSize: 0\n      },\n      xaxis: {\n        timezone: timeZone,\n        show: true,\n        mode: 'time',\n        min: min,\n        max: max,\n        label: 'Datetime',\n        ticks: ticks,\n        timeformat: graphTimeFormat(ticks, min, max),\n        tickFormatter: graphTickFormatter\n      },\n      yaxes,\n      grid: {\n        minBorderMargin: 0,\n        markings: [],\n        backgroundColor: null,\n        borderWidth: 0,\n        hoverable: true,\n        clickable: true,\n        color: '#a1a1a1',\n        margin: {\n          left: 0,\n          right: 0\n        },\n        labelMarginX: 0,\n        mouseActiveRadius: 30\n      },\n      selection: {\n        mode: onHorizontalRegionSelected ? 'x' : null,\n        color: '#666'\n      },\n      crosshair: {\n        mode: 'x'\n      }\n    };\n\n    try {\n      $.plot(this.element, series.filter(s => s.isVisible), flotOptions);\n    } catch (err) {\n      console.error('Graph rendering error', err, flotOptions, series);\n      throw new Error('Error rendering panel');\n    }\n  }\n\n  render() {\n    const {\n      ariaLabel,\n      height,\n      width,\n      series\n    } = this.props;\n    const noDataToBeDisplayed = series.length === 0;\n    const tooltip = this.renderTooltip();\n    const context = this.renderContextMenu();\n    return /*#__PURE__*/_jsxs(\"div\", {\n      className: \"graph-panel\",\n      \"aria-label\": ariaLabel,\n      children: [/*#__PURE__*/_jsx(\"div\", {\n        className: \"graph-panel__chart\",\n        ref: e => this.element = e,\n        style: {\n          height,\n          width\n        },\n        onMouseLeave: () => {\n          this.setState({\n            isTooltipVisible: false\n          });\n        }\n      }), noDataToBeDisplayed && (_div || (_div = /*#__PURE__*/_jsx(\"div\", {\n        className: \"datapoints-warning\",\n        children: \"No data\"\n      }))), tooltip, context]\n    });\n  }\n\n}\n\n_defineProperty(Graph, \"defaultProps\", {\n  showLines: true,\n  showPoints: false,\n  showBars: false,\n  isStacked: false,\n  lineWidth: 1\n});\n\nexport default Graph;","map":{"version":3,"names":["$","uniqBy","React","PureComponent","createDimension","TooltipDisplayMode","VizTooltip","GraphContextMenu","GraphTooltip","graphTimeFormat","graphTickFormatter","Graph","isTooltipVisible","isContextVisible","event","ranges","onHorizontalRegionSelected","props","xaxis","from","to","pos","item","setState","activeItem","contextPos","contextItem","children","series","timeZone","state","tooltipElement","length","Children","forEach","c","childType","type","displayName","name","tooltipElementProps","tooltipMode","mode","tooltipContentRenderer","tooltipComponent","seriesIndex","rowIndex","dataIndex","undefined","activeDimensions","xAxis","yAxis","tooltipContentProps","dimensions","map","s","timeField","valueField","Single","tooltipContent","createElement","cloneElement","content","position","x","pageX","y","pageY","offset","contextDimensions","closeContext","getContextMenuSource","datapoint","contextContentProps","onClose","Math","min","timeStep","componentDidUpdate","prevProps","prevState","draw","componentDidMount","element","$element","bind","onPlotSelected","onPlotHover","onPlotClick","componentWillUnmount","unbind","getYAxes","show","max","index","isNaN","tickDecimals","yAxisConfig","width","timeRange","showLines","showBars","showPoints","isStacked","lineWidth","ticks","valueOf","yaxes","flotOptions","legend","stack","lines","zero","points","fill","fillColor","radius","bars","barWidth","getBarWidth","shadowSize","timezone","label","timeformat","tickFormatter","grid","minBorderMargin","markings","backgroundColor","borderWidth","hoverable","clickable","color","margin","left","right","labelMarginX","mouseActiveRadius","selection","crosshair","plot","filter","isVisible","err","console","error","Error","render","ariaLabel","height","noDataToBeDisplayed","tooltip","renderTooltip","context","renderContextMenu","e"],"sources":["/home/soula/grafana/packages/grafana-ui/src/components/Graph/Graph.tsx"],"sourcesContent":["// Libraries\nimport $ from 'jquery';\nimport { uniqBy } from 'lodash';\nimport React, { PureComponent } from 'react';\n\n// Types\nimport { TimeRange, GraphSeriesXY, TimeZone, createDimension } from '@grafana/data';\nimport { TooltipDisplayMode } from '@grafana/schema';\n\nimport { VizTooltipProps, VizTooltipContentProps, ActiveDimensions, VizTooltip } from '../VizTooltip';\n\nimport { GraphContextMenu, GraphContextMenuProps, ContextDimensions } from './GraphContextMenu';\nimport { GraphTooltip } from './GraphTooltip/GraphTooltip';\nimport { GraphDimensions } from './GraphTooltip/types';\nimport { FlotPosition, FlotItem } from './types';\nimport { graphTimeFormat, graphTickFormatter } from './utils';\n\nexport interface GraphProps {\n  ariaLabel?: string;\n  children?: JSX.Element | JSX.Element[];\n  series: GraphSeriesXY[];\n  timeRange: TimeRange; // NOTE: we should aim to make `time` a property of the axis, not force it for all graphs\n  timeZone?: TimeZone; // NOTE: we should aim to make `time` a property of the axis, not force it for all graphs\n  showLines?: boolean;\n  showPoints?: boolean;\n  showBars?: boolean;\n  width: number;\n  height: number;\n  isStacked?: boolean;\n  lineWidth?: number;\n  onHorizontalRegionSelected?: (from: number, to: number) => void;\n}\n\ninterface GraphState {\n  pos?: FlotPosition;\n  contextPos?: FlotPosition;\n  isTooltipVisible: boolean;\n  isContextVisible: boolean;\n  activeItem?: FlotItem<GraphSeriesXY>;\n  contextItem?: FlotItem<GraphSeriesXY>;\n}\n\n/**\n * This is a react wrapper for the angular, flot based graph visualization.\n * Rather than using this component, you should use the `<PanelRender .../> with\n * timeseries panel configs.\n *\n * @deprecated\n */\nexport class Graph extends PureComponent<GraphProps, GraphState> {\n  static defaultProps = {\n    showLines: true,\n    showPoints: false,\n    showBars: false,\n    isStacked: false,\n    lineWidth: 1,\n  };\n\n  state: GraphState = {\n    isTooltipVisible: false,\n    isContextVisible: false,\n  };\n\n  element: HTMLElement | null = null;\n  $element: any;\n\n  componentDidUpdate(prevProps: GraphProps, prevState: GraphState) {\n    if (prevProps !== this.props) {\n      this.draw();\n    }\n  }\n\n  componentDidMount() {\n    this.draw();\n    if (this.element) {\n      this.$element = $(this.element);\n      this.$element.bind('plotselected', this.onPlotSelected);\n      this.$element.bind('plothover', this.onPlotHover);\n      this.$element.bind('plotclick', this.onPlotClick);\n    }\n  }\n\n  componentWillUnmount() {\n    if (this.$element) {\n      this.$element.unbind('plotselected', this.onPlotSelected);\n    }\n  }\n\n  onPlotSelected = (event: JQueryEventObject, ranges: { xaxis: { from: number; to: number } }) => {\n    const { onHorizontalRegionSelected } = this.props;\n    if (onHorizontalRegionSelected) {\n      onHorizontalRegionSelected(ranges.xaxis.from, ranges.xaxis.to);\n    }\n  };\n\n  onPlotHover = (event: JQueryEventObject, pos: FlotPosition, item?: FlotItem<GraphSeriesXY>) => {\n    this.setState({\n      isTooltipVisible: true,\n      activeItem: item,\n      pos,\n    });\n  };\n\n  onPlotClick = (event: JQueryEventObject, contextPos: FlotPosition, item?: FlotItem<GraphSeriesXY>) => {\n    this.setState({\n      isContextVisible: true,\n      isTooltipVisible: false,\n      contextItem: item,\n      contextPos,\n    });\n  };\n\n  getYAxes(series: GraphSeriesXY[]) {\n    if (series.length === 0) {\n      return [{ show: true, min: -1, max: 1 }];\n    }\n    return uniqBy(\n      series.map((s) => {\n        const index = s.yAxis ? s.yAxis.index : 1;\n        const min = s.yAxis && !isNaN(s.yAxis.min as number) ? s.yAxis.min : null;\n        const tickDecimals = s.yAxis && !isNaN(s.yAxis.tickDecimals as number) ? s.yAxis.tickDecimals : null;\n        return {\n          show: true,\n          index,\n          position: index === 1 ? 'left' : 'right',\n          min,\n          tickDecimals,\n        };\n      }),\n      (yAxisConfig) => yAxisConfig.index\n    );\n  }\n\n  renderTooltip = () => {\n    const { children, series, timeZone } = this.props;\n    const { pos, activeItem, isTooltipVisible } = this.state;\n    let tooltipElement: React.ReactElement<VizTooltipProps> | null = null;\n\n    if (!isTooltipVisible || !pos || series.length === 0) {\n      return null;\n    }\n\n    // Find children that indicate tooltip to be rendered\n    React.Children.forEach(children, (c) => {\n      // We have already found tooltip\n      if (tooltipElement) {\n        return;\n      }\n      // @ts-ignore\n      const childType = c && c.type && (c.type.displayName || c.type.name);\n\n      if (childType === VizTooltip.displayName) {\n        tooltipElement = c as React.ReactElement<VizTooltipProps>;\n      }\n    });\n    // If no tooltip provided, skip rendering\n    if (!tooltipElement) {\n      return null;\n    }\n    const tooltipElementProps = (tooltipElement as React.ReactElement<VizTooltipProps>).props;\n\n    const tooltipMode = tooltipElementProps.mode || 'single';\n\n    // If mode is single series and user is not hovering over item, skip rendering\n    if (!activeItem && tooltipMode === 'single') {\n      return null;\n    }\n\n    // Check if tooltip needs to be rendered with custom tooltip component, otherwise default to GraphTooltip\n    const tooltipContentRenderer = tooltipElementProps.tooltipComponent || GraphTooltip;\n    // Indicates column(field) index in y-axis dimension\n    const seriesIndex = activeItem ? activeItem.series.seriesIndex : 0;\n    // Indicates row index in active field values\n    const rowIndex = activeItem ? activeItem.dataIndex : undefined;\n\n    const activeDimensions: ActiveDimensions<GraphDimensions> = {\n      // Described x-axis active item\n      // When hovering over an item - let's take it's dataIndex, otherwise undefined\n      // Tooltip itself needs to figure out correct datapoint display information based on pos passed to it\n      xAxis: [seriesIndex, rowIndex],\n      // Describes y-axis active item\n      yAxis: activeItem ? [activeItem.series.seriesIndex, activeItem.dataIndex] : null,\n    };\n\n    const tooltipContentProps: VizTooltipContentProps<GraphDimensions> = {\n      dimensions: {\n        // time/value dimension columns are index-aligned - see getGraphSeriesModel\n        xAxis: createDimension(\n          'xAxis',\n          series.map((s) => s.timeField)\n        ),\n        yAxis: createDimension(\n          'yAxis',\n          series.map((s) => s.valueField)\n        ),\n      },\n      activeDimensions,\n      pos,\n      mode: tooltipElementProps.mode || TooltipDisplayMode.Single,\n      timeZone,\n    };\n\n    const tooltipContent = React.createElement(tooltipContentRenderer, { ...tooltipContentProps });\n\n    return React.cloneElement<VizTooltipProps>(tooltipElement as React.ReactElement<VizTooltipProps>, {\n      content: tooltipContent,\n      position: { x: pos.pageX, y: pos.pageY },\n      offset: { x: 10, y: 10 },\n    });\n  };\n\n  renderContextMenu = () => {\n    const { series } = this.props;\n    const { contextPos, contextItem, isContextVisible } = this.state;\n\n    if (!isContextVisible || !contextPos || !contextItem || series.length === 0) {\n      return null;\n    }\n\n    // Indicates column(field) index in y-axis dimension\n    const seriesIndex = contextItem ? contextItem.series.seriesIndex : 0;\n    // Indicates row index in context field values\n    const rowIndex = contextItem ? contextItem.dataIndex : undefined;\n\n    const contextDimensions: ContextDimensions<GraphDimensions> = {\n      // Described x-axis context item\n      xAxis: [seriesIndex, rowIndex],\n      // Describes y-axis context item\n      yAxis: contextItem ? [contextItem.series.seriesIndex, contextItem.dataIndex] : null,\n    };\n\n    const dimensions: GraphDimensions = {\n      // time/value dimension columns are index-aligned - see getGraphSeriesModel\n      xAxis: createDimension(\n        'xAxis',\n        series.map((s) => s.timeField)\n      ),\n      yAxis: createDimension(\n        'yAxis',\n        series.map((s) => s.valueField)\n      ),\n    };\n\n    const closeContext = () => this.setState({ isContextVisible: false });\n\n    const getContextMenuSource = () => {\n      return {\n        datapoint: contextItem.datapoint,\n        dataIndex: contextItem.dataIndex,\n        series: contextItem.series,\n        seriesIndex: contextItem.series.seriesIndex,\n        pageX: contextPos.pageX,\n        pageY: contextPos.pageY,\n      };\n    };\n\n    const contextContentProps: GraphContextMenuProps = {\n      x: contextPos.pageX,\n      y: contextPos.pageY,\n      onClose: closeContext,\n      getContextMenuSource: getContextMenuSource,\n      timeZone: this.props.timeZone,\n      dimensions,\n      contextDimensions,\n    };\n\n    return <GraphContextMenu {...contextContentProps} />;\n  };\n\n  getBarWidth = () => {\n    const { series } = this.props;\n    return Math.min(...series.map((s) => s.timeStep));\n  };\n\n  draw() {\n    if (this.element === null) {\n      return;\n    }\n\n    const {\n      width,\n      series,\n      timeRange,\n      showLines,\n      showBars,\n      showPoints,\n      isStacked,\n      lineWidth,\n      timeZone,\n      onHorizontalRegionSelected,\n    } = this.props;\n\n    if (!width) {\n      return;\n    }\n\n    const ticks = width / 100;\n    const min = timeRange.from.valueOf();\n    const max = timeRange.to.valueOf();\n    const yaxes = this.getYAxes(series);\n\n    const flotOptions: any = {\n      legend: {\n        show: false,\n      },\n      series: {\n        stack: isStacked,\n        lines: {\n          show: showLines,\n          lineWidth: lineWidth,\n          zero: false,\n        },\n        points: {\n          show: showPoints,\n          fill: 1,\n          fillColor: false,\n          radius: 2,\n        },\n        bars: {\n          show: showBars,\n          fill: 1,\n          // Dividig the width by 1.5 to make the bars not touch each other\n          barWidth: showBars ? this.getBarWidth() / 1.5 : 1,\n          zero: false,\n          lineWidth: lineWidth,\n        },\n        shadowSize: 0,\n      },\n      xaxis: {\n        timezone: timeZone,\n        show: true,\n        mode: 'time',\n        min: min,\n        max: max,\n        label: 'Datetime',\n        ticks: ticks,\n        timeformat: graphTimeFormat(ticks, min, max),\n        tickFormatter: graphTickFormatter,\n      },\n      yaxes,\n      grid: {\n        minBorderMargin: 0,\n        markings: [],\n        backgroundColor: null,\n        borderWidth: 0,\n        hoverable: true,\n        clickable: true,\n        color: '#a1a1a1',\n        margin: { left: 0, right: 0 },\n        labelMarginX: 0,\n        mouseActiveRadius: 30,\n      },\n      selection: {\n        mode: onHorizontalRegionSelected ? 'x' : null,\n        color: '#666',\n      },\n      crosshair: {\n        mode: 'x',\n      },\n    };\n\n    try {\n      $.plot(\n        this.element,\n        series.filter((s) => s.isVisible),\n        flotOptions\n      );\n    } catch (err) {\n      console.error('Graph rendering error', err, flotOptions, series);\n      throw new Error('Error rendering panel');\n    }\n  }\n\n  render() {\n    const { ariaLabel, height, width, series } = this.props;\n    const noDataToBeDisplayed = series.length === 0;\n    const tooltip = this.renderTooltip();\n    const context = this.renderContextMenu();\n    return (\n      <div className=\"graph-panel\" aria-label={ariaLabel}>\n        <div\n          className=\"graph-panel__chart\"\n          ref={(e) => (this.element = e)}\n          style={{ height, width }}\n          onMouseLeave={() => {\n            this.setState({ isTooltipVisible: false });\n          }}\n        />\n        {noDataToBeDisplayed && <div className=\"datapoints-warning\">No data</div>}\n        {tooltip}\n        {context}\n      </div>\n    );\n  }\n}\n\nexport default Graph;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}