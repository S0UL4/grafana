{"ast":null,"code":"import { ArrayVector, FieldType, incrRoundDn } from '@grafana/data';\nconst INSERT_MODES = {\n  threshold: (prev, next, threshold) => prev + threshold,\n  midpoint: (prev, next, threshold) => (prev + next) / 2,\n  // previous time + 1ms to prevent StateTimeline from forward-interpolating prior state\n  plusone: (prev, next, threshold) => prev + 1\n};\nexport function applyNullInsertThreshold(opts) {\n  if (opts.frame.length === 0) {\n    return opts.frame;\n  }\n\n  let thorough = true;\n  let {\n    frame,\n    refFieldName,\n    refFieldPseudoMax,\n    refFieldPseudoMin,\n    insertMode\n  } = opts;\n\n  if (!insertMode) {\n    insertMode = INSERT_MODES.threshold;\n  }\n\n  const refField = frame.fields.find(field => {\n    // note: getFieldDisplayName() would require full DF[]\n    return refFieldName != null ? field.name === refFieldName : field.type === FieldType.time;\n  });\n\n  if (refField == null) {\n    return frame;\n  }\n\n  refField.state = Object.assign({}, refField.state, {\n    nullThresholdApplied: true\n  });\n  const thresholds = frame.fields.map(field => {\n    var _ref, _field$config$custom$, _field$config$custom;\n\n    return (_ref = (_field$config$custom$ = (_field$config$custom = field.config.custom) === null || _field$config$custom === void 0 ? void 0 : _field$config$custom.insertNulls) !== null && _field$config$custom$ !== void 0 ? _field$config$custom$ : refField.config.interval) !== null && _ref !== void 0 ? _ref : null;\n  });\n  const uniqueThresholds = new Set(thresholds);\n  uniqueThresholds.delete(null);\n\n  if (uniqueThresholds.size === 0) {\n    return frame;\n  }\n\n  if (uniqueThresholds.size === 1) {\n    const threshold = uniqueThresholds.values().next().value;\n\n    if (threshold <= 0) {\n      return frame;\n    }\n\n    const refValues = refField.values.toArray();\n    const frameValues = frame.fields.map(field => field.values.toArray());\n    const filledFieldValues = nullInsertThreshold(refValues, frameValues, threshold, refFieldPseudoMin, refFieldPseudoMax, insertMode, thorough);\n\n    if (filledFieldValues === frameValues) {\n      return frame;\n    }\n\n    return Object.assign({}, frame, {\n      length: filledFieldValues[0].length,\n      fields: frame.fields.map((field, i) => Object.assign({}, field, {\n        values: new ArrayVector(filledFieldValues[i])\n      }))\n    });\n  } // TODO: unique threshold-per-field (via overrides) is unimplemented\n  // should be done by processing each (refField + thresholdA-field1 + thresholdA-field2...)\n  // as a separate nullInsertThreshold() dataset, then re-join into single dataset via join()\n\n\n  return frame;\n}\n\nfunction nullInsertThreshold(refValues, frameValues, threshold, refFieldPseudoMin = null, // will insert a trailing null when refFieldPseudoMax > last datapoint + threshold\nrefFieldPseudoMax = null, getInsertValue, // will insert the value at every missing interval\nthorough) {\n  const len = refValues.length;\n  const refValuesNew = []; // Continiuously subtract the threshold from the first data\n  // point filling in insert values accordingly\n\n  if (refFieldPseudoMin != null && refFieldPseudoMin < refValues[0]) {\n    // this will be 0 or 1 threshold increment left of visible range\n    let prevSlot = incrRoundDn(refFieldPseudoMin, threshold);\n\n    while (prevSlot < refValues[0]) {\n      // (prevSlot - threshold) is used to simulate the previous 'real' data point, as getInsertValue expects\n      refValuesNew.push(getInsertValue(prevSlot - threshold, prevSlot, threshold));\n      prevSlot += threshold;\n    }\n  } // Insert initial value\n\n\n  refValuesNew.push(refValues[0]);\n  let prevValue = refValues[0]; // Fill nulls when a value is greater than\n  // the threshold value\n\n  for (let i = 1; i < len; i++) {\n    const curValue = refValues[i];\n\n    while (curValue - prevValue > threshold) {\n      refValuesNew.push(getInsertValue(prevValue, curValue, threshold));\n      prevValue += threshold;\n\n      if (!thorough) {\n        break;\n      }\n    }\n\n    refValuesNew.push(curValue);\n    prevValue = curValue;\n  } // At the end of the sequence\n\n\n  if (refFieldPseudoMax != null && refFieldPseudoMax > prevValue) {\n    while (prevValue + threshold < refFieldPseudoMax) {\n      refValuesNew.push(getInsertValue(prevValue, refFieldPseudoMax, threshold));\n      prevValue += threshold;\n    }\n  }\n\n  const filledLen = refValuesNew.length;\n\n  if (filledLen === len) {\n    return frameValues;\n  }\n\n  const filledFieldValues = [];\n\n  for (let fieldValues of frameValues) {\n    let filledValues;\n\n    if (fieldValues !== refValues) {\n      filledValues = Array(filledLen);\n\n      for (let i = 0, j = 0; i < filledLen; i++) {\n        filledValues[i] = refValues[j] === refValuesNew[i] ? fieldValues[j++] : null;\n      }\n    } else {\n      filledValues = refValuesNew;\n    }\n\n    filledFieldValues.push(filledValues);\n  }\n\n  return filledFieldValues;\n}","map":{"version":3,"names":["ArrayVector","FieldType","incrRoundDn","INSERT_MODES","threshold","prev","next","midpoint","plusone","applyNullInsertThreshold","opts","frame","length","thorough","refFieldName","refFieldPseudoMax","refFieldPseudoMin","insertMode","refField","fields","find","field","name","type","time","state","nullThresholdApplied","thresholds","map","config","custom","insertNulls","interval","uniqueThresholds","Set","delete","size","values","value","refValues","toArray","frameValues","filledFieldValues","nullInsertThreshold","i","getInsertValue","len","refValuesNew","prevSlot","push","prevValue","curValue","filledLen","fieldValues","filledValues","Array","j"],"sources":["/home/soula/grafana/packages/grafana-ui/src/components/GraphNG/nullInsertThreshold.ts"],"sourcesContent":["import { ArrayVector, DataFrame, FieldType, incrRoundDn } from '@grafana/data';\n\ntype InsertMode = (prev: number, next: number, threshold: number) => number;\n\nconst INSERT_MODES = {\n  threshold: (prev: number, next: number, threshold: number) => prev + threshold,\n  midpoint: (prev: number, next: number, threshold: number) => (prev + next) / 2,\n  // previous time + 1ms to prevent StateTimeline from forward-interpolating prior state\n  plusone: (prev: number, next: number, threshold: number) => prev + 1,\n};\n\ninterface NullInsertOptions {\n  frame: DataFrame;\n  refFieldName?: string | null;\n  refFieldPseudoMax?: number;\n  refFieldPseudoMin?: number;\n  insertMode?: InsertMode;\n}\n\nexport function applyNullInsertThreshold(opts: NullInsertOptions): DataFrame {\n  if (opts.frame.length === 0) {\n    return opts.frame;\n  }\n\n  let thorough = true;\n  let { frame, refFieldName, refFieldPseudoMax, refFieldPseudoMin, insertMode } = opts;\n\n  if (!insertMode) {\n    insertMode = INSERT_MODES.threshold;\n  }\n\n  const refField = frame.fields.find((field) => {\n    // note: getFieldDisplayName() would require full DF[]\n    return refFieldName != null ? field.name === refFieldName : field.type === FieldType.time;\n  });\n\n  if (refField == null) {\n    return frame;\n  }\n\n  refField.state = {\n    ...refField.state,\n    nullThresholdApplied: true,\n  };\n\n  const thresholds = frame.fields.map((field) => field.config.custom?.insertNulls ?? refField.config.interval ?? null);\n\n  const uniqueThresholds = new Set<number>(thresholds);\n\n  uniqueThresholds.delete(null as any);\n\n  if (uniqueThresholds.size === 0) {\n    return frame;\n  }\n\n  if (uniqueThresholds.size === 1) {\n    const threshold = uniqueThresholds.values().next().value;\n\n    if (threshold <= 0) {\n      return frame;\n    }\n\n    const refValues = refField.values.toArray();\n\n    const frameValues = frame.fields.map((field) => field.values.toArray());\n\n    const filledFieldValues = nullInsertThreshold(\n      refValues,\n      frameValues,\n      threshold,\n      refFieldPseudoMin,\n      refFieldPseudoMax,\n      insertMode,\n      thorough\n    );\n\n    if (filledFieldValues === frameValues) {\n      return frame;\n    }\n\n    return {\n      ...frame,\n      length: filledFieldValues[0].length,\n      fields: frame.fields.map((field, i) => ({\n        ...field,\n        values: new ArrayVector(filledFieldValues[i]),\n      })),\n    };\n  }\n\n  // TODO: unique threshold-per-field (via overrides) is unimplemented\n  // should be done by processing each (refField + thresholdA-field1 + thresholdA-field2...)\n  // as a separate nullInsertThreshold() dataset, then re-join into single dataset via join()\n  return frame;\n}\n\nfunction nullInsertThreshold(\n  refValues: number[],\n  frameValues: any[][],\n  threshold: number,\n  refFieldPseudoMin: number | null = null,\n  // will insert a trailing null when refFieldPseudoMax > last datapoint + threshold\n  refFieldPseudoMax: number | null = null,\n  getInsertValue: InsertMode,\n  // will insert the value at every missing interval\n  thorough: boolean\n) {\n  const len = refValues.length;\n  const refValuesNew: number[] = [];\n\n  // Continiuously subtract the threshold from the first data\n  // point filling in insert values accordingly\n  if (refFieldPseudoMin != null && refFieldPseudoMin < refValues[0]) {\n    // this will be 0 or 1 threshold increment left of visible range\n    let prevSlot = incrRoundDn(refFieldPseudoMin, threshold);\n\n    while (prevSlot < refValues[0]) {\n      // (prevSlot - threshold) is used to simulate the previous 'real' data point, as getInsertValue expects\n      refValuesNew.push(getInsertValue(prevSlot - threshold, prevSlot, threshold));\n      prevSlot += threshold;\n    }\n  }\n\n  // Insert initial value\n  refValuesNew.push(refValues[0]);\n\n  let prevValue: number = refValues[0];\n\n  // Fill nulls when a value is greater than\n  // the threshold value\n  for (let i = 1; i < len; i++) {\n    const curValue = refValues[i];\n\n    while (curValue - prevValue > threshold) {\n      refValuesNew.push(getInsertValue(prevValue, curValue, threshold));\n\n      prevValue += threshold;\n\n      if (!thorough) {\n        break;\n      }\n    }\n\n    refValuesNew.push(curValue);\n\n    prevValue = curValue;\n  }\n\n  // At the end of the sequence\n  if (refFieldPseudoMax != null && refFieldPseudoMax > prevValue) {\n    while (prevValue + threshold < refFieldPseudoMax) {\n      refValuesNew.push(getInsertValue(prevValue, refFieldPseudoMax, threshold));\n      prevValue += threshold;\n    }\n  }\n\n  const filledLen = refValuesNew.length;\n\n  if (filledLen === len) {\n    return frameValues;\n  }\n\n  const filledFieldValues: any[][] = [];\n\n  for (let fieldValues of frameValues) {\n    let filledValues;\n\n    if (fieldValues !== refValues) {\n      filledValues = Array(filledLen);\n\n      for (let i = 0, j = 0; i < filledLen; i++) {\n        filledValues[i] = refValues[j] === refValuesNew[i] ? fieldValues[j++] : null;\n      }\n    } else {\n      filledValues = refValuesNew;\n    }\n\n    filledFieldValues.push(filledValues);\n  }\n\n  return filledFieldValues;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}