{"ast":null,"code":"import { histogram } from 'd3';\n\n/**\n * Convert series into array of series values.\n * @param data Array of series\n */\nexport function getSeriesValues(dataList) {\n  const VALUE_INDEX = 0;\n  const values = []; // Count histogam stats\n\n  for (let i = 0; i < dataList.length; i++) {\n    const series = dataList[i];\n    const datapoints = series.datapoints;\n\n    for (let j = 0; j < datapoints.length; j++) {\n      if (datapoints[j][VALUE_INDEX] !== null) {\n        values.push(datapoints[j][VALUE_INDEX]);\n      }\n    }\n  }\n\n  return values;\n}\n/**\n * Convert array of values into timeseries-like histogram:\n * [[val_1, count_1], [val_2, count_2], ..., [val_n, count_n]]\n * @param values\n * @param bucketSize\n */\n\nexport function convertValuesToHistogram(values, bucketSize, min, max) {\n  const minBound = getBucketBound(min, bucketSize);\n  const maxBound = getBucketBound(max, bucketSize);\n  const histGenerator = histogram().domain([minBound, maxBound]).thresholds(Math.round(max - min) / bucketSize);\n  return histGenerator(values).map(bin => {\n    return [bin.x0, bin.length];\n  });\n}\n/**\n * Convert series into array of histogram data.\n * @param data Array of series\n * @param bucketSize\n */\n\nexport function convertToHistogramData(data, bucketSize, hiddenSeries, min, max) {\n  return data.map(series => {\n    const values = getSeriesValues([series]);\n    series.histogram = true;\n\n    if (!hiddenSeries[series.alias]) {\n      const histogram = convertValuesToHistogram(values, bucketSize, min, max);\n      series.data = histogram;\n    } else {\n      series.data = [];\n    }\n\n    return series;\n  });\n}\n\nfunction getBucketBound(value, bucketSize) {\n  return Math.floor(value / bucketSize) * bucketSize;\n}","map":{"version":3,"names":["histogram","getSeriesValues","dataList","VALUE_INDEX","values","i","length","series","datapoints","j","push","convertValuesToHistogram","bucketSize","min","max","minBound","getBucketBound","maxBound","histGenerator","domain","thresholds","Math","round","map","bin","x0","convertToHistogramData","data","hiddenSeries","alias","value","floor"],"sources":["/home/soula/grafana/public/app/plugins/panel/graph/histogram.ts"],"sourcesContent":["import { histogram } from 'd3';\n\nimport TimeSeries from 'app/core/time_series2';\n\n/**\n * Convert series into array of series values.\n * @param data Array of series\n */\nexport function getSeriesValues(dataList: TimeSeries[]): number[] {\n  const VALUE_INDEX = 0;\n  const values = [];\n\n  // Count histogam stats\n  for (let i = 0; i < dataList.length; i++) {\n    const series = dataList[i];\n    const datapoints = series.datapoints;\n    for (let j = 0; j < datapoints.length; j++) {\n      if (datapoints[j][VALUE_INDEX] !== null) {\n        values.push(datapoints[j][VALUE_INDEX]);\n      }\n    }\n  }\n\n  return values;\n}\n\n/**\n * Convert array of values into timeseries-like histogram:\n * [[val_1, count_1], [val_2, count_2], ..., [val_n, count_n]]\n * @param values\n * @param bucketSize\n */\nexport function convertValuesToHistogram(values: number[], bucketSize: number, min: number, max: number): any[] {\n  const minBound = getBucketBound(min, bucketSize);\n  const maxBound = getBucketBound(max, bucketSize);\n\n  const histGenerator = histogram()\n    .domain([minBound, maxBound])\n    .thresholds(Math.round(max - min) / bucketSize);\n\n  return histGenerator(values).map((bin) => {\n    return [bin.x0, bin.length];\n  });\n}\n\n/**\n * Convert series into array of histogram data.\n * @param data Array of series\n * @param bucketSize\n */\nexport function convertToHistogramData(\n  data: any,\n  bucketSize: number,\n  hiddenSeries: any,\n  min: number,\n  max: number\n): any[] {\n  return data.map((series: any) => {\n    const values = getSeriesValues([series]);\n    series.histogram = true;\n    if (!hiddenSeries[series.alias]) {\n      const histogram = convertValuesToHistogram(values, bucketSize, min, max);\n      series.data = histogram;\n    } else {\n      series.data = [];\n    }\n    return series;\n  });\n}\n\nfunction getBucketBound(value: number, bucketSize: number): number {\n  return Math.floor(value / bucketSize) * bucketSize;\n}\n"],"mappings":"AAAA,SAASA,SAAT,QAA0B,IAA1B;;AAIA;AACA;AACA;AACA;AACA,OAAO,SAASC,eAAT,CAAyBC,QAAzB,EAA2D;EAChE,MAAMC,WAAW,GAAG,CAApB;EACA,MAAMC,MAAM,GAAG,EAAf,CAFgE,CAIhE;;EACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,QAAQ,CAACI,MAA7B,EAAqCD,CAAC,EAAtC,EAA0C;IACxC,MAAME,MAAM,GAAGL,QAAQ,CAACG,CAAD,CAAvB;IACA,MAAMG,UAAU,GAAGD,MAAM,CAACC,UAA1B;;IACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,UAAU,CAACF,MAA/B,EAAuCG,CAAC,EAAxC,EAA4C;MAC1C,IAAID,UAAU,CAACC,CAAD,CAAV,CAAcN,WAAd,MAA+B,IAAnC,EAAyC;QACvCC,MAAM,CAACM,IAAP,CAAYF,UAAU,CAACC,CAAD,CAAV,CAAcN,WAAd,CAAZ;MACD;IACF;EACF;;EAED,OAAOC,MAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASO,wBAAT,CAAkCP,MAAlC,EAAoDQ,UAApD,EAAwEC,GAAxE,EAAqFC,GAArF,EAAyG;EAC9G,MAAMC,QAAQ,GAAGC,cAAc,CAACH,GAAD,EAAMD,UAAN,CAA/B;EACA,MAAMK,QAAQ,GAAGD,cAAc,CAACF,GAAD,EAAMF,UAAN,CAA/B;EAEA,MAAMM,aAAa,GAAGlB,SAAS,GAC5BmB,MADmB,CACZ,CAACJ,QAAD,EAAWE,QAAX,CADY,EAEnBG,UAFmB,CAERC,IAAI,CAACC,KAAL,CAAWR,GAAG,GAAGD,GAAjB,IAAwBD,UAFhB,CAAtB;EAIA,OAAOM,aAAa,CAACd,MAAD,CAAb,CAAsBmB,GAAtB,CAA2BC,GAAD,IAAS;IACxC,OAAO,CAACA,GAAG,CAACC,EAAL,EAASD,GAAG,CAAClB,MAAb,CAAP;EACD,CAFM,CAAP;AAGD;AAED;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASoB,sBAAT,CACLC,IADK,EAELf,UAFK,EAGLgB,YAHK,EAILf,GAJK,EAKLC,GALK,EAME;EACP,OAAOa,IAAI,CAACJ,GAAL,CAAUhB,MAAD,IAAiB;IAC/B,MAAMH,MAAM,GAAGH,eAAe,CAAC,CAACM,MAAD,CAAD,CAA9B;IACAA,MAAM,CAACP,SAAP,GAAmB,IAAnB;;IACA,IAAI,CAAC4B,YAAY,CAACrB,MAAM,CAACsB,KAAR,CAAjB,EAAiC;MAC/B,MAAM7B,SAAS,GAAGW,wBAAwB,CAACP,MAAD,EAASQ,UAAT,EAAqBC,GAArB,EAA0BC,GAA1B,CAA1C;MACAP,MAAM,CAACoB,IAAP,GAAc3B,SAAd;IACD,CAHD,MAGO;MACLO,MAAM,CAACoB,IAAP,GAAc,EAAd;IACD;;IACD,OAAOpB,MAAP;EACD,CAVM,CAAP;AAWD;;AAED,SAASS,cAAT,CAAwBc,KAAxB,EAAuClB,UAAvC,EAAmE;EACjE,OAAOS,IAAI,CAACU,KAAL,CAAWD,KAAK,GAAGlB,UAAnB,IAAiCA,UAAxC;AACD"},"metadata":{},"sourceType":"module"}